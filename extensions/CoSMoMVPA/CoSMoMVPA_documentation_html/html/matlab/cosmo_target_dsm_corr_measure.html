    <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>cosmo target dsm corr measure &#8212; CoSMo Multivariate Pattern Analysis toolbox 1.0rc1 documentation</title>
    
    <link rel="stylesheet" href="../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.0rc1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="next" title="cosmo type" href="cosmo_type.html" />
    <link rel="prev" title="cosmo tail" href="cosmo_tail.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="cosmo_type.html" title="cosmo type"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="cosmo_tail.html" title="cosmo tail"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">CoSMoMVPA</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../documentation.html" >Documentation</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../cimec2016.html" >CIMeC hands-on methods course, part 1 (6 April-2 May 2016)</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="../matindex.html" accesskey="U">CoSMoMVPA functions</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="cosmo-target-dsm-corr-measure">
<span id="id1"></span><h1>cosmo target dsm corr measure<a class="headerlink" href="#cosmo-target-dsm-corr-measure" title="Permalink to this headline">Â¶</a></h1>
<div class="highlight-matlab"><div class="highlight"><pre><span></span>function ds_sa = cosmo_target_dsm_corr_measure(ds, varargin)
% measure correlation with target dissimilarity matrix
%
% ds_sa = cosmo_target_dsm_corr_measure(dataset, args)
%
% Inputs:
%   ds             dataset struct with field .samples PxQ for P samples and
%                  Q features
%   args           struct with fields:
%     .target_dsm  (optional) Either:
%                  - target dissimilarity matrix of size PxP. It should
%                    have zeros on the diagonal and be symmetric.
%                  - target dissimilarity vector of size Nx1, with
%                    N=P*(P-1)/2 the number of pairs of samples in ds.
%                  This option is mutually exclusive with the &#39;glm_dsm&#39;
%                  option
%     .metric      (optional) distance metric used in pdist to compute
%                  pair-wise distances between samples in ds. It accepts
%                  any metric supported by pdist (default: &#39;correlation&#39;)
%     .type        (optional) type of correlation between target_dsm and
%                  ds, one of &#39;Pearson&#39; (default), &#39;Spearman&#39;, or
%                  &#39;Kendall&#39;.
%     .regress_dsm (optional) target dissimilarity matrix or vector (as
%                  .target_dsm), or a cell with matrices or vectors, that
%                  should be regressed out. If this option is provided then
%                  the output is the partial correlation between the
%                  pairwise distances between samples in ds and target_dsm,
%                  after controlling for the effect of the matrix
%                  (or matrices) in regress_dsm. (Using this option yields
%                  similar behaviour as the Matlab function
%                  &#39;partial_corr&#39;)
%     .glm_dsm     (optional) cell with model dissimilarity matrices or
%                  vectors (as .target_dsm) for using a general linear
%                  model to get regression coefficients for each element in
%                  .glm_dsm. Both the input data and the dissimilarity
%                  matrices are z-scored before estimating the regression
%                  coefficients.
%                  This option is required when &#39;target_dsm&#39; is not
%                  provided; it cannot cannot used together with
%                  .target_dsm or regress_dsm.
%                  When using this option, the &#39;type&#39; option is ignored.
%                  For this option, the output has as many rows (samples)
%                  as there are elements (dissimilarity matrices) in
%                  .glm_dsm.
%     .center_data If set to true, then the mean of each feature (column in
%                  ds.samples) is subtracted from each column prior to
%                  computing the pairwise distances for all samples in ds.
%                  Default: false
%
% Output:
%    ds_sa         Dataset struct with fields:
%      .samples    Scalar correlation value between the pair-wise
%                  distances of the samples in ds and target_dsm; or
%                  (when &#39;glm_dsms&#39; is supplied) a column vector with
%                  normalized beta coefficients. These values
%                  are untransformed (e.g. there is no Fisher transform).
%      .sa         Struct with field:
%        .labels   {&#39;rho&#39;}; or (when &#39;glm_dsm&#39; is supplied) a cell
%                  {&#39;beta1&#39;,&#39;beta2&#39;,...}.
%
% Examples:
%     % generate synthetic dataset with 6 classes (conditions),
%     % one sample per class
%     ds=cosmo_synthetic_dataset(&#39;ntargets&#39;,6,&#39;nchunks&#39;,1);
%     %
%     % create target dissimilarity matrix to test whether
%     % - class 1 and 2 are similar (and different from classes 3-6)
%     % - class 3 and 4 are similar (and different from classes 1,2,5,6)
%     % - class 5 and 6 are similar (and different from classes 1-4)
%     target_dsm=1-kron(eye(3),ones(2));
%     %
%     % show the target dissimilarity matrix
%     cosmo_disp(target_dsm);
%     &gt; [ 0         0         1         1         1         1
%     &gt;   0         0         1         1         1         1
%     &gt;   1         1         0         0         1         1
%     &gt;   1         1         0         0         1         1
%     &gt;   1         1         1         1         0         0
%     &gt;   1         1         1         1         0         0 ]
%     %
%     % compute similarity between pairw-wise similarity of the
%     % patterns in the dataset and the target dissimilarity matrix
%     dcm_ds=cosmo_target_dsm_corr_measure(ds,&#39;target_dsm&#39;,target_dsm);
%     %
%     % Pearson correlation is about 0.56
%     cosmo_disp(dcm_ds)
%     &gt; .samples
%     &gt;   [ 0.562 ]
%     &gt; .sa
%     &gt;   .labels
%     &gt;     { &#39;rho&#39; }
%     &gt;   .metric
%     &gt;     { &#39;correlation&#39; }
%     &gt;   .type
%     &gt;     { &#39;Pearson&#39; }
%     %
%     % do not consider classses 3 and 5
%     target_dsm([3,5],:)=NaN;
%     target_dsm(:,[3,5])=NaN;
%     target_dsm(3,3)=0;
%     target_dsm(5,5)=0;
%     %
%     % show the updatedtarget dissimilarity matrix
%     cosmo_disp(target_dsm);
%     &gt; [   0         0       NaN         1       NaN         1
%     &gt;     0         0       NaN         1       NaN         1
%     &gt;   NaN       NaN         0       NaN       NaN       NaN
%     &gt;     1         1       NaN         0       NaN         1
%     &gt;   NaN       NaN       NaN       NaN         0       NaN
%     &gt;     1         1       NaN         1       NaN         0 ]
%     %
%     % compute similarity between pairw-wise similarity of the
%     % patterns in the dataset and the target dissimilarity matrix
%     dcm_ds=cosmo_target_dsm_corr_measure(ds,&#39;target_dsm&#39;,target_dsm);
%     %
%     % Correlation is different because classes 3 and 5 were left out
%     cosmo_disp(dcm_ds)
%     &gt; .samples
%     &gt;   [ 0.705 ]
%     &gt; .sa
%     &gt;   .labels
%     &gt;     { &#39;rho&#39; }
%     &gt;   .metric
%     &gt;     { &#39;correlation&#39; }
%     &gt;   .type
%     &gt;     { &#39;Pearson&#39; }
%
%
%
% Notes:
%   - for group analysis, correlations can be fisher-transformed
%     through:
%       dcm_ds.samples=atanh(dcm_ds.samples)
%   - it is recommended to set the &#39;center_data&#39; to true when using
%     the default &#39;correlation&#39; metric, as this removes a main effect
%     common to all samples; but note that this option is disabled by
%     default due to historical reasons.
%   - elements in the *_dsm dissimilarity matrices can have NaNs, in which
%     case their value, as well as the corresponding location in the
%     dataset&#39;s samples, are ignored. Masking is done prior to z-score
%     normalization.
%
%
% #   For CoSMoMVPA&#39;s copyright information and license terms,   #
% #   see the COPYING file distributed with CoSMoMVPA.           #

    % process input arguments
    params=cosmo_structjoin(&#39;type&#39;,&#39;Pearson&#39;,... % set default
                            &#39;metric&#39;,&#39;correlation&#39;,...
                            &#39;center_data&#39;,false,...
                            varargin);

    check_input(ds);
    check_params(params);

    % - compute the pair-wise distance between all dataset samples using
    %   cosmo_pdist

    samples=ds.samples;
    if params.center_data
        samples=bsxfun(@minus,samples,mean(samples,1));
    end

    samples_pdist = cosmo_pdist(samples, params.metric)&#39;;

    has_model_dsms=isfield(params,&#39;glm_dsm&#39;);

    if has_model_dsms
        ds_sa=linear_regression_dsm(samples_pdist, params);
    else
        ds_sa=correlation_dsm(samples_pdist,params);
    end

    check_output(ds,ds_sa);

function check_output(input_ds,output_ds_sa)
    if any(isnan(output_ds_sa.samples))
        if any(isnan(input_ds.samples(:)))
            msg=[&#39;Input dataset has NaN values, which results in &#39;...
                    &#39;NaN values in the output. Consider masking the &#39;...
                    &#39;dataset to remove NaN values&#39;];
        elseif any(var(input_ds.samples)==0)
            msg=[&#39;Input dataset has constant or infinite features, &#39;,...
                    &#39;which results in NaN values in the output. &#39;...
                    &#39;Consider masking the dataset to remove constant &#39;...
                    &#39;or non-finite features, for example using &#39;...
                    &#39;cosmo_remove_useless_data&#39;];
        else
            msg=[&#39;Output has NaN values, even though the input does &#39;...
                    &#39;not. This can be due to the presence of constant &#39;...
                    &#39;features and/or non-finite values in the input, &#39;...
                    &#39;and/or target similarity structures with constant &#39;...
                    &#39;and/of non-finite data. When in doubt, please &#39;...
                    &#39;contact the CoSMoMVPA developers&#39;];
        end
        cosmo_warning(msg);
    end


function ds_sa=correlation_dsm(samples_pdist,params)
    npairs_dataset=numel(samples_pdist);

    % get target dsm in vector form
    [target_dsm_vec,target_msk]=get_dsm_vec_from_struct(params,...
                                                &#39;target_dsm&#39;,...
                                                npairs_dataset);

    if ~isempty(target_msk)
        samples_pdist=samples_pdist(target_msk);
    end


    % ensure the size of the dataset matches the matrix
    has_regress_dsm=isfield(params,&#39;regress_dsm&#39;);
    if has_regress_dsm
        [regress_dsm_mat,regress_msk]=get_dsm_mat_from_vector_or_cell(...
                                                    params.regress_dsm,...
                                                    npairs_dataset);

        if ~isequal(target_msk,regress_msk)
            error([&#39;NaN mask non-match between &#39;&#39;target_dsm&#39;&#39; &#39;...
                    &#39;and &#39;&#39;regress_dsm&#39;&#39;&#39;]);
        end

        [samples_pdist(:),target_dsm_vec(:)]=regress_out(...
                                                samples_pdist,...
                                                target_dsm_vec,...
                                                regress_dsm_mat);
    end


    % compute correlations between &#39;pd&#39; and &#39;target_dsm_vec&#39;, store in &#39;rho&#39;
    rho=cosmo_corr(samples_pdist,target_dsm_vec, params.type);

    % store results
    ds_sa=struct();
    ds_sa.samples=rho;
    ds_sa.sa.labels={&#39;rho&#39;};
    ds_sa.sa.metric={params.metric};
    ds_sa.sa.type={params.type};


function ds_sa=linear_regression_dsm(samples_pdist, params)
    npairs_dataset=numel(samples_pdist);

    [dsm_mat,msk]=get_dsm_mat_from_vector_or_cell(params.glm_dsm,...
                                                npairs_dataset);

    % normalize matrices
    dsm_mat_zscore=cosmo_normalize(dsm_mat,&#39;zscore&#39;);


    if ~isempty(msk)
        samples_pdist=samples_pdist(msk);
    end

    % normalize data
    samples_pdist_zscore=cosmo_normalize(samples_pdist(:),&#39;zscore&#39;);

    % estimate betas based on masked samples
    betas=dsm_mat_zscore \ samples_pdist_zscore;

    % construct labels
    nvec=size(dsm_mat_zscore,2);
    labels=cell(nvec,1);
    for k=1:nvec
        labels{k}=sprintf(&#39;beta%d&#39;, k);
    end

    ds_sa=struct();
    ds_sa.samples=betas;
    ds_sa.sa.labels=labels;
    ds_sa.sa.metric=repmat({params.metric},nvec,1);


function [ds_resid,target_resid]=regress_out(ds_pdist,...
                                                target_dsm_vec,...
                                                regress_dsm_mat)
    % set up design matrix
    nsamples=size(ds_pdist,1);
    regr=[regress_dsm_mat ones(nsamples,1)];

    % put ds_pdist and target_dsm_vec together
    both=[ds_pdist target_dsm_vec];

    % compute residuals
    both_resid=both-regr*(regr\both);

    ds_resid=both_resid(:,1);
    target_resid=both_resid(:,2);

function [dsm_mat,common_msk]=get_dsm_mat_from_vector_or_cell(dsm_cell, ...
                                                        npairs_dataset)
    if isnumeric(dsm_cell)
        dsm_cell={dsm_cell};
    elseif ~iscell(dsm_cell)
        error(&#39;dsm inputs must be provided in a cell&#39;);
    end

    n=numel(dsm_cell);
    for k=1:n
        name=sprintf(&#39;.model_dsms{%d}&#39;,k);
        [vec,msk_k]=get_dsm_vec(dsm_cell{k},npairs_dataset,name);

        if k==1
            nrows=numel(vec);
            dsm_mat=zeros(nrows,n);

            common_msk=msk_k;
        end


        if ~isempty(msk_k) &amp;&amp; k~=1 &amp;&amp; ~isequal(common_msk,msk_k)
            error(&#39;DSMs NaN mask mismatch for matrices %d and %d&#39;,...
                        1, k);
        end

        dsm_mat(:,k)=vec;
    end

function [dsm_vec,msk]=get_dsm_vec_from_struct(params,name,npairs_dataset)
    % helper funciton to get dsm in vector form
    if ~isfield(params,name)
        error(&#39;Missing parameter &#39;&#39;%s&#39;&#39;&#39;,name);
    end

    dsm=params.(name);
    [dsm_vec,msk]=get_dsm_vec(dsm, npairs_dataset, [&#39;&#39;&#39;&#39; name &#39;&#39;&#39;&#39;]);


function [dsm_vec,msk]=get_dsm_vec(dsm,npairs_dataset,name)
    % helper function to get dsm in column vector form
    if ~isnumeric(dsm)
        error(&#39;dsm inputs must be numeric, found %s&#39;, class(dsm));
    end

    sz=size(dsm);

    if sz(1)==1
        dsm_vec=dsm&#39;;
    elseif sz(2)==1
        dsm_vec=dsm;
    else
        % convert square matrix to vector
        dsm_vec=cosmo_squareform(dsm,&#39;tovector&#39;)&#39;;
    end

    if npairs_dataset ~= numel(dsm_vec),
        error([&#39;Sample size mismatch between dataset (%d pairs) &#39;...
                    &#39;and %s in vector form (%d pairs)&#39;], ...
                        npairs_dataset,name,numel(dsm_vec));
    end

    msk=[];

    nan_msk=isnan(dsm_vec);
    if any(nan_msk)
        % apply mask
        msk=~nan_msk;
        dsm_vec=dsm_vec(msk);
    end


function check_input(ds)
    % for safety require targets to be 1:N
    has_sa=isstruct(ds) &amp;&amp; isfield(ds,&#39;sa&#39;);
    if ~has_sa || ~isfield(ds.sa,&#39;targets&#39;) || ~isfield(ds,&#39;samples&#39;)
        error(&#39;Missing field .sa.targets or .samples&#39;);
    end

    nsamples=size(ds.samples,1);

    if ~isequal(ds.sa.targets&#39;,1:nsamples)
        msg=sprintf(&#39;.sa.targets must be (1:%d)&#39;&#39;&#39;,nsamples);
        if isequal(unique(ds.sa.targets),(1:nsamples)&#39;);
            msg=sprintf([&#39;%s\nMultiple samples with the same chunks &#39;...
                            &#39;can be averaged using cosmo_fx&#39;],msg);
        else
            msg=sprintf([&#39;%s\nConsider setting .sa.chunks to q, where &#39;...
                            &#39;[~,~,q]=unique(ds.sa.targets)&#39;,msg]);
        end
        error(msg);
    end

function check_params(params)
    if isfield(params,&#39;glm_dsm&#39;)
        if isfield(params,&#39;regress_dsm&#39;) || isfield(params,&#39;target_dsm&#39;)
            error([&#39;&#39;&#39;glm_dsm&#39;&#39; cannot be used with &#39;&#39;regress_dsm&#39;&#39;&#39;...
                    &#39;or &#39;&#39;target_dsm&#39;&#39;&#39;]);
        end
    elseif ~isfield(params,&#39;target_dsm&#39;)
        error(&#39;&#39;&#39;target_dsm&#39;&#39; or &#39;&#39;glm_dsm&#39;&#39; option is required&#39;);
    end
</pre></div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/cosmomvpa_logo.png" alt="Logo"/>
            </a></p>
  <h4>Previous topic</h4>
  <p class="topless"><a href="cosmo_tail.html"
                        title="previous chapter">cosmo tail</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="cosmo_type.html"
                        title="next chapter">cosmo type</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/matlab/cosmo_target_dsm_corr_measure.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="cosmo_type.html" title="cosmo type"
             >next</a> |</li>
        <li class="right" >
          <a href="cosmo_tail.html" title="cosmo tail"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">CoSMoMVPA</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../documentation.html" >Documentation</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../cimec2016.html" >CIMeC hands-on methods course, part 1 (6 April-2 May 2016)</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="../matindex.html" >CoSMoMVPA functions</a> &#187;</li> 
      </ul>
    </div>
      <div class="footer">
       <span class="creativecommons">
          <a href="http://opensource.org/licenses/MIT" >
          <img src="../_static/mit-license_logo.png"
               border="0" alt="Creative Commons License"/>
         </a> 
         
        <a href="copyright.html">Copyright 2013-2016 Nikolaas N. Oosterhof, Andrew C. Connolly, CoSMoMVPA contributors</a>.
        CoSMoMVPA is licensed under a <a href="http://opensource.org/licenses/MIT">Expat (MIT) License</a>.
       </span>
      </div>
  </body>
</html>
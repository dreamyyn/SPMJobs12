    <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>cosmo fmri dataset skl &#8212; CoSMo Multivariate Pattern Analysis toolbox 1.0rc1 documentation</title>
    
    <link rel="stylesheet" href="../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.0rc1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="next" title="cosmo fmri deoblique skl" href="cosmo_fmri_deoblique_skl.html" />
    <link rel="prev" title="cosmo fmri convert xform skl" href="cosmo_fmri_convert_xform_skl.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="cosmo_fmri_deoblique_skl.html" title="cosmo fmri deoblique skl"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="cosmo_fmri_convert_xform_skl.html" title="cosmo fmri convert xform skl"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">CoSMoMVPA</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../documentation.html" >Documentation</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../cimec2016.html" >CIMeC hands-on methods course, part 1 (6 April-2 May 2016)</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="../matindex_skl.html" accesskey="U">CoSMoMVPA functions - skeleton files</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="cosmo-fmri-dataset-skl">
<span id="id1"></span><h1>cosmo fmri dataset skl<a class="headerlink" href="#cosmo-fmri-dataset-skl" title="Permalink to this headline">Â¶</a></h1>
<div class="highlight-matlab"><div class="highlight"><pre><span></span><span class="k">function</span><span class="w"> </span>ds<span class="p">=</span><span class="nf">cosmo_fmri_dataset</span><span class="p">(</span>filename, varargin<span class="p">)</span><span class="w"></span>
<span class="c">% load an fmri volumetric dataset</span>
<span class="c">%</span>
<span class="c">% ds = cosmo_fmri_dataset(filename, [,&#39;mask&#39;,mask],...</span>
<span class="c">%                                   [&#39;targets&#39;,targets],...</span>
<span class="c">%                                   [&#39;chunks&#39;,chunks])</span>
<span class="c">%</span>
<span class="c">% Inputs:</span>
<span class="c">%   filename     One of:</span>
<span class="c">%                * filename of fMRI dataset, it should end with one of:</span>
<span class="c">%                   .nii, .nii.gz                   NIfTI</span>
<span class="c">%                   .hdr, .img                      ANALYZE</span>
<span class="c">%                   +{orig,tlrc}.{HEAD,BRIK[.gz]}   AFNI</span>
<span class="c">%                   .vmr, .vmp, .vtc, .glm, .msk    BrainVoyager</span>
<span class="c">%                   .mat                            SPM (SPM.mat)</span>
<span class="c">%                   .mat:beta                       SPM beta</span>
<span class="c">%                   .mat:con                        SPM contrast</span>
<span class="c">%                   .mat:spm                        SPM stats</span>
<span class="c">%                   .mat                            Matlab file with</span>
<span class="c">%                                                   CoSMoMVPA or PyMVPA</span>
<span class="c">%                                                   dataset.</span>
<span class="c">%                * xff structure (from neuroelf&#39;s xff)</span>
<span class="c">%                * nifti structure (from load_untouch_nii)</span>
<span class="c">%                * FieldTrip source MEEG structure</span>
<span class="c">%                * SPM structure</span>
<span class="c">%                * CoSMoMVPA fMRI or MEEG source dataset structure</span>
<span class="c">%                * PyMVPA fMRI dataset structure (exported using PyMVPA&#39;s</span>
<span class="c">%                  cosmo.map2cosmo function)</span>
<span class="c">%   &#39;mask&#39;, m    Any input as for filename (in which case the output must</span>
<span class="c">%                contain a single volume), or one of:</span>
<span class="c">%                   &#39;-all&#39;     exclude features where all values are</span>
<span class="c">%                              zero or NaN</span>
<span class="c">%                   &#39;-any&#39;     exclude features where any value is</span>
<span class="c">%                              zero or NaN</span>
<span class="c">%                   &#39;-auto&#39;    require that &#39;-all&#39; and &#39;-any&#39; exclude the</span>
<span class="c">%                              same features, and exclude the</span>
<span class="c">%                              corresponding features</span>
<span class="c">%                   true       equivalent to &#39;-auto&#39;</span>
<span class="c">%                   false      do not apply a mask</span>
<span class="c">%                The mask must have voxels at the same coordinates as the</span>
<span class="c">%                data indicated by filename, although it may</span>
<span class="c">%                have a different orientation (e.g. RAI, LPI, AIR).</span>
<span class="c">%                Only voxels that are non-zero and not NaN are selected</span>
<span class="c">%                from the data indicated by filename.</span>
<span class="c">%                If &#39;mask&#39; is not given, then no mask is applied and a</span>
<span class="c">%                warning message (suggesting to use a mask) is printed if</span>
<span class="c">%                at least 5% of the values are non{zero,finite}.</span>
<span class="c">%   &#39;targets&#39;, t optional Tx1 numeric labels of experimental</span>
<span class="c">%                conditions (where T is the number of samples (volumes)</span>
<span class="c">%                in the dataset)</span>
<span class="c">%   &#39;chunks, c   optional Tx1 numeric labels of chunks, typically indices</span>
<span class="c">%                of runs of data acquisition</span>
<span class="c">%   &#39;volumes&#39;, v optional vector with indices of volumes to load. If</span>
<span class="c">%                empty or not provided, then all volumes are loaded.</span>
<span class="c">%   &#39;block_size&#39;, b  optional block size by which data is read (if</span>
<span class="c">%                supported by the format; currently NIfTI, ANALYZE, AFNI</span>
<span class="c">%                and SPM. If this option is provided *and* a mask is</span>
<span class="c">%                provided, then data is loaded in chunks (subsets of</span>
<span class="c">%                volumes) that contain at most block_size elements each;</span>
<span class="c">%                only data that survives the mask is then selected before</span>
<span class="c">%                the next block is loaded.</span>
<span class="c">%                The default value is 20,000,000, corresponding to ~160</span>
<span class="c">%                megabytes of memory required for a block (using</span>
<span class="c">%                numbers with double (64 bit) precsision).</span>
<span class="c">%                The rationale for this option is to reduce memory</span>
<span class="c">%                requirements, at the expensive of a possible increase of</span>
<span class="c">%                duration of disk reading operations.</span>
<span class="c">%</span>
<span class="c">%</span>
<span class="c">% Returns:</span>
<span class="c">%   ds           dataset struct with the following fields:</span>
<span class="c">%     .samples   NxM matrix containing the data loaded from filename, for</span>
<span class="c">%                N samples (observations, volumes) and M features (spatial</span>
<span class="c">%                locations, voxels).</span>
<span class="c">%                If the original nifti file contained data with X,Y,Z,T</span>
<span class="c">%                elements in the three spatial and one temporal dimension</span>
<span class="c">%                and no mask was applied, then .samples will have</span>
<span class="c">%                dimensions N x M, where N = T and M = X*Y*Z. If a mask</span>
<span class="c">%                was applied then M (M&lt;=X*Y*Z) is the number of non-zero</span>
<span class="c">%                voxels in the  mask input dataset.</span>
<span class="c">%     .a         struct with dataset-relevent data.</span>
<span class="c">%     .a.fdim.labels   dimension labels, set to {&#39;i&#39;,&#39;j&#39;,&#39;k&#39;}</span>
<span class="c">%     .a.fdim.values   dimension values, set to {1:X, 1:Y, 1:Z}</span>
<span class="c">%     .a.vol.dim 1x3 vector indicating the number of voxels in the 3</span>
<span class="c">%                spatial dimensions.</span>
<span class="c">%     .a.vol.mat 4x4 voxel-to-world transformation matrix (base-1).</span>
<span class="c">%     .a.vol.dim 1x3 number of voxels in each spatial dimension</span>
<span class="c">%     .sa        struct for holding sample attributes (e.g., sa.targets,</span>
<span class="c">%                sa.chunks)</span>
<span class="c">%     .fa        struct for holding feature attributes</span>
<span class="c">%     .fa.{i,j,k} indices of voxels (in voxel space).</span>
<span class="c">%</span>
<span class="c">% Notes:</span>
<span class="c">%  - Most MVPA applications require that .sa.targets (experimental</span>
<span class="c">%    condition of each sample) and .sa.chunks (partitioning of the samples</span>
<span class="c">%    in independent sets) are set, either by using this function or</span>
<span class="c">%    manually afterwards.</span>
<span class="c">%  - Data can be mapped to the volume using cosmo_map2fmri</span>
<span class="c">%  - SPM data can also be specified as filename:format, where format</span>
<span class="c">%    can be &#39;beta&#39;, &#39;con&#39; or &#39;spm&#39; (e.g. &#39;SPM.mat:beta&#39;, &#39;SPM.mat:con&#39;, or</span>
<span class="c">%    &#39;SPM.mat:spm&#39;) to load beta, contrast, or statistic images,</span>
<span class="c">%    respectively. When using &#39;beta&#39;, estimates for motion parameters and</span>
<span class="c">%    intercepts (which in most cases are estimates of no interest) are</span>
<span class="c">%    not returned. If format is omitted it is set to &#39;beta&#39;.</span>
<span class="c">%  - If SPM data contains a field .Sess (session) then .sa.chunks are set</span>
<span class="c">%    according to its contents</span>
<span class="c">%  - If a mask is supplied, then all features that are in the mask are</span>
<span class="c">%    returned, even if some voxels contain NaN. To remove such features,</span>
<span class="c">%    consider applying cosmo_remove_useless_data to the output of this</span>
<span class="c">%    function.</span>
<span class="c">%</span>
<span class="c">% Dependencies:</span>
<span class="c">% -  for NIfTI, analyze (.hdr/.img) and SPM.mat files, it requires the</span>
<span class="c">%    NIfTI toolbox by Jimmy Shen</span>
<span class="c">%    (note that his toolbox is included in CoSMoMVPA in /externals)</span>
<span class="c">% -  for Brainvoyager files (.vmp, .vtc, .msk, .glm), it requires the</span>
<span class="c">%    NeuroElf toolbox, available from: http://neuroelf.net</span>
<span class="c">% -  for AFNI files (+{orig,tlrc}.{HEAD,BRIK[.gz]}) it requires the AFNI</span>
<span class="c">%    Matlab toolbox, available from: https://github.com/afni/AFNI</span>
<span class="c">%</span>
<span class="c">% Examples:</span>
<span class="c">%     % load nifti file</span>
<span class="c">%     ds=cosmo_fmri_dataset(&#39;mydata.nii&#39;);</span>
<span class="c">%</span>
<span class="c">%     % load gzipped nifti file</span>
<span class="c">%     ds=cosmo_fmri_dataset(&#39;mydata.nii.gz&#39;);</span>
<span class="c">%</span>
<span class="c">%     % load ANALYZE file and apply brain mask</span>
<span class="c">%     ds=cosmo_fmri_dataset(&#39;mydata.hdr&#39;,&#39;mask&#39;,&#39;brain_mask.hdr&#39;);</span>
<span class="c">%</span>
<span class="c">%     % load AFNI file with 6 &#39;bricks&#39; (values per voxel, e.g. beta</span>
<span class="c">%     % values); set chunks (e.g. runs) and targets (experimental</span>
<span class="c">%     % conditions); use a mask</span>
<span class="c">%     ds=cosmo_fmri_dataset(&#39;mydata+tlrc&#39;, &#39;chunks&#39;, [1 1 1 2 2 2]&#39;, ...</span>
<span class="c">%                                     &#39;targets&#39;, [1 2 3 1 2 3]&#39;, ...</span>
<span class="c">%                                     &#39;mask&#39;, &#39;masks/brain_mask+tlrc);</span>
<span class="c">%</span>
<span class="c">%     % load BrainVoyager VMR file in directory &#39;mydata&#39;, and apply an</span>
<span class="c">%     % automask that removes all features (voxels) that are zero or</span>
<span class="c">%     % non-finite for all samples</span>
<span class="c">%     ds=cosmo_fmri_dataset(&#39;mydata/mydata.vmr&#39;, &#39;mask&#39;, true);</span>
<span class="c">%</span>
<span class="c">%     % load two datasets, one for odd runs, the other for even runs, and</span>
<span class="c">%     % combine them into one dataset. Note that the chunks are set here,</span>
<span class="c">%     % but the targets are not - for subsequent analyses this may have to</span>
<span class="c">%     % be done manually</span>
<span class="c">%     ds_even=cosmo_fmri_dataset(&#39;data_even_runs.glm&#39;,&#39;chunks&#39;,1);</span>
<span class="c">%     ds_odd=cosmo_fmri_dataset(&#39;data_odd_runs.glm&#39;,&#39;chunks&#39;,2);</span>
<span class="c">%     ds=cosmo_stack({ds_even,ds_odd});</span>
<span class="c">%</span>
<span class="c">%     % load beta values from SPM GLM analysis stored</span>
<span class="c">%     % in a file SPM.mat.</span>
<span class="c">%     % If SPM.mat contains a field .Sess (sessions) then .sa.chunks</span>
<span class="c">%     % is set according to the contents of .Sess.</span>
<span class="c">%     ds=cosmo_fmri_dataset(&#39;path/to/SPM.mat&#39;);</span>
<span class="c">%</span>
<span class="c">%     % as above, and apply an automask to remove voxels that</span>
<span class="c">%     % are zero or non-finite in all samples.</span>
<span class="c">%     ds=cosmo_fmri_dataset(&#39;path/to/SPM.mat&#39;,&#39;mask&#39;,true);</span>
<span class="c">%</span>
<span class="c">%     % load contrast beta values from SPM GLM file SPM.mat</span>
<span class="c">%     ds=cosmo_fmri_dataset(&#39;path/to/SPM.mat:con&#39;);</span>
<span class="c">%</span>
<span class="c">%     % load contrast statistic values from SPM GLM file SPM.mat</span>
<span class="c">%     ds=cosmo_fmri_dataset(&#39;path/to/SPM.mat:spm&#39;);</span>
<span class="c">%</span>
<span class="c">%     % load PyMVPA dataset &#39;pymvpa_ds&#39; that was exported using</span>
<span class="c">%     % PyMVPA&#39;s cosmo.map2cosmo function in Python with:</span>
<span class="c">%     %</span>
<span class="c">%     %    &gt;&gt;&gt; from mvpa2.datasets import cosmo</span>
<span class="c">%     %    &gt;&gt;&gt; cosmo.map2cosmo(pymvpa_ds,&#39;data.mat&#39;)</span>
<span class="c">%     %</span>
<span class="c">%     cosmo_ds=cosmo_fmri_dataset(&#39;data.mat&#39;)</span>
<span class="c">%</span>
<span class="c">% See also: cosmo_map2fmri</span>
<span class="c">%</span>
<span class="c">% part of the NIfTI code is based on code by Robert W Cox, 2003,</span>
<span class="c">% dedicated to the public domain.</span>
<span class="c">%</span>
<span class="c">% #   For CoSMoMVPA&#39;s copyright information and license terms,   #</span>
<span class="c">% #   see the COPYING file distributed with CoSMoMVPA.           #</span>

    <span class="c">% set defaults</span>
    <span class="n">defaults</span><span class="p">.</span><span class="n">mask</span><span class="p">=[];</span>
    <span class="n">defaults</span><span class="p">.</span><span class="n">targets</span><span class="p">=[];</span>
    <span class="n">defaults</span><span class="p">.</span><span class="n">chunks</span><span class="p">=[];</span>
    <span class="n">defaults</span><span class="p">.</span><span class="n">volumes</span><span class="p">=[];</span>
    <span class="n">defaults</span><span class="p">.</span><span class="n">block_size</span><span class="p">=</span><span class="mf">2e7</span><span class="p">;</span>

    <span class="c">% set parameters</span>
    <span class="n">params</span> <span class="p">=</span> <span class="n">cosmo_structjoin</span><span class="p">(</span><span class="n">defaults</span><span class="p">,</span> <span class="n">varargin</span><span class="p">{:});</span>


    <span class="c">% create dataset from filename</span>
    <span class="n">ds</span><span class="p">=</span><span class="n">convert_to_dataset</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">params</span><span class="p">);</span>

    <span class="c">% set chunks and targets</span>
    <span class="n">ds</span><span class="p">=</span><span class="n">set_sa_vec</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span><span class="n">params</span><span class="p">,</span><span class="s">&#39;targets&#39;</span><span class="p">);</span>
    <span class="n">ds</span><span class="p">=</span><span class="n">set_sa_vec</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span><span class="n">params</span><span class="p">,</span><span class="s">&#39;chunks&#39;</span><span class="p">);</span>

    <span class="k">if</span> <span class="n">param_specifies_auto_mask</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
        <span class="n">auto_mask</span><span class="p">=</span><span class="n">compute_auto_mask</span><span class="p">(</span><span class="n">ds</span><span class="p">.</span><span class="n">samples</span><span class="p">,</span> <span class="n">params</span><span class="p">.</span><span class="n">mask</span><span class="p">);</span>
        <span class="n">ds</span><span class="p">=</span><span class="n">cosmo_slice</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span><span class="n">auto_mask</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
    <span class="k">else</span>
        <span class="n">warn_if_nan_present_in_dataset</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span>
    <span class="k">end</span>




<span class="k">function</span><span class="w"> </span>ds_all<span class="p">=</span><span class="nf">convert_to_dataset</span><span class="p">(</span>fn, params<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="c">% main data reader function</span>

    <span class="k">if</span> <span class="n">string_endswith</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span><span class="s">&#39;.mat&#39;</span><span class="p">)</span>
        <span class="n">data</span><span class="p">=</span><span class="n">fast_import_data</span><span class="p">(</span><span class="n">fn</span><span class="p">);</span>
    <span class="k">else</span>
        <span class="n">data</span><span class="p">=</span><span class="n">fn</span><span class="p">;</span>
    <span class="k">end</span>

    <span class="n">img_formats_collection</span><span class="p">=</span><span class="n">get_img_formats</span><span class="p">;</span>
    <span class="n">label</span><span class="p">=</span><span class="n">find_img_format</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">img_formats_collection</span><span class="p">);</span>
    <span class="n">img_format</span><span class="p">=</span><span class="n">img_formats_collection</span><span class="p">.(</span><span class="n">label</span><span class="p">);</span>

    <span class="c">% make sure the required externals exists</span>
    <span class="n">externals</span><span class="p">=</span><span class="n">img_format</span><span class="p">.</span><span class="n">externals</span><span class="p">;</span>
    <span class="n">cosmo_check_external</span><span class="p">(</span><span class="n">externals</span><span class="p">);</span>

    <span class="c">% get the helper functions for this format</span>
    <span class="n">data_converter</span><span class="p">=</span><span class="n">img_format</span><span class="p">.</span><span class="n">data_converter</span><span class="p">;</span>
    <span class="n">has_data_reader</span><span class="p">=</span><span class="n">isfield</span><span class="p">(</span><span class="n">img_format</span><span class="p">,</span><span class="s">&#39;data_reader&#39;</span><span class="p">);</span>

    <span class="c">% verify the input</span>
    <span class="n">input_is_filename</span><span class="p">=</span><span class="o">~</span><span class="n">img_format</span><span class="p">.</span><span class="n">matcher</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
    <span class="k">if</span> <span class="n">input_is_filename</span> <span class="o">&amp;&amp;</span> <span class="o">~</span><span class="n">ischar</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">error</span><span class="p">(</span><span class="s">&#39;illegal input of type &#39;&#39;%s&#39;&#39;&#39;</span><span class="p">,</span> <span class="n">class</span><span class="p">(</span><span class="n">data</span><span class="p">));</span>
    <span class="k">end</span>

    <span class="k">if</span> <span class="n">input_is_filename</span>
        <span class="c">% read header from file</span>
        <span class="n">raw_header</span><span class="p">=</span><span class="n">img_format</span><span class="p">.</span><span class="n">header_reader</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
    <span class="k">elseif</span> <span class="n">isfield</span><span class="p">(</span><span class="n">img_format</span><span class="p">,</span> <span class="s">&#39;struct_header_reader&#39;</span><span class="p">)</span>
        <span class="n">raw_header</span><span class="p">=</span><span class="n">img_format</span><span class="p">.</span><span class="n">struct_header_reader</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span><span class="n">data</span><span class="p">);</span>
    <span class="k">else</span>
        <span class="c">% input is a struct or object, no reading required</span>
        <span class="n">raw_header</span><span class="p">=</span><span class="n">data</span><span class="p">;</span>
    <span class="k">end</span>

    <span class="c">% get dataset header</span>
    <span class="p">[</span><span class="n">ds_hdr_full</span><span class="p">,</span><span class="n">nsamples</span><span class="p">]=</span><span class="n">img_format</span><span class="p">.</span><span class="n">header_converter</span><span class="p">(</span><span class="n">raw_header</span><span class="p">,</span><span class="c">...</span>
                                                                <span class="n">params</span><span class="p">);</span>

    <span class="c">% now we have enough information about the dataset to load the mask</span>
    <span class="c">% and compare its orientation and position of voxels. If there is</span>
    <span class="c">% a mismatch, an error is raised</span>
    <span class="n">mask_ds</span><span class="p">=</span><span class="n">get_user_ds_mask</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">ds_hdr_full</span><span class="p">);</span>

    <span class="c">% only read in multiple blocks if it is supported for this format, and</span>
    <span class="c">% if there is a mask; otherwise what is the point?</span>
    <span class="n">has_mask</span><span class="p">=</span><span class="o">~</span><span class="nb">isempty</span><span class="p">(</span><span class="n">mask_ds</span><span class="p">);</span>
    <span class="n">load_multiple_blocks</span><span class="p">=</span><span class="n">has_data_reader</span> <span class="o">&amp;&amp;</span> <span class="n">has_mask</span><span class="p">;</span>
    <span class="n">nvoxels</span><span class="p">=</span><span class="n">prod</span><span class="p">(</span><span class="n">ds_hdr_full</span><span class="p">.</span><span class="n">a</span><span class="p">.</span><span class="n">vol</span><span class="p">.</span><span class="n">dim</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">));</span>
    <span class="n">volumes_cell</span><span class="p">=</span><span class="n">partition_volumes</span><span class="p">(</span><span class="n">nsamples</span><span class="p">,</span> <span class="n">nvoxels</span><span class="p">,</span><span class="c">...</span>
                                    <span class="n">load_multiple_blocks</span><span class="p">,</span> <span class="n">params</span><span class="p">);</span>
    <span class="n">n_blocks</span><span class="p">=</span><span class="nb">numel</span><span class="p">(</span><span class="n">volumes_cell</span><span class="p">);</span>

    <span class="c">% allocate space for output</span>
    <span class="n">ds_cell</span><span class="p">=</span><span class="n">cell</span><span class="p">(</span><span class="n">n_blocks</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>

    <span class="c">% each block contains a subset of volumes; when they are combined</span>
    <span class="c">% the contain all volumes that have to be loaded.</span>
    <span class="c">% To reduce memory usage when a mask is supplied *and* the file</span>
    <span class="c">% format reader allows selecting a subset of volumes:</span>
    <span class="c">% - for each block, read all data from the corresponding volumes</span>
    <span class="c">% - apply the mask to the data</span>
    <span class="c">% - only store the result (which is much smaller)</span>
    <span class="c">% After this has been done for each block, results are stacked to</span>
    <span class="c">% form a single dataset</span>
    <span class="k">for</span> <span class="n">block</span><span class="p">=</span><span class="mi">1</span><span class="p">:</span><span class="n">n_blocks</span>
        <span class="n">volumes</span><span class="p">=</span><span class="n">volumes_cell</span><span class="p">{</span><span class="n">block</span><span class="p">};</span>

        <span class="c">% if all volumes are read, call the data reader or converter</span>
        <span class="c">% with empty input, so that it knows that all volumes can be read</span>
        <span class="n">volumes_or_empty</span><span class="p">=</span><span class="n">volumes</span><span class="p">;</span>
        <span class="n">is_all_volumes</span><span class="p">=</span><span class="nb">isequal</span><span class="p">(</span><span class="n">volumes</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="n">nsamples</span><span class="p">);</span>
        <span class="k">if</span> <span class="n">is_all_volumes</span>
            <span class="n">volumes_or_empty</span><span class="p">=[];</span>
        <span class="k">end</span>

        <span class="k">if</span> <span class="n">input_is_filename</span> <span class="o">&amp;&amp;</span> <span class="n">has_data_reader</span>
            <span class="c">% selecting subset of volumes is done by the data_reader,</span>
            <span class="c">% so that only part of the whole file has to be read</span>
            <span class="n">data_reader</span><span class="p">=</span><span class="n">img_format</span><span class="p">.</span><span class="n">data_reader</span><span class="p">;</span>

            <span class="c">% make a copy of the filename or SPM struct</span>
            <span class="n">is_first_block</span><span class="p">=</span><span class="n">block</span><span class="o">==</span><span class="mi">1</span><span class="p">;</span>
            <span class="k">if</span> <span class="n">is_first_block</span>
                <span class="n">original_data</span><span class="p">=</span><span class="n">data</span><span class="p">;</span>
            <span class="k">end</span>

            <span class="n">data</span><span class="p">=</span><span class="n">data_converter</span><span class="p">(</span><span class="n">data_reader</span><span class="p">(</span><span class="n">original_data</span><span class="p">,</span> <span class="n">raw_header</span><span class="p">,</span> <span class="c">...</span>
                                                <span class="n">volumes_or_empty</span><span class="p">),</span> <span class="p">[]);</span>
        <span class="k">else</span>
            <span class="c">% all data is probably already in memory, so select subset</span>
            <span class="c">% of volumes through the converter</span>
            <span class="n">data</span><span class="p">=</span><span class="n">data_converter</span><span class="p">(</span><span class="n">raw_header</span><span class="p">,</span> <span class="n">volumes_or_empty</span><span class="p">);</span>
        <span class="k">end</span>

        <span class="k">if</span> <span class="n">isfield</span><span class="p">(</span><span class="n">img_format</span><span class="p">,</span><span class="s">&#39;convert_volume&#39;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="c">...</span>
                                <span class="o">~</span><span class="n">img_format</span><span class="p">.</span><span class="n">convert_volume</span>
            <span class="n">ds</span><span class="p">=</span><span class="n">data</span><span class="p">;</span>
        <span class="k">else</span>
            <span class="n">ds</span><span class="p">=</span><span class="n">flatten_data_array</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">ds_hdr_full</span><span class="p">.</span><span class="n">a</span><span class="p">.</span><span class="n">vol</span><span class="p">);</span>
        <span class="k">end</span>

        <span class="n">clear</span> <span class="n">data</span><span class="p">;</span> <span class="c">% reduce memory usage</span>

        <span class="k">if</span> <span class="n">has_mask</span>
            <span class="k">if</span> <span class="n">block</span><span class="o">==</span><span class="mi">1</span>
                <span class="c">% only get the mask once, as it is the same for all blocks</span>
                <span class="n">ds_ids_mask</span><span class="p">=</span><span class="n">get_binary_dataset_mask</span><span class="p">(</span><span class="n">mask_ds</span><span class="p">,</span><span class="n">ds</span><span class="p">);</span>
            <span class="k">end</span>

            <span class="n">ds</span><span class="p">=</span><span class="n">cosmo_slice</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span> <span class="n">ds_ids_mask</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
        <span class="k">end</span>

        <span class="n">ds_hdr</span><span class="p">=</span><span class="n">ds_hdr_full</span><span class="p">;</span>

        <span class="c">% get sample attributes for these volumes from the header</span>
        <span class="k">if</span> <span class="n">isfield</span><span class="p">(</span><span class="n">ds_hdr</span><span class="p">,</span><span class="s">&#39;sa&#39;</span><span class="p">)</span>
            <span class="n">ds_hdr</span><span class="p">.</span><span class="n">sa</span><span class="p">=</span><span class="n">cosmo_slice</span><span class="p">(</span><span class="n">ds_hdr</span><span class="p">.</span><span class="n">sa</span><span class="p">,</span> <span class="n">volumes</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="s">&#39;struct&#39;</span><span class="p">);</span>
        <span class="k">end</span>

        <span class="c">% update from header</span>
        <span class="n">ds</span><span class="p">=</span><span class="n">cosmo_structjoin</span><span class="p">(</span><span class="n">ds_hdr</span><span class="p">,</span> <span class="n">ds</span><span class="p">);</span>

        <span class="c">% store block</span>
        <span class="n">ds_cell</span><span class="p">{</span><span class="n">block</span><span class="p">}=</span><span class="n">ds</span><span class="p">;</span>
    <span class="k">end</span>

    <span class="n">ds_all</span><span class="p">=</span><span class="n">cosmo_stack</span><span class="p">(</span><span class="n">ds_cell</span><span class="p">,[],[],</span><span class="n">false</span><span class="p">);</span>
    <span class="n">cosmo_check_dataset</span><span class="p">(</span><span class="n">ds_all</span><span class="p">,</span><span class="s">&#39;fmri&#39;</span><span class="p">);</span>


<span class="k">function</span><span class="w"> </span>ids_mask<span class="p">=</span><span class="nf">get_binary_dataset_mask</span><span class="p">(</span>ds_mask, ds<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="c">% return a binary mask that can be used to slice ds</span>
    <span class="c">% to contain only features indexed by ds_mask</span>
    <span class="c">%</span>
    <span class="c">% This function also works if ds_mask and ds do not have the same</span>
    <span class="c">% features (voxels), and/or if the same location is indexed by multiple</span>
    <span class="c">% features.</span>

    <span class="c">% this should always be fine</span>
    <span class="n">check_datasets_in_same_space</span><span class="p">(</span><span class="n">ds_mask</span><span class="p">,</span> <span class="n">ds</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">islogical</span><span class="p">(</span><span class="n">ds_mask</span><span class="p">.</span><span class="n">samples</span><span class="p">));</span>


    <span class="p">[</span><span class="n">mask_lin_ids</span><span class="p">,</span><span class="n">dim</span><span class="p">]=</span><span class="n">get_linear_feature_ids</span><span class="p">(</span><span class="n">ds_mask</span><span class="p">);</span>
    <span class="p">[</span><span class="n">lin_ids</span><span class="p">,</span> <span class="n">dim_</span><span class="p">]=</span><span class="n">get_linear_feature_ids</span><span class="p">(</span><span class="n">ds</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="nb">isequal</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span><span class="n">dim_</span><span class="p">));</span>

    <span class="c">% allow duplicate feature ids in either ds_mask and/or ds</span>
    <span class="n">n_ids_mask</span><span class="p">=</span><span class="n">prod</span><span class="p">(</span><span class="n">dim</span><span class="p">);</span>
    <span class="n">mask</span><span class="p">=</span><span class="n">false</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">n_ids_mask</span><span class="p">);</span>
    <span class="n">mask</span><span class="p">(</span><span class="n">mask_lin_ids</span><span class="p">)=</span><span class="n">samples_to_binary_mask</span><span class="p">(</span><span class="n">ds_mask</span><span class="p">.</span><span class="n">samples</span><span class="p">);</span>

    <span class="n">ids_mask</span><span class="p">=</span><span class="n">mask</span><span class="p">(</span><span class="n">lin_ids</span><span class="p">);</span>


<span class="k">function</span><span class="w"> </span>mask<span class="p">=</span><span class="nf">samples_to_binary_mask</span><span class="p">(</span>samples<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">mask</span><span class="p">=</span><span class="n">samples</span><span class="o">~=</span><span class="mi">0</span> <span class="o">&amp;</span> <span class="o">~</span><span class="nb">isnan</span><span class="p">(</span><span class="n">samples</span><span class="p">);</span>

<span class="k">function</span><span class="w"> </span><span class="nf">warn_if_nan_present_in_dataset</span><span class="p">(</span>ds<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">nsamples</span><span class="p">=</span><span class="nb">size</span><span class="p">(</span><span class="n">ds</span><span class="p">.</span><span class="n">samples</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">=</span><span class="mi">1</span><span class="p">:</span><span class="n">nsamples</span>
        <span class="k">if</span> <span class="n">any</span><span class="p">(</span><span class="nb">isnan</span><span class="p">(</span><span class="n">ds</span><span class="p">.</span><span class="n">samples</span><span class="p">(</span><span class="n">k</span><span class="p">,:)))</span>
            <span class="n">cosmo_warning</span><span class="p">([</span><span class="s">&#39;The input dataset has NaN (not a number) &#39;</span><span class="c">...</span>
                            <span class="s">&#39;values, which may cause the output &#39;</span><span class="c">...</span>
                            <span class="s">&#39;of subsequent analyses to contain NaNs as &#39;</span><span class="c">...</span>
                            <span class="s">&#39;well. For many use cases, NaNs are not &#39;</span><span class="c">...</span>
                            <span class="s">&#39;desirabe. To remove features (voxels) &#39;</span><span class="c">...</span>
                            <span class="s">&#39;with NaN values, consider using:\n\n&#39;</span><span class="c">...</span>
                            <span class="s">&#39;  ds_clean=cosmo_remove_useless_data(ds)&#39;</span><span class="c">...</span>
                            <span class="s">&#39;\n\nwhere ds is the output from this &#39;</span><span class="c">...</span>
                            <span class="s">&#39;function (%s)&#39;</span><span class="p">],</span><span class="n">mfilename</span><span class="p">());</span>
            <span class="k">return</span>
        <span class="k">end</span>
    <span class="k">end</span>

<span class="k">function</span><span class="w"> </span>[lin_ids, vol_dim]<span class="p">=</span><span class="nf">get_linear_feature_ids</span><span class="p">(</span>ds<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="c">% get linear ids for each feature</span>
    <span class="n">keys</span><span class="p">={</span><span class="s">&#39;i&#39;</span><span class="p">,</span><span class="s">&#39;j&#39;</span><span class="p">,</span><span class="s">&#39;k&#39;</span><span class="p">};</span>
    <span class="n">n_keys</span><span class="p">=</span><span class="nb">numel</span><span class="p">(</span><span class="n">keys</span><span class="p">);</span>

    <span class="n">sub_ids</span><span class="p">=</span><span class="n">cell</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">n_keys</span><span class="p">);</span>
    <span class="n">vol_dim</span><span class="p">=</span><span class="n">ds</span><span class="p">.</span><span class="n">a</span><span class="p">.</span><span class="n">vol</span><span class="p">.</span><span class="n">dim</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">);</span>

    <span class="k">for</span> <span class="n">k</span><span class="p">=</span><span class="mi">1</span><span class="p">:</span><span class="n">n_keys</span><span class="p">;</span>
        <span class="n">key</span><span class="p">=</span><span class="n">keys</span><span class="p">{</span><span class="n">k</span><span class="p">};</span>

        <span class="p">[</span><span class="n">dim</span><span class="p">,</span> <span class="n">unused</span><span class="p">,</span> <span class="n">unused</span><span class="p">,</span> <span class="n">unused</span><span class="p">,</span> <span class="n">values</span><span class="p">]=</span><span class="n">cosmo_dim_find</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span><span class="n">key</span><span class="p">,</span><span class="n">true</span><span class="p">);</span>
        <span class="k">if</span> <span class="n">dim</span><span class="o">~=</span><span class="mi">2</span>
            <span class="n">error</span><span class="p">(</span><span class="s">&#39;Unexpected key &#39;&#39;%s&#39;&#39; in sample dimension&#39;</span><span class="p">,</span><span class="n">key</span><span class="p">);</span>
        <span class="k">end</span>
        <span class="n">assert</span><span class="p">(</span><span class="nb">numel</span><span class="p">(</span><span class="n">values</span><span class="p">)</span><span class="o">==</span><span class="n">vol_dim</span><span class="p">(</span><span class="n">k</span><span class="p">));</span>

        <span class="n">sub_ids</span><span class="p">{</span><span class="n">k</span><span class="p">}=</span><span class="n">values</span><span class="p">(</span><span class="n">ds</span><span class="p">.</span><span class="n">fa</span><span class="p">.(</span><span class="n">key</span><span class="p">));</span>
    <span class="k">end</span>


    <span class="n">lin_ids</span><span class="p">=</span><span class="nb">sub2ind</span><span class="p">(</span><span class="n">vol_dim</span><span class="p">,</span><span class="n">sub_ids</span><span class="p">{:});</span>


<span class="k">function</span><span class="w"> </span>tf<span class="p">=</span><span class="nf">param_specifies_auto_mask</span><span class="p">(</span>params<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="c">% return true if an auto mask is specified</span>
    <span class="n">mask_param</span><span class="p">=</span><span class="n">params</span><span class="p">.</span><span class="n">mask</span><span class="p">;</span>
    <span class="n">tf</span><span class="p">=(</span><span class="n">islogical</span><span class="p">(</span><span class="n">mask_param</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="c">...</span>
                <span class="n">mask_param</span><span class="p">)</span> <span class="o">||</span> <span class="c">...</span>
        <span class="p">(</span><span class="n">ischar</span><span class="p">(</span><span class="n">mask_param</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="c">...</span>
                 <span class="nb">numel</span><span class="p">(</span><span class="n">mask_param</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="c">...</span>
                 <span class="n">mask_param</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">==</span><span class="s">&#39;-&#39;</span><span class="p">);</span>

<span class="k">function</span><span class="w"> </span>tf<span class="p">=</span><span class="nf">param_specifies_user_mask</span><span class="p">(</span>params<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="c">% return true if a user mask is specified</span>
    <span class="n">mask_param</span><span class="p">=</span><span class="n">params</span><span class="p">.</span><span class="n">mask</span><span class="p">;</span>
    <span class="n">tf</span><span class="p">=</span><span class="o">~</span><span class="p">(</span><span class="nb">isempty</span><span class="p">(</span><span class="n">mask_param</span><span class="p">)</span> <span class="o">||</span> <span class="c">...</span>
                <span class="n">islogical</span><span class="p">(</span><span class="n">mask_param</span><span class="p">)</span> <span class="o">||</span> <span class="c">...</span>
                <span class="n">param_specifies_auto_mask</span><span class="p">(</span><span class="n">params</span><span class="p">));</span>


<span class="k">function</span><span class="w"> </span>ds_mask<span class="p">=</span><span class="nf">get_user_ds_mask</span><span class="p">(</span>params, ds_hdr<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="c">% returns a dataset containing the user mask,</span>
    <span class="c">% or [] if no user mask was supplied</span>
    <span class="n">mask_param</span><span class="p">=</span><span class="n">params</span><span class="p">.</span><span class="n">mask</span><span class="p">;</span>

    <span class="k">if</span> <span class="o">~</span><span class="n">param_specifies_user_mask</span><span class="p">(</span><span class="n">params</span><span class="p">);</span>
        <span class="n">ds_mask</span><span class="p">=[];</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="k">end</span>

    <span class="c">% get the mask in dataset form</span>
    <span class="n">opt</span><span class="p">=</span><span class="n">struct</span><span class="p">();</span>
    <span class="n">opt</span><span class="p">.</span><span class="n">mask</span><span class="p">=</span><span class="n">false</span><span class="p">;</span>
    <span class="n">ds_mask</span><span class="p">=</span><span class="n">convert_to_dataset</span><span class="p">(</span><span class="n">mask_param</span><span class="p">,</span><span class="n">opt</span><span class="p">);</span>

     <span class="c">% only support single volume</span>
    <span class="n">nsamples_mask</span><span class="p">=</span><span class="nb">size</span><span class="p">(</span><span class="n">ds_mask</span><span class="p">.</span><span class="n">samples</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">if</span> <span class="n">nsamples_mask</span><span class="o">~=</span><span class="mi">1</span>
        <span class="n">error</span><span class="p">(</span><span class="s">&#39;mask must have a single volume, found %d&#39;</span><span class="p">,</span><span class="c">...</span>
                                        <span class="n">nsamples_mask</span><span class="p">);</span>
    <span class="k">end</span>

    <span class="c">% ensure they are in the same space</span>
    <span class="n">ds_mask</span><span class="p">=</span><span class="n">align_mask_to_ds_space</span><span class="p">(</span><span class="n">ds_mask</span><span class="p">,</span> <span class="n">ds_hdr</span><span class="p">);</span>

    <span class="c">% set the samples to a boolean array</span>
    <span class="n">ds_mask</span><span class="p">.</span><span class="n">samples</span><span class="p">=</span><span class="n">samples_to_binary_mask</span><span class="p">(</span><span class="n">ds_mask</span><span class="p">.</span><span class="n">samples</span><span class="p">);</span>


<span class="k">function</span><span class="w"> </span>ds_mask<span class="p">=</span><span class="nf">align_mask_to_ds_space</span><span class="p">(</span>ds_mask, ds_hdr<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="c">% throw an error if the mask is in a different space as ds_hdr</span>

    <span class="c">% based on the header, make a minimal dataset (with no samples)</span>
    <span class="c">% so that its orientation can be obtained for ds_hdr</span>
    <span class="n">vol</span><span class="p">=</span><span class="n">ds_hdr</span><span class="p">.</span><span class="n">a</span><span class="p">.</span><span class="n">vol</span><span class="p">;</span>
    <span class="n">data</span><span class="p">=</span><span class="nb">zeros</span><span class="p">([</span><span class="n">vol</span><span class="p">.</span><span class="n">dim</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">)</span> <span class="mi">0</span><span class="p">]);</span>
    <span class="n">ds_hdr</span><span class="p">=</span><span class="n">flatten_data_array</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">vol</span><span class="p">);</span>

    <span class="c">% if in another orientation, try to match to orientation of the mask</span>
    <span class="n">ds_orient</span><span class="p">=</span><span class="n">cosmo_fmri_orientation</span><span class="p">(</span><span class="n">ds_hdr</span><span class="p">);</span>
    <span class="k">if</span> <span class="o">~</span><span class="nb">isequal</span><span class="p">(</span><span class="n">ds_orient</span><span class="p">,</span> <span class="n">cosmo_fmri_orientation</span><span class="p">(</span><span class="n">ds_mask</span><span class="p">))</span>
        <span class="n">ds_mask</span><span class="p">=</span><span class="n">cosmo_fmri_reorient</span><span class="p">(</span><span class="n">ds_mask</span><span class="p">,</span> <span class="n">ds_orient</span><span class="p">);</span>
    <span class="k">end</span>

    <span class="n">check_datasets_in_same_space</span><span class="p">(</span><span class="n">ds_mask</span><span class="p">,</span> <span class="n">ds_hdr</span><span class="p">);</span>


<span class="k">function</span><span class="w"> </span><span class="nf">check_datasets_in_same_space</span><span class="p">(</span>ds_mask, ds_hdr<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="c">% ensure the mask is compatible with the dataset</span>
    <span class="k">if</span> <span class="o">~</span><span class="nb">isequal</span><span class="p">(</span><span class="n">ds_mask</span><span class="p">.</span><span class="n">a</span><span class="p">.</span><span class="n">fdim</span><span class="p">,</span><span class="n">ds_hdr</span><span class="p">.</span><span class="n">a</span><span class="p">.</span><span class="n">fdim</span><span class="p">)</span>
        <span class="n">error</span><span class="p">(</span><span class="s">&#39;.a.fdim mismatch between data and mask&#39;</span><span class="p">);</span>
    <span class="k">end</span>

    <span class="c">% check voxel-to-world mapping</span>
    <span class="n">max_delta</span><span class="p">=</span><span class="mf">1e-4</span><span class="p">;</span> <span class="c">% allow for minor tolerance</span>
    <span class="n">delta</span><span class="p">=</span><span class="n">max</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">ds_mask</span><span class="p">.</span><span class="n">a</span><span class="p">.</span><span class="n">vol</span><span class="p">.</span><span class="n">mat</span><span class="p">(:)</span><span class="o">-</span><span class="n">ds_hdr</span><span class="p">.</span><span class="n">a</span><span class="p">.</span><span class="n">vol</span><span class="p">.</span><span class="n">mat</span><span class="p">(:)));</span>
    <span class="k">if</span> <span class="n">delta</span><span class="o">&gt;</span><span class="n">max_delta</span>
        <span class="n">error</span><span class="p">([</span><span class="s">&#39;voxel dimension mismatch between data and mask:&#39;</span><span class="c">...</span>
                    <span class="s">&#39;max difference is %.5f &gt; %.5f&#39;</span><span class="p">],</span><span class="c">...</span>
                    <span class="n">delta</span><span class="p">,</span><span class="n">max_delta</span><span class="p">);</span>
    <span class="k">end</span>


<span class="k">function</span><span class="w"> </span>ds_data<span class="p">=</span><span class="nf">flatten_data_array</span><span class="p">(</span>data, vol<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span> <span class="n">all</span><span class="p">(</span><span class="n">cosmo_isfield</span><span class="p">(</span><span class="n">data</span><span class="p">,{</span><span class="s">&#39;samples&#39;</span><span class="p">,</span><span class="s">&#39;a.vol.dim&#39;</span><span class="p">}))</span>
        <span class="n">ds_data</span><span class="p">=</span><span class="n">data</span><span class="p">;</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="k">end</span>

    <span class="c">% see how many dimensions there are, and their size</span>
    <span class="n">data_size</span> <span class="p">=</span> <span class="nb">size</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
    <span class="n">ndim</span> <span class="p">=</span> <span class="nb">numel</span><span class="p">(</span><span class="n">data_size</span><span class="p">);</span>

    <span class="k">if</span> <span class="n">ndim</span><span class="o">&lt;</span><span class="mi">4</span>
        <span class="c">% simple reshape operation</span>
        <span class="n">data</span><span class="p">=</span><span class="nb">reshape</span><span class="p">(</span><span class="n">data</span><span class="p">,[</span><span class="mi">1</span> <span class="n">data_size</span><span class="p">]);</span>
    <span class="k">elseif</span> <span class="n">ndim</span><span class="o">==</span><span class="mi">4</span>
        <span class="n">data</span><span class="p">=</span><span class="nb">shiftdim</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span>
    <span class="k">else</span>
        <span class="n">error</span><span class="p">(</span><span class="s">&#39;need 3 or 4 dimensions, found %d&#39;</span><span class="p">,</span> <span class="n">ndim</span><span class="p">);</span>
    <span class="k">end</span>

    <span class="c">% number of values in 3 spatial dimensions</span>
    <span class="n">full_size</span><span class="p">=[</span><span class="nb">size</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="mi">1</span> <span class="mi">1</span><span class="p">];</span>
    <span class="n">ni</span><span class="p">=</span><span class="n">full_size</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="n">nj</span><span class="p">=</span><span class="n">full_size</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
    <span class="n">nk</span><span class="p">=</span><span class="n">full_size</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>

    <span class="c">% make a dataset</span>
    <span class="n">ds_data</span><span class="p">=</span><span class="n">cosmo_flatten</span><span class="p">(</span><span class="n">data</span><span class="p">,{</span><span class="s">&#39;i&#39;</span><span class="p">;</span><span class="s">&#39;j&#39;</span><span class="p">;</span><span class="s">&#39;k&#39;</span><span class="p">},{</span><span class="mi">1</span><span class="p">:</span><span class="n">ni</span><span class="p">;</span><span class="mi">1</span><span class="p">:</span><span class="n">nj</span><span class="p">;</span><span class="mi">1</span><span class="p">:</span><span class="n">nk</span><span class="p">});</span>
    <span class="n">ds_data</span><span class="p">.</span><span class="n">a</span><span class="p">.</span><span class="n">vol</span><span class="p">=</span><span class="n">vol</span><span class="p">;</span>


<span class="k">function</span> <span class="nf">volumes_cell</span><span class="p">=</span><span class="n">partition_volumes</span><span class="p">(</span><span class="n">n_volumes_total</span><span class="p">,</span> <span class="n">n_voxels</span><span class="p">,</span> <span class="c">...</span>
                                                <span class="n">do_partial</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
    <span class="c">% return a cell with indices of volumes to load as specified</span>
    <span class="c">% by params.volumes.</span>
    <span class="c">% If params.volumes is empty, all volume indices are returned.</span>
    <span class="c">% If do_partial=true then each element in volume_cell has a</span>
    <span class="c">% limited number of indices so that the volumes in each cell</span>
    <span class="c">% element correspond to at most params.block_size elements (number</span>
    <span class="c">% of voxels times number of volumes).</span>
    <span class="c">% If do_partial=false, a cell with a single element with all volumes</span>
    <span class="c">% is returned.</span>

    <span class="k">if</span> <span class="o">~</span><span class="n">isfield</span><span class="p">(</span><span class="n">params</span><span class="p">,</span><span class="s">&#39;volumes&#39;</span><span class="p">)</span> <span class="o">||</span> <span class="nb">isempty</span><span class="p">(</span><span class="n">params</span><span class="p">.</span><span class="n">volumes</span><span class="p">)</span>
        <span class="n">volumes</span><span class="p">=</span><span class="mi">1</span><span class="p">:</span><span class="n">n_volumes_total</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="n">volumes</span><span class="p">=</span><span class="n">params</span><span class="p">.</span><span class="n">volumes</span><span class="p">;</span>
    <span class="k">end</span>


    <span class="k">if</span> <span class="n">do_partial</span>
        <span class="n">block_size</span><span class="p">=</span><span class="n">params</span><span class="p">.</span><span class="n">block_size</span><span class="p">;</span>
        <span class="n">n_volumes_per_block</span><span class="p">=</span><span class="nb">floor</span><span class="p">(</span><span class="n">block_size</span> <span class="o">/</span> <span class="n">n_voxels</span><span class="p">);</span>

        <span class="k">if</span> <span class="n">n_volumes_per_block</span><span class="o">&lt;</span><span class="mi">1</span>
            <span class="n">n_volumes_per_block</span><span class="p">=</span><span class="mi">1</span><span class="p">;</span>
        <span class="k">end</span>

        <span class="n">n_volumes_to_load</span><span class="p">=</span><span class="nb">numel</span><span class="p">(</span><span class="n">volumes</span><span class="p">);</span>
        <span class="n">n_blocks</span><span class="p">=</span><span class="nb">ceil</span><span class="p">(</span><span class="n">n_volumes_to_load</span> <span class="o">/</span> <span class="n">n_volumes_per_block</span><span class="p">);</span>

        <span class="k">if</span> <span class="n">n_blocks</span><span class="o">&lt;</span><span class="mi">1</span>
            <span class="n">n_blocks</span><span class="p">=</span><span class="n">n_volumes_to_load</span><span class="p">;</span>
            <span class="n">n_volumes_per_block</span><span class="p">=</span><span class="mi">1</span><span class="p">;</span>
        <span class="k">end</span>

        <span class="n">volumes_cell</span><span class="p">=</span><span class="n">cell</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_blocks</span><span class="p">);</span>
        <span class="n">first_index</span><span class="p">=</span><span class="mi">1</span><span class="p">;</span>
        <span class="k">for</span> <span class="n">block</span><span class="p">=</span><span class="mi">1</span><span class="p">:</span><span class="n">n_blocks</span>
            <span class="n">last_index</span><span class="p">=</span><span class="n">min</span><span class="p">(</span><span class="n">n_volumes_to_load</span><span class="p">,</span> <span class="c">...</span>
                            <span class="n">first_index</span><span class="o">+</span><span class="n">n_volumes_per_block</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>

            <span class="n">volumes_cell</span><span class="p">{</span><span class="n">block</span><span class="p">}=</span><span class="n">volumes</span><span class="p">(</span><span class="n">first_index</span><span class="p">:</span><span class="n">last_index</span><span class="p">);</span>

            <span class="n">first_index</span><span class="p">=</span><span class="n">last_index</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
        <span class="k">end</span>

        <span class="n">assert</span><span class="p">(</span><span class="n">all</span><span class="p">(</span><span class="n">cellfun</span><span class="p">(@</span><span class="nb">numel</span><span class="p">,</span><span class="n">volumes_cell</span><span class="p">)</span><span class="o">&gt;</span><span class="p">=</span><span class="mi">1</span><span class="p">));</span>
    <span class="k">else</span>
        <span class="n">volumes_cell</span><span class="p">={</span><span class="n">volumes</span><span class="p">};</span>
    <span class="k">end</span>

<span class="k">function</span><span class="w"> </span>result<span class="p">=</span><span class="nf">fast_import_data</span><span class="p">(</span>fn<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">x</span><span class="p">=</span><span class="n">load</span><span class="p">(</span><span class="n">fn</span><span class="p">);</span>
    <span class="n">keys</span><span class="p">=</span><span class="n">fieldnames</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
    <span class="k">if</span> <span class="n">isfield</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="s">&#39;samples&#39;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">isnumeric</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">samples</span><span class="p">)</span>
        <span class="n">result</span><span class="p">=</span><span class="n">x</span><span class="p">;</span>
    <span class="k">elseif</span> <span class="nb">numel</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span>
        <span class="n">result</span><span class="p">=</span><span class="n">x</span><span class="p">.(</span><span class="n">keys</span><span class="p">{</span><span class="mi">1</span><span class="p">});</span>
    <span class="k">else</span>
        <span class="n">error</span><span class="p">(</span><span class="s">&#39;Cannot load .mat file %s with multiple variables: %s&#39;</span><span class="p">,</span><span class="c">...</span>
                <span class="n">fn</span><span class="p">,</span> <span class="n">cosmo_strjoin</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span><span class="s">&#39;, &#39;</span><span class="p">));</span>
    <span class="k">end</span>



<span class="k">function</span><span class="w"> </span>ds<span class="p">=</span><span class="nf">set_sa_vec</span><span class="p">(</span>ds,p,fieldname<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="c">% helper: sets a sample attribute as a vector</span>
    <span class="c">% throws an error if it has the wrong size</span>
    <span class="n">v</span><span class="p">=</span><span class="n">p</span><span class="p">.(</span><span class="n">fieldname</span><span class="p">);</span>
    <span class="k">if</span> <span class="nb">isequal</span><span class="p">(</span><span class="nb">size</span><span class="p">(</span><span class="n">v</span><span class="p">),[</span><span class="mi">0</span> <span class="mi">0</span><span class="p">])</span>
        <span class="c">% ignore &#39;[]&#39;, but not zeros(10,0)</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="k">end</span>
    <span class="n">nsamples</span><span class="p">=</span><span class="nb">size</span><span class="p">(</span><span class="n">ds</span><span class="p">.</span><span class="n">samples</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>

    <span class="n">n</span><span class="p">=</span><span class="nb">numel</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
    <span class="k">if</span> <span class="n">n</span><span class="o">==</span><span class="mi">1</span>
        <span class="c">% singleton element - repeat nsamples times.</span>
        <span class="n">v</span><span class="p">=</span><span class="nb">repmat</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">nsamples</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
        <span class="n">n</span><span class="p">=</span><span class="n">nsamples</span><span class="p">;</span>
    <span class="k">end</span>
    <span class="k">if</span> <span class="o">~</span><span class="p">(</span><span class="n">n</span><span class="o">==</span><span class="mi">0</span> <span class="o">||</span> <span class="n">n</span><span class="o">==</span><span class="n">nsamples</span><span class="p">)</span>
        <span class="n">error</span><span class="p">(</span><span class="s">&#39;size mismatch for %s: expected %d values, found %d&#39;</span><span class="p">,</span> <span class="c">...</span>
                        <span class="n">fieldname</span><span class="p">,</span> <span class="n">nsamples</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
    <span class="k">end</span>
    <span class="n">ds</span><span class="p">.</span><span class="n">sa</span><span class="p">.(</span><span class="n">fieldname</span><span class="p">)=</span><span class="n">v</span><span class="p">(:);</span>

<span class="k">function</span><span class="w"> </span>tf<span class="p">=</span><span class="nf">string_endswith</span><span class="p">(</span>s, tail<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">tf</span><span class="p">=</span><span class="n">ischar</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">~</span><span class="nb">isempty</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nb">isempty</span><span class="p">(</span><span class="n">cosmo_strsplit</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">tail</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">));</span>


<span class="k">function</span><span class="w"> </span>img_format<span class="p">=</span><span class="nf">find_img_format</span><span class="p">(</span>filename, img_formats<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="c">% helper: find image format of filename fn</span>

    <span class="n">fns</span><span class="p">=</span><span class="n">fieldnames</span><span class="p">(</span><span class="n">img_formats</span><span class="p">);</span>
    <span class="n">n</span><span class="p">=</span><span class="nb">numel</span><span class="p">(</span><span class="n">fns</span><span class="p">);</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">=</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span>
        <span class="n">fn</span><span class="p">=</span><span class="n">fns</span><span class="p">{</span><span class="n">k</span><span class="p">};</span>

        <span class="k">if</span> <span class="n">ischar</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
            <span class="n">exts</span><span class="p">=</span><span class="n">img_formats</span><span class="p">.(</span><span class="n">fn</span><span class="p">).</span><span class="n">exts</span><span class="p">;</span>
            <span class="n">m</span><span class="p">=</span><span class="nb">numel</span><span class="p">(</span><span class="n">exts</span><span class="p">);</span>
            <span class="k">for</span> <span class="nb">j</span><span class="p">=</span><span class="mi">1</span><span class="p">:</span><span class="n">m</span>
                <span class="n">ext</span><span class="p">=</span><span class="n">exts</span><span class="p">{</span><span class="nb">j</span><span class="p">};</span>
                <span class="k">if</span> <span class="n">string_endswith</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="n">ext</span><span class="p">)</span>
                    <span class="n">img_format</span><span class="p">=</span><span class="n">fn</span><span class="p">;</span>
                    <span class="k">return</span>
                <span class="k">end</span>
            <span class="k">end</span>
        <span class="k">else</span>
            <span class="c">% it could be a struct - try that</span>
            <span class="n">matcher</span><span class="p">=</span><span class="n">img_formats</span><span class="p">.(</span><span class="n">fn</span><span class="p">).</span><span class="n">matcher</span><span class="p">;</span>
            <span class="k">if</span> <span class="n">matcher</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
                <span class="n">img_format</span><span class="p">=</span><span class="n">fn</span><span class="p">;</span>
                <span class="k">return</span>
            <span class="k">end</span>
        <span class="k">end</span>
    <span class="k">end</span>

    <span class="k">if</span> <span class="n">ischar</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="n">desc</span><span class="p">=</span><span class="n">sprintf</span><span class="p">(</span><span class="s">&#39;file &#39;&#39;%s&#39;&#39;&#39;</span><span class="p">,</span><span class="n">filename</span><span class="p">);</span>
    <span class="k">else</span>
        <span class="n">desc</span><span class="p">=</span><span class="n">sprintf</span><span class="p">(</span><span class="s">&#39;&lt;%s&gt; input&#39;</span><span class="p">,</span><span class="n">class</span><span class="p">(</span><span class="n">filename</span><span class="p">));</span>
    <span class="k">end</span>
    <span class="n">error</span><span class="p">(</span><span class="s">&#39;Could not find image format for %s&#39;</span><span class="p">,</span><span class="n">desc</span><span class="p">);</span>


<span class="k">function</span><span class="w"> </span>auto_mask<span class="p">=</span><span class="nf">compute_auto_mask</span><span class="p">(</span>data, mask_type<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="c">% mask_type can be &#39;any&#39;, &#39;all&#39;, &#39;auto&#39;, or &#39;&#39;</span>
    <span class="c">% When using &#39;auto&#39;, &#39;any&#39; and &#39;all&#39; should give the same mask</span>
    <span class="c">% When using &#39;&#39;, a warning is shown when the percentage of</span>
    <span class="c">% non{zero,finite} features exceeds pct_thrshold</span>

    <span class="k">if</span> <span class="nb">isequal</span><span class="p">(</span><span class="n">mask_type</span><span class="p">,</span><span class="n">true</span><span class="p">)</span>
        <span class="n">mask_type</span><span class="p">=</span><span class="s">&#39;-auto&#39;</span><span class="p">;</span>
    <span class="k">end</span>


    <span class="n">pct_threshold</span><span class="p">=</span><span class="mi">5</span><span class="p">;</span>

    <span class="n">to_remove</span><span class="p">=</span><span class="o">~</span><span class="n">samples_to_binary_mask</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>


    <span class="c">% take as a mask anywhere where any feature is nonzero.</span>
    <span class="k">if</span> <span class="n">cosmo_match</span><span class="p">({</span><span class="n">mask_type</span><span class="p">},{</span><span class="s">&#39;-any&#39;</span><span class="p">,</span><span class="s">&#39;-auto&#39;</span><span class="p">,</span><span class="s">&#39;&#39;</span><span class="p">})</span>
        <span class="n">to_remove_any</span><span class="p">=</span><span class="n">any</span><span class="p">(</span><span class="n">to_remove</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">end</span>

    <span class="k">if</span> <span class="n">cosmo_match</span><span class="p">({</span><span class="n">mask_type</span><span class="p">},{</span><span class="s">&#39;-all&#39;</span><span class="p">,</span><span class="s">&#39;-auto&#39;</span><span class="p">,</span><span class="s">&#39;&#39;</span><span class="p">})</span>
        <span class="n">to_remove_all</span><span class="p">=</span><span class="n">all</span><span class="p">(</span><span class="n">to_remove</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">end</span>

    <span class="k">switch</span> <span class="n">mask_type</span>
        <span class="k">case</span> <span class="p">{</span><span class="s">&#39;-auto&#39;</span><span class="p">,</span><span class="s">&#39;&#39;</span><span class="p">}</span>
            <span class="c">%</span>
            <span class="n">any_equals_all</span><span class="p">=</span><span class="nb">isequal</span><span class="p">(</span><span class="n">to_remove_any</span><span class="p">,</span> <span class="n">to_remove_all</span><span class="p">);</span>

            <span class="n">n</span><span class="p">=</span><span class="nb">numel</span><span class="p">(</span><span class="n">to_remove_any</span><span class="p">);</span>
            <span class="n">n_any</span><span class="p">=</span><span class="n">sum</span><span class="p">(</span><span class="n">to_remove_any</span><span class="p">(:));</span>
            <span class="n">n_all</span><span class="p">=</span><span class="n">sum</span><span class="p">(</span><span class="n">to_remove_all</span><span class="p">(:));</span>

            <span class="n">pct_any</span><span class="p">=</span><span class="mi">100</span><span class="o">*</span><span class="n">n_any</span><span class="o">/</span><span class="n">n</span><span class="p">;</span>
            <span class="n">pct_all</span><span class="p">=</span><span class="mi">100</span><span class="o">*</span><span class="n">n_all</span><span class="o">/</span><span class="n">n</span><span class="p">;</span>

            <span class="n">do_mask_suggestion</span><span class="p">=</span><span class="n">pct_all</span><span class="o">&gt;</span><span class="n">pct_threshold</span> <span class="o">&amp;&amp;</span> <span class="c">...</span>
                                <span class="n">strcmp</span><span class="p">(</span><span class="n">mask_type</span><span class="p">,</span><span class="s">&#39;&#39;</span><span class="p">);</span>

            <span class="k">if</span> <span class="n">any_equals_all</span>
                <span class="k">if</span> <span class="n">do_mask_suggestion</span>
                    <span class="n">me_name</span><span class="p">=</span><span class="n">mfilename</span><span class="p">();</span>
                    <span class="n">msg</span><span class="p">=</span><span class="n">sprintf</span><span class="p">([</span><span class="s">&#39;%d (%.1f%%) features are non&#39;</span><span class="c">...</span>
                                <span class="s">&#39;{zero,finite} in all samples (and no &#39;</span><span class="c">...</span>
                                <span class="s">&#39;features have non-{zero,finite} &#39;</span><span class="c">...</span>
                                <span class="s">&#39;values in some samples and not &#39;</span><span class="c">...</span>
                                <span class="s">&#39;in others)\n&#39;</span><span class="c">...</span>
                                <span class="s">&#39;To use a mask excluding these &#39;</span><span class="c">...</span>
                                <span class="s">&#39;features: %s(...,&#39;&#39;mask&#39;&#39;,-auto&#39;&#39;)\n&#39;</span><span class="p">],</span><span class="c">...</span>
                                <span class="n">n_all</span><span class="p">,</span><span class="n">pct_all</span><span class="p">,</span><span class="n">me_name</span><span class="p">);</span>
                    <span class="n">cosmo_warning</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>

                    <span class="n">to_remove</span><span class="p">=[];</span>
                <span class="k">else</span>
                    <span class="n">to_remove</span><span class="p">=</span><span class="n">to_remove_any</span><span class="p">;</span>
                <span class="k">end</span>
            <span class="k">else</span>
                <span class="c">% give error or warning</span>
                <span class="n">me_name</span><span class="p">=</span><span class="n">mfilename</span><span class="p">();</span>

                <span class="n">msg</span><span class="p">=</span><span class="n">sprintf</span><span class="p">([</span><span class="s">&#39;%d (%.1f%%) features are non{zero,&#39;</span><span class="c">...</span>
                            <span class="s">&#39;finite} in all samples\n&#39;</span><span class="c">...</span>
                            <span class="s">&#39;%d (%.1f%%) features are non{zero,&#39;</span><span class="c">...</span>
                            <span class="s">&#39;finite} in at least one sample\n&#39;</span><span class="c">...</span>
                            <span class="s">&#39;To use a mask excluding &#39;</span><span class="c">...</span>
                            <span class="s">&#39;features:\n&#39;</span><span class="c">...</span>
                            <span class="s">&#39;- where *all* values are non{zero,finite}:&#39;</span><span class="c">...</span>
                            <span class="s">&#39; %s(...,&#39;&#39;mask&#39;&#39;,-all&#39;&#39;)\n&#39;</span><span class="c">...</span>
                            <span class="s">&#39;- where *any* value  is  non{zero,finite}:&#39;</span><span class="c">...</span>
                            <span class="s">&#39; %s(...,&#39;&#39;mask&#39;&#39;,-any&#39;&#39;)\n&#39;</span><span class="p">],</span><span class="c">...</span>
                            <span class="n">n_all</span><span class="p">,</span><span class="n">pct_all</span><span class="p">,</span><span class="n">n_any</span><span class="p">,</span><span class="n">pct_any</span><span class="p">,</span><span class="n">me_name</span><span class="p">,</span><span class="n">me_name</span><span class="p">);</span>

                <span class="k">if</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">mask_type</span><span class="p">,</span><span class="s">&#39;-auto&#39;</span><span class="p">);</span>
                    <span class="n">error</span><span class="p">(</span><span class="s">&#39;automatic mask failed:\n%s&#39;</span><span class="p">,</span><span class="n">msg</span><span class="p">);</span>
                <span class="k">else</span>
                    <span class="c">% give a warning</span>
                    <span class="n">cosmo_warning</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
                    <span class="c">% set mask to empty; a mask will not be applied</span>
                    <span class="n">to_remove</span><span class="p">=[];</span>
                <span class="k">end</span>
            <span class="k">end</span>
        <span class="k">case</span> <span class="s">&#39;-any&#39;</span>
            <span class="n">to_remove</span><span class="p">=</span><span class="n">to_remove_any</span><span class="p">;</span>
        <span class="k">case</span> <span class="s">&#39;-all&#39;</span>
            <span class="n">to_remove</span><span class="p">=</span><span class="n">to_remove_all</span><span class="p">;</span>
        <span class="k">otherwise</span>
            <span class="n">error</span><span class="p">(</span><span class="s">&#39;illegal mask specification &#39;&#39;-%s&#39;&#39;&#39;</span><span class="p">,</span> <span class="n">mask_type</span><span class="p">);</span>
    <span class="k">end</span>

    <span class="n">auto_mask</span><span class="p">=</span><span class="o">~</span><span class="n">to_remove</span><span class="p">(:)</span><span class="o">&#39;</span><span class="p">;</span>



<span class="c">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
<span class="c">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
<span class="c">%</span>
<span class="c">% Definition of supported data formats</span>
<span class="c">%</span>
<span class="c">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
<span class="c">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>

<span class="k">function</span><span class="w"> </span>img_formats<span class="p">=</span><span class="nf">get_img_formats</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="c">% define which formats are supported.</span>
    <span class="c">%</span>
    <span class="c">% The intention is to support a wide variety of formats through</span>
    <span class="c">% different external toolboxes, yet support these in a uniform way. If</span>
    <span class="c">% the toolbox supports loading a subset of the data</span>
    <span class="c">% (NIfTI, AFNI, SPM), then a .data_reader can be defined which</span>
    <span class="c">% only loads the requested data; otherwise (BrainVoyager, non-SPM</span>
    <span class="c">% .mat files) all data is read and the requested data selected</span>
    <span class="c">% afterwards</span>
    <span class="c">%</span>
    <span class="c">% In the definitions below:</span>
    <span class="c">% - native header:    contains at least minimal header information in</span>
    <span class="c">%                     the format&#39;s representation</span>
    <span class="c">% - minimal dataset:  contains at least minimal header information in</span>
    <span class="c">%                     dataset format (in .sa.samples, .a.vol.dim and</span>
    <span class="c">%                     .a.vol.mat)</span>
    <span class="c">% - nvolumes          number of volumes available in the input</span>
    <span class="c">% - native header  }  native header information and data stored in</span>
    <span class="c">%   and data:      }  native representation</span>
    <span class="c">% - volumes           indices of volumes to read</span>
    <span class="c">% - 4D data           volume data in X x Y x Z x T</span>
    <span class="c">%</span>
    <span class="c">% Each format is defined by these fields:</span>
    <span class="c">% .exts               file name extensions</span>
    <span class="c">% .externals          required externals</span>
    <span class="c">% .header_reader      file name -&gt; native header</span>
    <span class="c">% [.struct_header_reader] (file name, native header) -&gt; native header</span>
    <span class="c">%                     (used for SPM.mat, to avoid re-loading the file)</span>
    <span class="c">% .header_converter   (native header, params)  -&gt; (minimal dataset,</span>
    <span class="c">%                                                   nvolumes)</span>
    <span class="c">% [.data_reader]      (file name,</span>
    <span class="c">%                      native header, volumes) -&gt; (native header and</span>
    <span class="c">%                                                    data)</span>
    <span class="c">% .data_converter     (native header and data,</span>
    <span class="c">%                      volumes)                -&gt; 4D data array</span>
    <span class="c">% [.convert_volume]   if false, then the native header format must be</span>
    <span class="c">%                     an fmri dataset</span>
    <span class="c">%</span>
    <span class="c">% Notes:</span>
    <span class="c">% - if .data_reader is absent, then .header_reader must return a</span>
    <span class="c">%   header that contains the data and which can be converter by</span>
    <span class="c">%   .data_converter.</span>
    <span class="c">% - if .convert_volume is not present, then the output frmo</span>
    <span class="c">%   .data_converter is assumed to return a COSMoMVPA dataset struct</span>
    <span class="c">%   (instead of 4D data)</span>
    <span class="n">img_formats</span><span class="p">=</span><span class="n">struct</span><span class="p">();</span>

    <span class="n">img_formats</span><span class="p">.</span><span class="n">nii</span><span class="p">.</span><span class="n">exts</span><span class="p">={</span><span class="s">&#39;.nii.gz&#39;</span><span class="p">,</span><span class="s">&#39;.nii&#39;</span><span class="p">,</span><span class="s">&#39;.hdr&#39;</span><span class="p">,</span><span class="s">&#39;.img&#39;</span><span class="p">};</span>
    <span class="n">img_formats</span><span class="p">.</span><span class="n">nii</span><span class="p">.</span><span class="n">externals</span><span class="p">={</span><span class="s">&#39;nifti&#39;</span><span class="p">};</span>
    <span class="n">img_formats</span><span class="p">.</span><span class="n">nii</span><span class="p">.</span><span class="n">matcher</span><span class="p">=@</span><span class="n">isa_nii</span><span class="p">;</span>
    <span class="n">img_formats</span><span class="p">.</span><span class="n">nii</span><span class="p">.</span><span class="n">header_reader</span><span class="p">=@</span><span class="n">read_nii_header</span><span class="p">;</span>
    <span class="n">img_formats</span><span class="p">.</span><span class="n">nii</span><span class="p">.</span><span class="n">header_converter</span><span class="p">=@</span><span class="n">convert_nii_header</span><span class="p">;</span>
    <span class="n">img_formats</span><span class="p">.</span><span class="n">nii</span><span class="p">.</span><span class="n">data_reader</span><span class="p">=@</span><span class="n">read_nii_data</span><span class="p">;</span>
    <span class="n">img_formats</span><span class="p">.</span><span class="n">nii</span><span class="p">.</span><span class="n">data_converter</span><span class="p">=@</span><span class="n">convert_nii_data</span><span class="p">;</span>


    <span class="n">img_formats</span><span class="p">.</span><span class="n">bv_glm</span><span class="p">.</span><span class="n">exts</span><span class="p">={</span><span class="s">&#39;.glm&#39;</span><span class="p">};</span>
    <span class="n">img_formats</span><span class="p">.</span><span class="n">bv_glm</span><span class="p">.</span><span class="n">externals</span><span class="p">={</span><span class="s">&#39;neuroelf&#39;</span><span class="p">};</span>
    <span class="n">img_formats</span><span class="p">.</span><span class="n">bv_glm</span><span class="p">.</span><span class="n">matcher</span><span class="p">=@</span><span class="n">isa_bv_glm</span><span class="p">;</span>
    <span class="n">img_formats</span><span class="p">.</span><span class="n">bv_glm</span><span class="p">.</span><span class="n">header_reader</span><span class="p">=@</span><span class="n">read_bv_glm_header</span><span class="p">;</span>
    <span class="n">img_formats</span><span class="p">.</span><span class="n">bv_glm</span><span class="p">.</span><span class="n">header_converter</span><span class="p">=@</span><span class="n">convert_bv_glm_header</span><span class="p">;</span>
    <span class="n">img_formats</span><span class="p">.</span><span class="n">bv_glm</span><span class="p">.</span><span class="n">data_converter</span><span class="p">=@</span><span class="n">convert_bv_glm_data</span><span class="p">;</span>


    <span class="n">img_formats</span><span class="p">.</span><span class="n">bv_msk</span><span class="p">.</span><span class="n">exts</span><span class="p">={</span><span class="s">&#39;.msk&#39;</span><span class="p">};</span>
    <span class="n">img_formats</span><span class="p">.</span><span class="n">bv_msk</span><span class="p">.</span><span class="n">externals</span><span class="p">={</span><span class="s">&#39;neuroelf&#39;</span><span class="p">};</span>
    <span class="n">img_formats</span><span class="p">.</span><span class="n">bv_msk</span><span class="p">.</span><span class="n">matcher</span><span class="p">=@</span><span class="n">isa_bv_msk</span><span class="p">;</span>
    <span class="n">img_formats</span><span class="p">.</span><span class="n">bv_msk</span><span class="p">.</span><span class="n">header_reader</span><span class="p">=@</span><span class="n">read_bv_msk_header</span><span class="p">;</span>
    <span class="n">img_formats</span><span class="p">.</span><span class="n">bv_msk</span><span class="p">.</span><span class="n">header_converter</span><span class="p">=@</span><span class="n">convert_bv_msk_header</span><span class="p">;</span>
    <span class="n">img_formats</span><span class="p">.</span><span class="n">bv_msk</span><span class="p">.</span><span class="n">data_converter</span><span class="p">=@</span><span class="n">convert_bv_msk_data</span><span class="p">;</span>


    <span class="n">img_formats</span><span class="p">.</span><span class="n">bv_vtc</span><span class="p">.</span><span class="n">exts</span><span class="p">={</span><span class="s">&#39;.vtc&#39;</span><span class="p">};</span>
    <span class="n">img_formats</span><span class="p">.</span><span class="n">bv_vtc</span><span class="p">.</span><span class="n">externals</span><span class="p">={</span><span class="s">&#39;neuroelf&#39;</span><span class="p">};</span>
    <span class="n">img_formats</span><span class="p">.</span><span class="n">bv_vtc</span><span class="p">.</span><span class="n">matcher</span><span class="p">=@</span><span class="n">isa_bv_vtc</span><span class="p">;</span>
    <span class="n">img_formats</span><span class="p">.</span><span class="n">bv_vtc</span><span class="p">.</span><span class="n">header_reader</span><span class="p">=@</span><span class="n">read_bv_vtc_header</span><span class="p">;</span>
    <span class="n">img_formats</span><span class="p">.</span><span class="n">bv_vtc</span><span class="p">.</span><span class="n">header_converter</span><span class="p">=@</span><span class="n">convert_bv_vtc_header</span><span class="p">;</span>
    <span class="n">img_formats</span><span class="p">.</span><span class="n">bv_vtc</span><span class="p">.</span><span class="n">data_converter</span><span class="p">=@</span><span class="n">convert_bv_vtc_data</span><span class="p">;</span>


    <span class="n">img_formats</span><span class="p">.</span><span class="n">bv_vmp</span><span class="p">.</span><span class="n">exts</span><span class="p">={</span><span class="s">&#39;.vmp&#39;</span><span class="p">};</span>
    <span class="n">img_formats</span><span class="p">.</span><span class="n">bv_vmp</span><span class="p">.</span><span class="n">externals</span><span class="p">={</span><span class="s">&#39;neuroelf&#39;</span><span class="p">};</span>
    <span class="n">img_formats</span><span class="p">.</span><span class="n">bv_vmp</span><span class="p">.</span><span class="n">matcher</span><span class="p">=@</span><span class="n">isa_bv_vmp</span><span class="p">;</span>
    <span class="n">img_formats</span><span class="p">.</span><span class="n">bv_vmp</span><span class="p">.</span><span class="n">header_reader</span><span class="p">=@</span><span class="n">read_bv_vmp_header</span><span class="p">;</span>
    <span class="n">img_formats</span><span class="p">.</span><span class="n">bv_vmp</span><span class="p">.</span><span class="n">header_converter</span><span class="p">=@</span><span class="n">convert_bv_vmp_header</span><span class="p">;</span>
    <span class="n">img_formats</span><span class="p">.</span><span class="n">bv_vmp</span><span class="p">.</span><span class="n">data_converter</span><span class="p">=@</span><span class="n">convert_bv_vmp_data</span><span class="p">;</span>


    <span class="n">img_formats</span><span class="p">.</span><span class="n">bv_vmr</span><span class="p">.</span><span class="n">exts</span><span class="p">={</span><span class="s">&#39;.vmr&#39;</span><span class="p">};</span>
    <span class="n">img_formats</span><span class="p">.</span><span class="n">bv_vmr</span><span class="p">.</span><span class="n">externals</span><span class="p">={</span><span class="s">&#39;neuroelf&#39;</span><span class="p">};</span>
    <span class="n">img_formats</span><span class="p">.</span><span class="n">bv_vmr</span><span class="p">.</span><span class="n">matcher</span><span class="p">=@</span><span class="n">isa_bv_vmr</span><span class="p">;</span>
    <span class="n">img_formats</span><span class="p">.</span><span class="n">bv_vmr</span><span class="p">.</span><span class="n">header_reader</span><span class="p">=@</span><span class="n">read_bv_vmr_header</span><span class="p">;</span>
    <span class="n">img_formats</span><span class="p">.</span><span class="n">bv_vmr</span><span class="p">.</span><span class="n">header_converter</span><span class="p">=@</span><span class="n">convert_bv_vmr_header</span><span class="p">;</span>
    <span class="n">img_formats</span><span class="p">.</span><span class="n">bv_vmr</span><span class="p">.</span><span class="n">data_converter</span><span class="p">=@</span><span class="n">convert_bv_vmr_data</span><span class="p">;</span>


    <span class="n">img_formats</span><span class="p">.</span><span class="n">spm</span><span class="p">.</span><span class="n">exts</span><span class="p">={</span><span class="s">&#39;mat:con&#39;</span><span class="p">,</span><span class="s">&#39;mat:beta&#39;</span><span class="p">,</span><span class="s">&#39;mat:spm&#39;</span><span class="p">};</span>
    <span class="n">img_formats</span><span class="p">.</span><span class="n">spm</span><span class="p">.</span><span class="n">externals</span><span class="p">=</span><span class="n">img_formats</span><span class="p">.</span><span class="n">nii</span><span class="p">.</span><span class="n">externals</span><span class="p">;</span>
    <span class="n">img_formats</span><span class="p">.</span><span class="n">spm</span><span class="p">.</span><span class="n">matcher</span><span class="p">=@</span><span class="n">isa_spm</span><span class="p">;</span>
    <span class="n">img_formats</span><span class="p">.</span><span class="n">spm</span><span class="p">.</span><span class="n">struct_header_reader</span><span class="p">=@</span><span class="n">read_spm_struct_header</span><span class="p">;</span>
    <span class="n">img_formats</span><span class="p">.</span><span class="n">spm</span><span class="p">.</span><span class="n">header_reader</span><span class="p">=@</span><span class="n">read_spm_header</span><span class="p">;</span>
    <span class="n">img_formats</span><span class="p">.</span><span class="n">spm</span><span class="p">.</span><span class="n">header_converter</span><span class="p">=@</span><span class="n">convert_spm_header</span><span class="p">;</span>
    <span class="n">img_formats</span><span class="p">.</span><span class="n">spm</span><span class="p">.</span><span class="n">data_reader</span><span class="p">=@</span><span class="n">read_spm_data</span><span class="p">;</span>
    <span class="n">img_formats</span><span class="p">.</span><span class="n">spm</span><span class="p">.</span><span class="n">data_converter</span><span class="p">=@</span><span class="n">convert_spm_data</span><span class="p">;</span>


    <span class="n">img_formats</span><span class="p">.</span><span class="n">afni</span><span class="p">.</span><span class="n">exts</span><span class="p">={</span><span class="s">&#39;+orig&#39;</span><span class="p">,</span><span class="s">&#39;+orig.HEAD&#39;</span><span class="p">,</span><span class="s">&#39;+orig.BRIK&#39;</span><span class="p">,</span><span class="c">...</span>
                           <span class="s">&#39;+orig.BRIK.gz&#39;</span><span class="p">,</span><span class="s">&#39;+tlrc&#39;</span><span class="p">,</span><span class="s">&#39;+tlrc.HEAD&#39;</span><span class="p">,</span><span class="c">...</span>
                           <span class="s">&#39;+tlrc.BRIK&#39;</span><span class="p">,</span><span class="s">&#39;+tlrc.BRIK.gz&#39;</span><span class="p">};</span>
    <span class="n">img_formats</span><span class="p">.</span><span class="n">afni</span><span class="p">.</span><span class="n">externals</span><span class="p">={</span><span class="s">&#39;afni&#39;</span><span class="p">};</span>
    <span class="n">img_formats</span><span class="p">.</span><span class="n">afni</span><span class="p">.</span><span class="n">matcher</span><span class="p">=@</span><span class="n">isa_afni</span><span class="p">;</span>
    <span class="n">img_formats</span><span class="p">.</span><span class="n">afni</span><span class="p">.</span><span class="n">header_reader</span><span class="p">=@</span><span class="n">read_afni_header</span><span class="p">;</span>
    <span class="n">img_formats</span><span class="p">.</span><span class="n">afni</span><span class="p">.</span><span class="n">header_converter</span><span class="p">=@</span><span class="n">convert_afni_header</span><span class="p">;</span>
    <span class="n">img_formats</span><span class="p">.</span><span class="n">afni</span><span class="p">.</span><span class="n">data_reader</span><span class="p">=@</span><span class="n">read_afni_data</span><span class="p">;</span>
    <span class="n">img_formats</span><span class="p">.</span><span class="n">afni</span><span class="p">.</span><span class="n">data_converter</span><span class="p">=@</span><span class="n">convert_afni_data</span><span class="p">;</span>


    <span class="n">img_formats</span><span class="p">.</span><span class="n">ft_source</span><span class="p">.</span><span class="n">exts</span><span class="p">=</span><span class="n">cell</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">img_formats</span><span class="p">.</span><span class="n">ft_source</span><span class="p">.</span><span class="n">externals</span><span class="p">=</span><span class="n">cell</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">img_formats</span><span class="p">.</span><span class="n">ft_source</span><span class="p">.</span><span class="n">matcher</span><span class="p">=@</span><span class="n">isa_ft_source</span><span class="p">;</span>
    <span class="n">img_formats</span><span class="p">.</span><span class="n">ft_source</span><span class="p">.</span><span class="n">header_reader</span><span class="p">=@</span><span class="n">read_ft_source_header</span><span class="p">;</span>
    <span class="n">img_formats</span><span class="p">.</span><span class="n">ft_source</span><span class="p">.</span><span class="n">header_converter</span><span class="p">=@</span><span class="n">convert_ft_source_header</span><span class="p">;</span>
    <span class="n">img_formats</span><span class="p">.</span><span class="n">ft_source</span><span class="p">.</span><span class="n">data_converter</span><span class="p">=@</span><span class="n">convert_ft_source_data</span><span class="p">;</span>
    <span class="n">img_formats</span><span class="p">.</span><span class="n">ft_source</span><span class="p">.</span><span class="n">convert_volume</span><span class="p">=</span><span class="n">false</span><span class="p">;</span> <span class="c">% already dataset</span>


    <span class="c">% fMRI volumetric datasets exported with PyMVPA&#39;s cosmo module</span>
    <span class="n">img_formats</span><span class="p">.</span><span class="n">pymvpa_fmri_ds</span><span class="p">.</span><span class="n">exts</span><span class="p">=</span><span class="n">cell</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">img_formats</span><span class="p">.</span><span class="n">pymvpa_fmri_ds</span><span class="p">.</span><span class="n">matcher</span><span class="p">=@</span><span class="n">isa_pymvpa_fmri</span><span class="p">;</span>
    <span class="n">img_formats</span><span class="p">.</span><span class="n">pymvpa_fmri_ds</span><span class="p">.</span><span class="n">externals</span><span class="p">=</span><span class="n">cell</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">img_formats</span><span class="p">.</span><span class="n">pymvpa_fmri_ds</span><span class="p">.</span><span class="n">header_reader</span><span class="p">=@</span><span class="n">read_pymvpa_ds_header</span><span class="p">;</span>
    <span class="n">img_formats</span><span class="p">.</span><span class="n">pymvpa_fmri_ds</span><span class="p">.</span><span class="n">header_converter</span><span class="p">=@</span><span class="n">convert_pymvpa_ds_header</span><span class="p">;</span>
    <span class="n">img_formats</span><span class="p">.</span><span class="n">pymvpa_fmri_ds</span><span class="p">.</span><span class="n">data_converter</span><span class="p">=@</span><span class="n">convert_pymvpa_ds_data</span><span class="p">;</span>
    <span class="n">img_formats</span><span class="p">.</span><span class="n">pymvpa_fmri_ds</span><span class="p">.</span><span class="n">convert_volume</span><span class="p">=</span><span class="n">false</span><span class="p">;</span> <span class="c">% already dataset</span>


    <span class="n">img_formats</span><span class="p">.</span><span class="n">cosmo_fmri_ds</span><span class="p">.</span><span class="n">exts</span><span class="p">=</span><span class="n">cell</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">img_formats</span><span class="p">.</span><span class="n">cosmo_fmri_ds</span><span class="p">.</span><span class="n">matcher</span><span class="p">=@(</span><span class="n">x</span><span class="p">)</span><span class="n">isa_cosmo_fmri</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="c">...</span>
                                            <span class="o">~</span><span class="n">isa_pymvpa_fmri</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
    <span class="n">img_formats</span><span class="p">.</span><span class="n">cosmo_fmri_ds</span><span class="p">.</span><span class="n">externals</span><span class="p">=</span><span class="n">cell</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">img_formats</span><span class="p">.</span><span class="n">cosmo_fmri_ds</span><span class="p">.</span><span class="n">header_reader</span><span class="p">=@</span><span class="n">read_cosmo_ds_header</span><span class="p">;</span>
    <span class="n">img_formats</span><span class="p">.</span><span class="n">cosmo_fmri_ds</span><span class="p">.</span><span class="n">header_converter</span><span class="p">=@</span><span class="n">convert_cosmo_ds_header</span><span class="p">;</span>
    <span class="n">img_formats</span><span class="p">.</span><span class="n">cosmo_fmri_ds</span><span class="p">.</span><span class="n">data_converter</span><span class="p">=@</span><span class="n">convert_cosmo_ds_data</span><span class="p">;</span>
    <span class="n">img_formats</span><span class="p">.</span><span class="n">cosmo_fmri_ds</span><span class="p">.</span><span class="n">convert_volume</span><span class="p">=</span><span class="n">false</span><span class="p">;</span> <span class="c">% already dataset</span>


<span class="c">%%%%%%%%%%%%%%%%%%%%%%%%</span>
<span class="c">% General</span>

<span class="k">function</span><span class="w"> </span>data<span class="p">=</span><span class="nf">slice_4d</span><span class="p">(</span>data, volumes<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">data_size</span><span class="p">=</span><span class="nb">size</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
    <span class="n">ndim</span><span class="p">=</span><span class="nb">numel</span><span class="p">(</span><span class="n">data_size</span><span class="p">);</span>
    <span class="k">if</span> <span class="n">ndim</span><span class="o">&gt;</span><span class="mi">4</span>
        <span class="c">% Could be the AFNI NIFTI conversion syndrome, where the 4th</span>
        <span class="c">% dimension is singleton and the fifth one contains the data.</span>
        <span class="c">% Such data is accepted and treated as if the fifth dimension is</span>
        <span class="c">% the fourth one.</span>
        <span class="n">time_size</span><span class="p">=</span><span class="n">data_size</span><span class="p">(</span><span class="mi">4</span><span class="p">:</span><span class="k">end</span><span class="p">);</span>
        <span class="k">if</span> <span class="n">sum</span><span class="p">(</span><span class="n">time_size</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span>
            <span class="n">error</span><span class="p">([</span><span class="s">&#39;More than one singleton dimension found in &#39;</span><span class="c">...</span>
                        <span class="s">&#39;time dimension; this is currently not &#39;</span><span class="c">...</span>
                        <span class="s">&#39;supported. If you want to be able &#39;</span><span class="c">...</span>
                        <span class="s">&#39;to load such data, please get in touch &#39;</span><span class="c">...</span>
                        <span class="s">&#39;with the CoSMoMVPA developers&#39;</span><span class="p">]);</span>
        <span class="k">end</span>

        <span class="n">ntime</span><span class="p">=</span><span class="n">prod</span><span class="p">(</span><span class="n">time_size</span><span class="p">);</span>
        <span class="n">data</span><span class="p">=</span><span class="nb">reshape</span><span class="p">(</span><span class="n">data</span><span class="p">,[</span><span class="n">data_size</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">),</span><span class="n">ntime</span><span class="p">]);</span>
    <span class="k">end</span>

    <span class="k">if</span> <span class="o">~</span><span class="nb">isempty</span><span class="p">(</span><span class="n">volumes</span><span class="p">)</span>
        <span class="n">data</span><span class="p">=</span><span class="n">data</span><span class="p">(:,:,:,</span><span class="n">volumes</span><span class="p">);</span>
    <span class="k">end</span>

    <span class="k">if</span> <span class="o">~</span><span class="n">isa</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="s">&#39;double&#39;</span><span class="p">)</span>
        <span class="n">data</span><span class="p">=</span><span class="n">double</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
    <span class="k">end</span>


<span class="k">function</span><span class="w"> </span>ds<span class="p">=</span><span class="nf">slice_dataset_volumes</span><span class="p">(</span>ds, volumes<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span> <span class="o">~</span><span class="nb">isempty</span><span class="p">(</span><span class="n">volumes</span><span class="p">)</span>
        <span class="n">ds</span><span class="p">=</span><span class="n">cosmo_slice</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span><span class="n">volumes</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">end</span>

<span class="k">function</span><span class="w"> </span><span class="nf">require_singleton_volume</span><span class="p">(</span>volumes<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span> <span class="o">~</span><span class="nb">isequal</span><span class="p">(</span><span class="n">volumes</span><span class="p">,[])</span> <span class="o">&amp;&amp;</span> <span class="o">~</span><span class="nb">isequal</span><span class="p">(</span><span class="n">volumes</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">error</span><span class="p">(</span><span class="s">&#39;Only a single volume is supported for this data format&#39;</span><span class="p">);</span>
    <span class="k">end</span>

<span class="k">function</span><span class="w"> </span>hdr<span class="p">=</span><span class="nf">get_and_check_data</span><span class="p">(</span>hdr, loader_func, check_func, varargin<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="c">% is hdr is a char, load it using loader with optional arguments</span>
    <span class="c">% from varargin</span>
    <span class="c">% For other input, the input is returned.</span>
    <span class="c">%</span>
    <span class="c">% in any case the output is checked using check_func.</span>
    <span class="k">if</span> <span class="n">ischar</span><span class="p">(</span><span class="n">hdr</span><span class="p">)</span>
        <span class="n">hdr</span><span class="p">=</span><span class="n">loader_func</span><span class="p">(</span><span class="n">hdr</span><span class="p">,</span> <span class="n">varargin</span><span class="p">{:});</span>
    <span class="k">end</span>
    <span class="k">if</span> <span class="o">~</span><span class="n">check_func</span><span class="p">(</span><span class="n">hdr</span><span class="p">)</span>
        <span class="n">error</span><span class="p">(</span><span class="s">&#39;Illegal input of type %s - failed to pass %s&#39;</span><span class="p">,</span><span class="c">...</span>
                    <span class="n">class</span><span class="p">(</span><span class="n">hdr</span><span class="p">),</span> <span class="n">func2str</span><span class="p">(</span><span class="n">check_func</span><span class="p">));</span>
    <span class="k">end</span>


<span class="c">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
<span class="c">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
<span class="c">%</span>
<span class="c">% format-specific helper functions</span>
<span class="c">%</span>
<span class="c">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
<span class="c">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>


<span class="c">%%%%%%%%%%%%%%%%%%%%%%%%</span>
<span class="c">% NIfTI</span>
<span class="c">%%%%%%%%%%%%%%%%%%%%%%%%</span>

<span class="c">% helpers</span>
<span class="k">function</span><span class="w"> </span>[mx, xform]<span class="p">=</span><span class="nf">get_nifti_transform</span><span class="p">(</span>hdr, varargin<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="c">% Get LPI affine transformation from NIfTI file</span>
    <span class="c">%</span>
    <span class="c">% Input:</span>
    <span class="c">%   fn          nifti filename</span>
    <span class="c">%</span>
    <span class="c">% Output:</span>
    <span class="c">%   mx          4x4 affine transformation matrix from voxel to world</span>
    <span class="c">%               coordinates. voxel indices as base0, not base1 as in</span>
    <span class="c">%               CoSMoMVPA</span>
    <span class="c">%   xform       string with xform based on sform or qform code</span>
    <span class="c">%</span>
    <span class="c">% Notes:</span>
    <span class="c">%  - this function is experimental</span>
    <span class="c">%  - initial testing suggests agreement with MRIcron (thanks to Chris</span>
    <span class="c">%    Rorden for providing this software)</span>
    <span class="c">%  - functionality in the subfunctions are based on nftii1_io.h in</span>
    <span class="c">%    AFNI, written Robert W Cox (2003), public domain dedication;</span>
    <span class="c">%    http://nifti.nimh.nih.gov/pub/dist/src/niftilib/nifti1_io.c</span>
    <span class="c">%  - to convert voxel coordinates (i,j,k) to (x,y,z), compute</span>
    <span class="c">%    lpi_mx*[x y z 1]&#39;. For the reverse, compute inv(lpi_mx)*[i j k 1]&#39;</span>
    <span class="c">%</span>
    <span class="c">% NNO Dec 2014</span>

    <span class="n">defaults</span><span class="p">.</span><span class="n">nifti_form</span><span class="p">=[];</span>
    <span class="n">opt</span><span class="p">=</span><span class="n">cosmo_structjoin</span><span class="p">(</span><span class="n">defaults</span><span class="p">,</span><span class="n">varargin</span><span class="p">);</span>

    <span class="k">if</span> <span class="nb">isempty</span><span class="p">(</span><span class="n">opt</span><span class="p">.</span><span class="n">nifti_form</span><span class="p">)</span>
        <span class="p">[</span><span class="n">mx</span><span class="p">,</span> <span class="n">nifti_form</span><span class="p">]=</span><span class="n">nifti_matrix_from_auto</span><span class="p">(</span><span class="n">hdr</span><span class="p">);</span>
    <span class="k">else</span>
        <span class="p">[</span><span class="n">mx</span><span class="p">,</span> <span class="n">nifti_form</span><span class="p">]=</span><span class="n">nifti_matrix_using_method</span><span class="p">(</span><span class="n">hdr</span><span class="p">,</span><span class="n">opt</span><span class="p">.</span><span class="n">nifti_form</span><span class="p">);</span>
    <span class="k">end</span>

    <span class="c">% prioritize sformch</span>
    <span class="k">switch</span> <span class="n">nifti_form</span>
        <span class="k">case</span> <span class="s">&#39;sform&#39;</span>
            <span class="n">key</span><span class="p">=</span><span class="n">hdr</span><span class="p">.</span><span class="n">hist</span><span class="p">.</span><span class="n">sform_code</span><span class="p">;</span>
        <span class="k">case</span> <span class="s">&#39;qform&#39;</span>
            <span class="n">key</span><span class="p">=</span><span class="n">hdr</span><span class="p">.</span><span class="n">hist</span><span class="p">.</span><span class="n">qform_code</span><span class="p">;</span>
        <span class="k">otherwise</span>
            <span class="n">key</span><span class="p">=</span><span class="mi">0</span><span class="p">;</span>
    <span class="k">end</span>

    <span class="n">xform</span><span class="p">=</span><span class="n">cosmo_fmri_convert_xform</span><span class="p">(</span><span class="s">&#39;nii&#39;</span><span class="p">,</span><span class="n">key</span><span class="p">);</span>


<span class="k">function</span><span class="w"> </span>[mx, nifti_form]<span class="p">=</span><span class="nf">nifti_matrix_from_auto</span><span class="p">(</span>hdr<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="c">% get matrix automatically, assumes that qform and sform (if present)</span>
    <span class="c">% are identical</span>
    <span class="n">max_delta_s_and_q</span><span class="p">=</span><span class="mf">1e-3</span><span class="p">;</span> <span class="c">% maximum allowed difference between s and q</span>

    <span class="n">has_sform</span><span class="p">=</span><span class="n">hdr</span><span class="p">.</span><span class="n">hist</span><span class="p">.</span><span class="n">sform_code</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">;</span>
    <span class="n">has_qform</span><span class="p">=</span><span class="n">hdr</span><span class="p">.</span><span class="n">hist</span><span class="p">.</span><span class="n">qform_code</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">;</span>

    <span class="k">if</span> <span class="n">has_sform</span><span class="p">;</span>
        <span class="n">nifti_form</span><span class="p">=</span><span class="s">&#39;sform&#39;</span><span class="p">;</span>
    <span class="k">elseif</span> <span class="n">has_qform</span>
        <span class="n">nifti_form</span><span class="p">=</span><span class="s">&#39;qform&#39;</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="n">nifti_form</span><span class="p">=</span><span class="s">&#39;pixdim&#39;</span><span class="p">;</span>
    <span class="k">end</span>

    <span class="n">mx</span><span class="p">=</span><span class="n">nifti_matrix_using_method</span><span class="p">(</span><span class="n">hdr</span><span class="p">,</span><span class="n">nifti_form</span><span class="p">);</span>

    <span class="k">if</span> <span class="n">has_sform</span> <span class="o">&amp;&amp;</span> <span class="n">has_qform</span>
        <span class="n">mx_q</span><span class="p">=</span><span class="n">nifti_matrix_using_method</span><span class="p">(</span><span class="n">hdr</span><span class="p">,</span><span class="s">&#39;qform&#39;</span><span class="p">);</span>

        <span class="n">max_diff</span><span class="p">=</span><span class="n">max</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">mx</span><span class="p">(:)</span><span class="o">-</span><span class="n">mx_q</span><span class="p">(:)));</span>
        <span class="k">if</span> <span class="n">max_diff</span><span class="o">&gt;</span><span class="n">max_delta_s_and_q</span>
            <span class="n">str_mx</span><span class="p">=</span><span class="n">matrix2string</span><span class="p">(</span><span class="n">mx</span><span class="p">);</span>
            <span class="n">str_mx_s</span><span class="p">=</span><span class="n">matrix2string</span><span class="p">(</span><span class="n">mx_q</span><span class="p">);</span>
            <span class="n">url</span><span class="p">=[</span><span class="s">&#39;http://nifti.nimh.nih.gov/nifti-1/documentation/&#39;</span><span class="c">...</span>
                    <span class="s">&#39;nifti1fields/nifti1fields_pages/qsform.html&#39;</span><span class="p">];</span>
            <span class="n">error</span><span class="p">([</span><span class="s">&#39;the affine matrices mapping voxel-to-world &#39;</span><span class="c">...</span>
                    <span class="s">&#39;coordinates according to the sform and qform &#39;</span><span class="c">...</span>
                    <span class="s">&#39;in the NIfTI header differ &#39;</span><span class="c">...</span>
                    <span class="s">&#39;by %d, exceeding the treshold %d.\n\n&#39;</span><span class="c">...</span>
                    <span class="s">&#39;The sform matrix is:\n\n%s\n\n&#39;</span><span class="p">,</span><span class="c">...</span>
                    <span class="s">&#39;The qform matrix is:\n\n%s\n\n&#39;</span><span class="c">...</span>
                    <span class="s">&#39;To resolve this, set the &#39;&#39;nifti_form&#39;&#39; &#39;</span><span class="c">...</span>
                    <span class="s">&#39;option to either:\n&#39;</span><span class="c">...</span>
                    <span class="s">&#39;  &#39;&#39;pixdim&#39;&#39; (method 1), or\n&#39;</span><span class="c">...</span>
                    <span class="s">&#39;  &#39;&#39;qform&#39;&#39;  (method 2), or\n&#39;</span><span class="c">...</span>
                    <span class="s">&#39;  &#39;&#39;sform&#39;&#39;  (method 3).\n\n&#39;</span><span class="c">...</span>
                    <span class="s">&#39;For more information, see:\n  %s\n\n&#39;</span><span class="p">,</span><span class="c">...</span>
                    <span class="s">&#39;If you have absolutely no idea what to use, &#39;</span><span class="c">...</span>
                    <span class="s">&#39;try &#39;&#39;sform&#39;&#39;\n\n&#39;</span><span class="p">],</span><span class="c">...</span>
                    <span class="n">max_diff</span><span class="p">,</span> <span class="n">max_delta_s_and_q</span><span class="p">,</span><span class="c">...</span>
                    <span class="n">str_mx_s</span><span class="p">,</span> <span class="n">str_mx</span><span class="p">,</span> <span class="n">url</span><span class="p">);</span>
        <span class="k">end</span>
    <span class="k">end</span>

<span class="k">function</span><span class="w"> </span>s<span class="p">=</span><span class="nf">matrix2string</span><span class="p">(</span>mx<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">float_pat</span><span class="p">=</span><span class="s">&#39;%6.3f&#39;</span><span class="p">;</span>
    <span class="n">line_pat</span><span class="p">=</span><span class="nb">repmat</span><span class="p">([</span><span class="n">float_pat</span> <span class="s">&#39; &#39;</span><span class="p">],</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">);</span>
    <span class="n">line_pat</span><span class="p">(</span><span class="k">end</span><span class="p">)=</span><span class="n">sprintf</span><span class="p">(</span><span class="s">&#39;\n&#39;</span><span class="p">);</span>
    <span class="n">mx_pat</span><span class="p">=</span><span class="nb">repmat</span><span class="p">(</span><span class="n">line_pat</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span>
    <span class="n">mx_3x4</span><span class="p">=</span><span class="n">mx</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">);</span>
    <span class="n">s</span><span class="p">=</span><span class="n">sprintf</span><span class="p">(</span><span class="n">mx_pat</span><span class="p">,</span><span class="n">mx_3x4</span><span class="o">&#39;</span><span class="p">);</span>



<span class="k">function</span><span class="w"> </span>[mx, method]<span class="p">=</span><span class="nf">nifti_matrix_using_method</span><span class="p">(</span>hdr, method<span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="k">switch</span> <span class="n">method</span>
        <span class="k">case</span> <span class="s">&#39;pixdim&#39;</span>
            <span class="n">mx</span><span class="p">=</span><span class="n">nifti_matrix_from_pixdim</span><span class="p">(</span><span class="n">hdr</span><span class="p">);</span>
        <span class="k">case</span> <span class="s">&#39;qform&#39;</span>
            <span class="n">mx</span><span class="p">=</span><span class="n">nifti_matrix_from_qform</span><span class="p">(</span><span class="n">hdr</span><span class="p">);</span>
        <span class="k">case</span> <span class="s">&#39;sform&#39;</span>
            <span class="n">mx</span><span class="p">=</span><span class="n">nifti_matrix_from_sform</span><span class="p">(</span><span class="n">hdr</span><span class="p">);</span>
        <span class="k">otherwise</span>
            <span class="n">error</span><span class="p">(</span><span class="s">&#39;illegal method %s&#39;</span><span class="p">,</span> <span class="n">method</span><span class="p">);</span>
    <span class="k">end</span>

    <span class="n">assert</span><span class="p">(</span><span class="nb">isequal</span><span class="p">(</span><span class="nb">size</span><span class="p">(</span><span class="n">mx</span><span class="p">),[</span><span class="mi">4</span> <span class="mi">4</span><span class="p">]));</span>

<span class="k">function</span><span class="w"> </span>mx<span class="p">=</span><span class="nf">nifti_matrix_from_pixdim</span><span class="p">(</span>hdr<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">mx</span><span class="p">=[[</span><span class="nb">diag</span><span class="p">(</span><span class="n">hdr</span><span class="p">.</span><span class="n">dime</span><span class="p">.</span><span class="n">pixdim</span><span class="p">(</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">));</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">]</span> <span class="p">[</span><span class="mi">0</span><span class="p">;</span><span class="mi">0</span><span class="p">;</span><span class="mi">0</span><span class="p">;</span><span class="mi">1</span><span class="p">]];</span>


<span class="k">function</span><span class="w"> </span>mx<span class="p">=</span><span class="nf">nifti_matrix_from_qform</span><span class="p">(</span>hdr<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="c">% convert quaternion to affine matrix</span>
    <span class="c">%</span>
    <span class="c">% based on &quot;quatern_to_mat44&quot; in nifti1_io.c by Robert W. Cox, 2003,</span>
    <span class="c">% which he dedicated to the public domain.</span>
    <span class="c">%</span>
    <span class="c">% http://nifti.nimh.nih.gov/pub/dist/src/niftilib/nifti1_io.c</span>
    <span class="n">qfac</span><span class="p">=</span><span class="n">hdr</span><span class="p">.</span><span class="n">dime</span><span class="p">.</span><span class="n">pixdim</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">dx</span><span class="p">=</span><span class="n">hdr</span><span class="p">.</span><span class="n">dime</span><span class="p">.</span><span class="n">pixdim</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="n">dy</span><span class="p">=</span><span class="n">hdr</span><span class="p">.</span><span class="n">dime</span><span class="p">.</span><span class="n">pixdim</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
    <span class="n">dz</span><span class="p">=</span><span class="n">hdr</span><span class="p">.</span><span class="n">dime</span><span class="p">.</span><span class="n">pixdim</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
    <span class="n">qb</span><span class="p">=</span><span class="n">hdr</span><span class="p">.</span><span class="n">hist</span><span class="p">.</span><span class="n">quatern_b</span><span class="p">;</span>
    <span class="n">qc</span><span class="p">=</span><span class="n">hdr</span><span class="p">.</span><span class="n">hist</span><span class="p">.</span><span class="n">quatern_c</span><span class="p">;</span>
    <span class="n">qd</span><span class="p">=</span><span class="n">hdr</span><span class="p">.</span><span class="n">hist</span><span class="p">.</span><span class="n">quatern_d</span><span class="p">;</span>
    <span class="n">qx</span><span class="p">=</span><span class="n">hdr</span><span class="p">.</span><span class="n">hist</span><span class="p">.</span><span class="n">qoffset_x</span><span class="p">;</span>
    <span class="n">qy</span><span class="p">=</span><span class="n">hdr</span><span class="p">.</span><span class="n">hist</span><span class="p">.</span><span class="n">qoffset_y</span><span class="p">;</span>
    <span class="n">qz</span><span class="p">=</span><span class="n">hdr</span><span class="p">.</span><span class="n">hist</span><span class="p">.</span><span class="n">qoffset_z</span><span class="p">;</span>

    <span class="c">% ported from MRIcron</span>
    <span class="n">b</span><span class="p">=</span><span class="n">qb</span><span class="p">;</span>
    <span class="n">c</span><span class="p">=</span><span class="n">qc</span><span class="p">;</span>
    <span class="n">d</span><span class="p">=</span><span class="n">qd</span><span class="p">;</span>
    <span class="n">a</span><span class="p">=</span><span class="mi">1</span><span class="o">-</span><span class="p">(</span><span class="n">b</span>^<span class="mi">2</span><span class="o">+</span><span class="n">c</span>^<span class="mi">2</span><span class="o">+</span><span class="n">d</span>^<span class="mi">2</span><span class="p">);</span>

    <span class="k">if</span> <span class="n">a</span><span class="o">&lt;</span><span class="mf">1e-7</span>
        <span class="n">a</span><span class="p">=</span><span class="mi">1</span><span class="o">/</span><span class="nb">sqrt</span><span class="p">(</span><span class="n">b</span>^<span class="mi">2</span><span class="o">+</span><span class="n">c</span>^<span class="mi">2</span><span class="o">+</span><span class="n">d</span>^<span class="mi">2</span><span class="p">);</span>
        <span class="n">b</span><span class="p">=</span><span class="n">b</span><span class="o">*</span><span class="n">a</span><span class="p">;</span>
        <span class="n">c</span><span class="p">=</span><span class="n">c</span><span class="o">*</span><span class="n">a</span><span class="p">;</span>
        <span class="n">d</span><span class="p">=</span><span class="n">d</span><span class="o">*</span><span class="n">a</span><span class="p">;</span>
        <span class="n">a</span><span class="p">=</span><span class="mi">0</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="n">a</span><span class="p">=</span><span class="nb">sqrt</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
    <span class="k">end</span>

    <span class="k">if</span> <span class="n">dx</span><span class="o">&gt;</span><span class="mi">0</span>
        <span class="n">xd</span><span class="p">=</span><span class="n">dx</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="n">xd</span><span class="p">=</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">end</span>

    <span class="k">if</span> <span class="n">dy</span><span class="o">&gt;</span><span class="mi">0</span>
        <span class="n">yd</span><span class="p">=</span><span class="n">dy</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="n">yd</span><span class="p">=</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">end</span>

    <span class="k">if</span> <span class="n">dz</span><span class="o">&gt;</span><span class="mi">0</span>
        <span class="n">zd</span><span class="p">=</span><span class="n">dz</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="n">zd</span><span class="p">=</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">end</span>

    <span class="k">if</span> <span class="n">qfac</span><span class="o">&lt;</span><span class="mi">0</span>
        <span class="n">zd</span><span class="p">=</span><span class="o">-</span><span class="n">zd</span><span class="p">;</span>
    <span class="k">end</span>

    <span class="c">% construct affine matrix</span>
    <span class="n">mx</span><span class="p">=</span><span class="nb">zeros</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">);</span>
    <span class="n">mx</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)=</span>     <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="o">*</span><span class="n">b</span><span class="o">-</span><span class="n">c</span><span class="o">*</span><span class="n">c</span><span class="o">-</span><span class="n">d</span><span class="o">*</span><span class="n">d</span><span class="p">)</span> <span class="o">*</span> <span class="n">xd</span> <span class="p">;</span>
    <span class="n">mx</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">b</span><span class="o">*</span><span class="n">c</span><span class="o">-</span><span class="n">a</span><span class="o">*</span><span class="n">d</span>        <span class="p">)</span> <span class="o">*</span> <span class="n">yd</span> <span class="p">;</span>
    <span class="n">mx</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">b</span><span class="o">*</span><span class="n">d</span><span class="o">+</span><span class="n">a</span><span class="o">*</span><span class="n">c</span>        <span class="p">)</span> <span class="o">*</span> <span class="n">zd</span> <span class="p">;</span>
    <span class="n">mx</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">b</span><span class="o">*</span><span class="n">c</span><span class="o">+</span><span class="n">a</span><span class="o">*</span><span class="n">d</span>        <span class="p">)</span> <span class="o">*</span> <span class="n">xd</span> <span class="p">;</span>
    <span class="n">mx</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)=</span>     <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">a</span><span class="o">+</span><span class="n">c</span><span class="o">*</span><span class="n">c</span><span class="o">-</span><span class="n">b</span><span class="o">*</span><span class="n">b</span><span class="o">-</span><span class="n">d</span><span class="o">*</span><span class="n">d</span><span class="p">)</span> <span class="o">*</span> <span class="n">yd</span> <span class="p">;</span>
    <span class="n">mx</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">c</span><span class="o">*</span><span class="n">d</span><span class="o">-</span><span class="n">a</span><span class="o">*</span><span class="n">b</span>        <span class="p">)</span> <span class="o">*</span> <span class="n">zd</span> <span class="p">;</span>
    <span class="n">mx</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">)=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">b</span><span class="o">*</span><span class="n">d</span><span class="o">-</span><span class="n">a</span><span class="o">*</span><span class="n">c</span>        <span class="p">)</span> <span class="o">*</span> <span class="n">xd</span> <span class="p">;</span>
    <span class="n">mx</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">)=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">c</span><span class="o">*</span><span class="n">d</span><span class="o">+</span><span class="n">a</span><span class="o">*</span><span class="n">b</span>        <span class="p">)</span> <span class="o">*</span> <span class="n">yd</span> <span class="p">;</span>
    <span class="n">mx</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)=</span>     <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">a</span><span class="o">+</span><span class="n">d</span><span class="o">*</span><span class="n">d</span><span class="o">-</span><span class="n">c</span><span class="o">*</span><span class="n">c</span><span class="o">-</span><span class="n">b</span><span class="o">*</span><span class="n">b</span><span class="p">)</span> <span class="o">*</span> <span class="n">zd</span> <span class="p">;</span>
    <span class="n">mx</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">)=</span><span class="n">qx</span><span class="p">;</span>
    <span class="n">mx</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">)=</span><span class="n">qy</span><span class="p">;</span>
    <span class="n">mx</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)=</span><span class="n">qz</span><span class="p">;</span>
    <span class="n">mx</span><span class="p">(</span><span class="mi">4</span><span class="p">,:)=[</span><span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span><span class="p">];</span>

<span class="k">function</span><span class="w"> </span>mx<span class="p">=</span><span class="nf">nifti_matrix_from_sform</span><span class="p">(</span>hdr<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="c">% set the srow values</span>
    <span class="n">mx</span><span class="p">=[</span><span class="n">hdr</span><span class="p">.</span><span class="n">hist</span><span class="p">.</span><span class="n">srow_x</span><span class="p">;</span><span class="c">...</span>
        <span class="n">hdr</span><span class="p">.</span><span class="n">hist</span><span class="p">.</span><span class="n">srow_y</span><span class="p">;</span><span class="c">...</span>
        <span class="n">hdr</span><span class="p">.</span><span class="n">hist</span><span class="p">.</span><span class="n">srow_z</span><span class="p">;</span><span class="c">...</span>
        <span class="p">[</span><span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span><span class="p">]];</span>

<span class="k">function</span><span class="w"> </span>scaling<span class="p">=</span><span class="nf">nifti_get_scaling_factor</span><span class="p">(</span>hdr<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="c">% get scaling factor, if present for this dataset</span>
    <span class="c">% scaling=[intercept slope] if present, otherwise []</span>
    <span class="n">is_datatype</span><span class="p">=</span><span class="n">any</span><span class="p">(</span><span class="n">hdr</span><span class="p">.</span><span class="n">dime</span><span class="p">.</span><span class="n">datatype</span><span class="o">==</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">64</span><span class="p">,</span><span class="mi">256</span><span class="p">,</span><span class="mi">512</span><span class="p">,</span><span class="mi">768</span><span class="p">]);</span>
    <span class="n">is_nonidentity</span><span class="p">=</span><span class="n">hdr</span><span class="p">.</span><span class="n">dime</span><span class="p">.</span><span class="n">scl_inter</span><span class="o">~=</span><span class="mi">0</span> <span class="o">||</span> <span class="n">hdr</span><span class="p">.</span><span class="n">dime</span><span class="p">.</span><span class="n">scl_slope</span><span class="o">~=</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">is_nonzero</span><span class="p">=</span><span class="n">hdr</span><span class="p">.</span><span class="n">dime</span><span class="p">.</span><span class="n">scl_slope</span><span class="o">~=</span><span class="mi">0</span><span class="p">;</span>

    <span class="k">if</span> <span class="n">is_datatype</span> <span class="o">&amp;&amp;</span> <span class="n">is_nonidentity</span> <span class="o">&amp;&amp;</span> <span class="n">is_nonzero</span>
        <span class="n">scaling</span><span class="p">=[</span><span class="n">hdr</span><span class="p">.</span><span class="n">dime</span><span class="p">.</span><span class="n">scl_inter</span> <span class="n">hdr</span><span class="p">.</span><span class="n">dime</span><span class="p">.</span><span class="n">scl_slope</span><span class="p">];</span>
    <span class="k">else</span>
        <span class="n">scaling</span><span class="p">=[];</span>
    <span class="k">end</span>



<span class="c">% NIfTI input</span>
<span class="c">% -----------</span>
<span class="k">function</span><span class="w"> </span>b<span class="p">=</span><span class="nf">isa_nii</span><span class="p">(</span>hdr<span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="n">b</span><span class="p">=</span><span class="n">isstruct</span><span class="p">(</span><span class="n">hdr</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">isfield</span><span class="p">(</span><span class="n">hdr</span><span class="p">,</span><span class="s">&#39;img&#39;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">isnumeric</span><span class="p">(</span><span class="n">hdr</span><span class="p">.</span><span class="n">img</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="c">...</span>
            <span class="n">isfield</span><span class="p">(</span><span class="n">hdr</span><span class="p">,</span><span class="s">&#39;hdr&#39;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">isfield</span><span class="p">(</span><span class="n">hdr</span><span class="p">.</span><span class="n">hdr</span><span class="p">,</span><span class="s">&#39;dime&#39;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="c">...</span>
            <span class="n">isfield</span><span class="p">(</span><span class="n">hdr</span><span class="p">.</span><span class="n">hdr</span><span class="p">.</span><span class="n">dime</span><span class="p">,</span><span class="s">&#39;dim&#39;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">isnumeric</span><span class="p">(</span><span class="n">hdr</span><span class="p">.</span><span class="n">hdr</span><span class="p">.</span><span class="n">dime</span><span class="p">.</span><span class="n">dim</span><span class="p">);</span>


<span class="k">function</span><span class="w"> </span>nii<span class="p">=</span><span class="nf">read_nii_header</span><span class="p">(</span>fn<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">nii</span><span class="p">.</span><span class="n">hdr</span><span class="p">=</span><span class="n">load_untouch_header_only</span><span class="p">(</span><span class="n">fn</span><span class="p">);</span>


<span class="k">function</span><span class="w"> </span>[hdr_ds,nsamples]<span class="p">=</span><span class="nf">convert_nii_header</span><span class="p">(</span>nii, params<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">hdr</span><span class="p">=</span><span class="n">nii</span><span class="p">.</span><span class="n">hdr</span><span class="p">;</span>
    <span class="n">dim</span><span class="p">=</span><span class="n">hdr</span><span class="p">.</span><span class="n">dime</span><span class="p">.</span><span class="n">dim</span><span class="p">(</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">);</span>

    <span class="c">% get original affine matrix</span>
    <span class="p">[</span><span class="n">mat</span><span class="p">,</span> <span class="n">xform</span><span class="p">]=</span><span class="n">get_nifti_transform</span><span class="p">(</span><span class="n">hdr</span><span class="p">,</span> <span class="n">params</span><span class="p">);</span>

    <span class="c">% make matrix base1 friendly</span>
    <span class="n">mat</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)=</span><span class="n">mat</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span><span class="o">+</span><span class="n">mat</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span> <span class="o">-</span><span class="mi">1</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">&#39;</span><span class="p">;</span>

    <span class="n">vol</span><span class="p">=</span><span class="n">struct</span><span class="p">();</span>
    <span class="n">vol</span><span class="p">.</span><span class="n">mat</span><span class="p">=</span><span class="n">mat</span><span class="p">;</span>
    <span class="n">vol</span><span class="p">.</span><span class="n">xform</span><span class="p">=</span><span class="n">xform</span><span class="p">;</span>
    <span class="n">vol</span><span class="p">.</span><span class="n">dim</span><span class="p">=</span><span class="n">dim</span><span class="p">;</span>
    <span class="n">sa</span><span class="p">=</span><span class="n">struct</span><span class="p">();</span>
    <span class="n">nsamples</span><span class="p">=</span><span class="n">hdr</span><span class="p">.</span><span class="n">dime</span><span class="p">.</span><span class="n">dim</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>

    <span class="n">hdr_ds</span><span class="p">=</span><span class="n">struct</span><span class="p">();</span>
    <span class="n">hdr_ds</span><span class="p">.</span><span class="n">a</span><span class="p">.</span><span class="n">vol</span><span class="p">=</span><span class="n">vol</span><span class="p">;</span>
    <span class="n">hdr_ds</span><span class="p">.</span><span class="n">sa</span><span class="p">=</span><span class="n">sa</span><span class="p">;</span>

<span class="k">function</span><span class="w"> </span>nii<span class="p">=</span><span class="nf">read_nii_data</span><span class="p">(</span>fn, hdr_from_nii, volumes<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="c">% get original header</span>
    <span class="n">hdr</span><span class="p">=</span><span class="n">hdr_from_nii</span><span class="p">.</span><span class="n">hdr</span><span class="p">;</span>

    <span class="c">% load the data</span>
    <span class="n">nii</span><span class="p">=</span><span class="n">load_untouch_nii</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">volumes</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="nb">isequal</span><span class="p">(</span><span class="n">hdr</span><span class="p">.</span><span class="n">dime</span><span class="p">.</span><span class="n">dim</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">),</span><span class="n">nii</span><span class="p">.</span><span class="n">hdr</span><span class="p">.</span><span class="n">dime</span><span class="p">.</span><span class="n">dim</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">)));</span>

    <span class="n">hdr</span><span class="p">.</span><span class="n">dime</span><span class="p">.</span><span class="n">dim</span><span class="p">=</span><span class="n">nii</span><span class="p">.</span><span class="n">hdr</span><span class="p">.</span><span class="n">dime</span><span class="p">.</span><span class="n">dim</span><span class="p">;</span>
    <span class="n">hdr</span><span class="p">.</span><span class="n">dime</span><span class="p">.</span><span class="n">glmax</span><span class="p">=</span><span class="n">nii</span><span class="p">.</span><span class="n">hdr</span><span class="p">.</span><span class="n">dime</span><span class="p">.</span><span class="n">glmax</span><span class="p">;</span>
    <span class="n">hdr</span><span class="p">.</span><span class="n">dime</span><span class="p">.</span><span class="n">glmin</span><span class="p">=</span><span class="n">nii</span><span class="p">.</span><span class="n">hdr</span><span class="p">.</span><span class="n">dime</span><span class="p">.</span><span class="n">glmin</span><span class="p">;</span>
    <span class="n">assert</span><span class="p">(</span><span class="nb">isequal</span><span class="p">(</span><span class="n">hdr</span><span class="p">,</span><span class="n">nii</span><span class="p">.</span><span class="n">hdr</span><span class="p">));</span>


<span class="k">function</span><span class="w"> </span>data<span class="p">=</span><span class="nf">convert_nii_data</span><span class="p">(</span>nii, volumes<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="c">% get scaling factor</span>
    <span class="n">scaling</span><span class="p">=</span><span class="n">nifti_get_scaling_factor</span><span class="p">(</span><span class="n">nii</span><span class="p">.</span><span class="n">hdr</span><span class="p">);</span>

    <span class="n">data</span><span class="p">=</span><span class="n">slice_4d</span><span class="p">(</span><span class="n">nii</span><span class="p">.</span><span class="n">img</span><span class="p">,</span> <span class="n">volumes</span><span class="p">);</span>

    <span class="c">% apply scaling</span>
    <span class="k">if</span> <span class="o">~</span><span class="nb">isempty</span><span class="p">(</span><span class="n">scaling</span><span class="p">)</span>
        <span class="n">data</span><span class="p">(:)=</span><span class="n">scaling</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">scaling</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">data</span><span class="p">;</span>
    <span class="k">end</span>


<span class="c">%%%%%%%%%%%%%%%%%%%%%%%%</span>
<span class="c">% AFNI</span>
<span class="c">%%%%%%%%%%%%%%%%%%%%%%%%</span>

<span class="c">% helpers</span>
<span class="k">function</span><span class="w"> </span>vol<span class="p">=</span><span class="nf">get_vol_afni</span><span class="p">(</span>hdr<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="c">% afni volume info</span>
    <span class="n">orient</span><span class="p">=</span><span class="s">&#39;LPI&#39;</span><span class="p">;</span> <span class="c">% always return LPI-based matrix</span>

    <span class="c">% origin and basis vectors in world space</span>
    <span class="n">k</span><span class="p">=[</span><span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">;</span><span class="nb">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)];</span>

    <span class="p">[</span><span class="n">unused</span><span class="p">,</span><span class="nb">i</span><span class="p">]=</span><span class="n">AFNI_Index2XYZcontinuous</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">hdr</span><span class="p">,</span><span class="n">orient</span><span class="p">);</span>

    <span class="c">% basis vectors in voxel space</span>
    <span class="n">e1</span><span class="p">=</span><span class="nb">i</span><span class="p">(</span><span class="mi">2</span><span class="p">,:)</span><span class="o">-</span><span class="nb">i</span><span class="p">(</span><span class="mi">1</span><span class="p">,:);</span>
    <span class="n">e2</span><span class="p">=</span><span class="nb">i</span><span class="p">(</span><span class="mi">3</span><span class="p">,:)</span><span class="o">-</span><span class="nb">i</span><span class="p">(</span><span class="mi">1</span><span class="p">,:);</span>
    <span class="n">e3</span><span class="p">=</span><span class="nb">i</span><span class="p">(</span><span class="mi">4</span><span class="p">,:)</span><span class="o">-</span><span class="nb">i</span><span class="p">(</span><span class="mi">1</span><span class="p">,:);</span>

    <span class="c">% change from base0 (afni) to base1 (SPM/Matlab)</span>
    <span class="n">o</span><span class="p">=</span><span class="nb">i</span><span class="p">(</span><span class="mi">1</span><span class="p">,:)</span><span class="o">-</span><span class="p">(</span><span class="n">e1</span><span class="o">+</span><span class="n">e2</span><span class="o">+</span><span class="n">e3</span><span class="p">);</span>

    <span class="c">% create matrix</span>
    <span class="n">mat</span><span class="p">=[</span><span class="n">e1</span><span class="p">;</span><span class="n">e2</span><span class="p">;</span><span class="n">e3</span><span class="p">;</span><span class="n">o</span><span class="p">]</span><span class="o">&#39;</span><span class="p">;</span>

    <span class="c">% set 4th row</span>
    <span class="n">mat</span><span class="p">(</span><span class="mi">4</span><span class="p">,:)=[</span><span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span><span class="p">];</span>

    <span class="n">vol</span><span class="p">=</span><span class="n">struct</span><span class="p">();</span>
    <span class="n">vol</span><span class="p">.</span><span class="n">mat</span><span class="p">=</span><span class="n">mat</span><span class="p">;</span>
    <span class="n">vol</span><span class="p">.</span><span class="n">dim</span><span class="p">=</span><span class="n">hdr</span><span class="p">.</span><span class="n">DATASET_DIMENSIONS</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">);</span>
    <span class="n">vol</span><span class="p">.</span><span class="n">xform</span><span class="p">=</span><span class="n">cosmo_fmri_convert_xform</span><span class="p">(</span><span class="s">&#39;afni&#39;</span><span class="p">,</span><span class="n">hdr</span><span class="p">.</span><span class="n">SCENE_DATA</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>


<span class="c">% AFNI HEAD &amp; BRIK input</span>
<span class="c">% ----------------------</span>
<span class="k">function</span><span class="w"> </span>b<span class="p">=</span><span class="nf">isa_afni</span><span class="p">(</span>hdr<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">b</span><span class="p">=</span><span class="n">isstruct</span><span class="p">(</span><span class="n">hdr</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">isfield</span><span class="p">(</span><span class="n">hdr</span><span class="p">,</span><span class="s">&#39;DATASET_DIMENSIONS&#39;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="c">...</span>
            <span class="n">isfield</span><span class="p">(</span><span class="n">hdr</span><span class="p">,</span><span class="s">&#39;DATASET_RANK&#39;</span><span class="p">);</span>


<span class="k">function</span><span class="w"> </span>head<span class="p">=</span><span class="nf">read_afni_header</span><span class="p">(</span>fn<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">[</span><span class="n">err</span><span class="p">,</span><span class="n">head</span><span class="p">]=</span><span class="n">BrikInfo</span><span class="p">(</span><span class="n">fn</span><span class="p">);</span>
    <span class="k">if</span> <span class="n">err</span>
        <span class="n">error</span><span class="p">(</span><span class="s">&#39;Could not read %s&#39;</span><span class="p">,</span> <span class="n">fn</span><span class="p">);</span>
    <span class="k">end</span>


<span class="k">function</span><span class="w"> </span>[hdr_ds,nsamples]<span class="p">=</span><span class="nf">convert_afni_header</span><span class="p">(</span>head, params<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span> <span class="nb">numel</span><span class="p">(</span><span class="n">head</span><span class="p">.</span><span class="n">DATASET_RANK</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">2</span>
        <span class="n">error</span><span class="p">(</span><span class="s">&#39;illegal AFNI header: DATASET_RANK&#39;</span><span class="p">);</span>
    <span class="k">end</span>
    <span class="n">nsamples</span><span class="p">=</span><span class="n">head</span><span class="p">.</span><span class="n">DATASET_RANK</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>

    <span class="c">% set sample attributes</span>
    <span class="n">sa</span><span class="p">=</span><span class="n">struct</span><span class="p">();</span>

    <span class="k">if</span> <span class="n">isfield</span><span class="p">(</span><span class="n">head</span><span class="p">,</span><span class="s">&#39;BRICK_LABS&#39;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">~</span><span class="nb">isempty</span><span class="p">(</span><span class="n">head</span><span class="p">.</span><span class="n">BRICK_LABS</span><span class="p">);</span>
        <span class="c">% if present, get labels</span>
        <span class="n">labels</span><span class="p">=</span><span class="n">cosmo_strsplit</span><span class="p">(</span><span class="n">head</span><span class="p">.</span><span class="n">BRICK_LABS</span><span class="p">,</span><span class="s">&#39;~&#39;</span><span class="p">);</span>
        <span class="k">if</span> <span class="nb">numel</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span><span class="o">==</span><span class="n">nsamples</span><span class="o">+</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="nb">isempty</span><span class="p">(</span><span class="n">labels</span><span class="p">{</span><span class="k">end</span><span class="p">})</span>
            <span class="n">labels</span><span class="p">=</span><span class="n">labels</span><span class="p">(</span><span class="mi">1</span><span class="p">:(</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>
        <span class="k">end</span>
        <span class="n">sa</span><span class="p">.</span><span class="n">labels</span><span class="p">=</span><span class="n">labels</span><span class="p">(:);</span>
    <span class="k">end</span>

    <span class="k">if</span> <span class="n">isfield</span><span class="p">(</span><span class="n">head</span><span class="p">,</span><span class="s">&#39;BRICK_STATAUX&#39;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">~</span><span class="nb">isempty</span><span class="p">(</span><span class="n">head</span><span class="p">.</span><span class="n">BRICK_STATAUX</span><span class="p">);</span>
        <span class="c">% if present, get stat codes</span>
        <span class="n">sa</span><span class="p">.</span><span class="n">stats</span><span class="p">=</span><span class="n">cosmo_statcode</span><span class="p">(</span><span class="n">head</span><span class="p">);</span>
    <span class="k">end</span>

    <span class="n">hdr_ds</span><span class="p">.</span><span class="n">sa</span><span class="p">=</span><span class="n">sa</span><span class="p">;</span>

    <span class="c">% get volume info</span>
    <span class="n">hdr_ds</span><span class="p">.</span><span class="n">a</span><span class="p">.</span><span class="n">vol</span><span class="p">=</span><span class="n">get_vol_afni</span><span class="p">(</span><span class="n">head</span><span class="p">);</span>

<span class="k">function</span><span class="w"> </span>head<span class="p">=</span><span class="nf">read_afni_data</span><span class="p">(</span>fn, head, volumes<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">opt</span><span class="p">=</span><span class="n">struct</span><span class="p">();</span>
    <span class="n">opt</span><span class="p">.</span><span class="n">Frames</span><span class="p">=</span><span class="n">volumes</span><span class="p">;</span>

    <span class="p">[</span><span class="n">err</span><span class="p">,</span><span class="n">data</span><span class="p">,</span><span class="n">head_data</span><span class="p">,</span><span class="n">err_msg</span><span class="p">]=</span><span class="n">BrikLoad</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span><span class="n">opt</span><span class="p">);</span>
    <span class="k">if</span> <span class="n">err</span>
        <span class="n">error</span><span class="p">(</span><span class="s">&#39;Error reading afni file: %s&#39;</span><span class="p">,</span> <span class="n">err_msg</span><span class="p">);</span>
    <span class="k">end</span>

    <span class="n">assert</span><span class="p">(</span><span class="nb">isequal</span><span class="p">(</span><span class="n">head_data</span><span class="p">,</span><span class="n">head</span><span class="p">));</span>

    <span class="n">head</span><span class="p">.</span><span class="n">img</span><span class="p">=</span><span class="n">data</span><span class="p">;</span>


<span class="k">function</span><span class="w"> </span>data<span class="p">=</span><span class="nf">convert_afni_data</span><span class="p">(</span>head, volumes<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">data</span><span class="p">=</span><span class="n">slice_4d</span><span class="p">(</span><span class="n">head</span><span class="p">.</span><span class="n">img</span><span class="p">,</span> <span class="n">volumes</span><span class="p">);</span>





<span class="c">%%%%%%%%%%%%%%%%%%%%%%%%</span>
<span class="c">% BrainVoyager</span>
<span class="c">%%%%%%%%%%%%%%%%%%%%%%%%</span>

<span class="c">% helpers</span>
<span class="k">function</span><span class="w"> </span>z<span class="p">=</span><span class="nf">xff_struct</span><span class="p">(</span>x<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="c">% helper function: applies xff and returns a struct</span>
    <span class="c">% this avoids clearing of the object (which xff seems like doing)</span>
    <span class="n">y</span><span class="p">=</span><span class="n">xff</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
    <span class="n">z</span><span class="p">=</span><span class="n">getcont</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>

    <span class="c">% BoundingBox is a method; copy its output to the struct</span>
    <span class="n">z</span><span class="p">.</span><span class="n">BoundingBox</span><span class="p">=</span><span class="n">y</span><span class="p">.</span><span class="n">BoundingBox</span><span class="p">;</span>

    <span class="c">% Clear object</span>
    <span class="n">y</span><span class="p">.</span><span class="n">ClearObject</span><span class="p">();</span>

<span class="k">function</span><span class="w"> </span>vol<span class="p">=</span><span class="nf">get_vol_bv</span><span class="p">(</span>hdr<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="c">% bv vol info</span>
    <span class="n">bbox</span><span class="p">=</span><span class="n">hdr</span><span class="p">.</span><span class="n">BoundingBox</span><span class="p">;</span>
    <span class="n">mat</span><span class="p">=</span><span class="n">neuroelf_bvcoordconv_wrapper</span><span class="p">([],</span><span class="s">&#39;bvx2tal&#39;</span><span class="p">,</span><span class="n">bbox</span><span class="p">);</span>
    <span class="n">dim</span><span class="p">=</span><span class="n">bbox</span><span class="p">.</span><span class="n">DimXYZ</span><span class="p">;</span>

    <span class="n">vol</span><span class="p">=</span><span class="n">struct</span><span class="p">();</span>
    <span class="n">vol</span><span class="p">.</span><span class="n">mat</span><span class="p">=</span><span class="n">mat</span><span class="p">;</span>
    <span class="n">vol</span><span class="p">.</span><span class="n">dim</span><span class="p">=</span><span class="n">dim</span><span class="p">;</span>
    <span class="n">vol</span><span class="p">.</span><span class="n">xform</span><span class="p">=</span><span class="n">cosmo_fmri_convert_xform</span><span class="p">(</span><span class="s">&#39;bv&#39;</span><span class="p">,</span><span class="n">NaN</span><span class="p">);</span>

<span class="k">function</span><span class="w"> </span>mat<span class="p">=</span><span class="nf">neuroelf_bvcoordconv_wrapper</span><span class="p">(</span>varargin<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="c">% converts BV bounding box to affine transformation matrix</span>
    <span class="c">% helper functions that deals with both new neuroelf (version 1.0)</span>
    <span class="c">% and older versions.</span>
    <span class="c">% the old version provides a &#39;bvcoordconv&#39; .m file</span>
    <span class="c">% the new version privides this function in the neuroelf class</span>
    <span class="n">has_bvcoordconv</span><span class="p">=</span><span class="o">~</span><span class="nb">isempty</span><span class="p">(</span><span class="n">which</span><span class="p">(</span><span class="s">&#39;bvcoordconv&#39;</span><span class="p">));</span>

    <span class="c">% set function handle</span>
    <span class="k">if</span> <span class="n">has_bvcoordconv</span>
        <span class="n">f</span><span class="p">=@</span><span class="n">bvcoordconv</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="n">n</span><span class="p">=</span><span class="n">neuroelf</span><span class="p">();</span>
        <span class="n">f</span><span class="p">=@</span><span class="n">n</span><span class="p">.</span><span class="n">bvcoordconv</span><span class="p">;</span>
    <span class="k">end</span>

    <span class="n">mat</span><span class="p">=</span><span class="n">f</span><span class="p">(</span><span class="n">varargin</span><span class="p">{:});</span>


<span class="c">% BV GLM input</span>
<span class="c">% ------------</span>
<span class="k">function</span><span class="w"> </span>b<span class="p">=</span><span class="nf">isa_bv_glm</span><span class="p">(</span>hdr<span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="n">b</span><span class="p">=(</span><span class="n">isa</span><span class="p">(</span><span class="n">hdr</span><span class="p">,</span><span class="s">&#39;xff&#39;</span><span class="p">)</span> <span class="o">||</span> <span class="n">isstruct</span><span class="p">(</span><span class="n">hdr</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="n">isfield</span><span class="p">(</span><span class="n">hdr</span><span class="p">,</span><span class="s">&#39;Predictor&#39;</span><span class="p">)</span> <span class="o">&amp;&amp;</span>  <span class="c">...</span>
            <span class="n">isfield</span><span class="p">(</span><span class="n">hdr</span><span class="p">,</span><span class="s">&#39;GLMData&#39;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">isfield</span><span class="p">(</span><span class="n">hdr</span><span class="p">,</span><span class="s">&#39;DesignMatrix&#39;</span><span class="p">);</span>

<span class="k">function</span><span class="w"> </span>hdr<span class="p">=</span><span class="nf">read_bv_glm_header</span><span class="p">(</span>fn<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">hdr</span><span class="p">=</span><span class="n">get_and_check_data</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="p">@</span><span class="n">xff_struct</span><span class="p">,</span> <span class="p">@</span><span class="n">isa_bv_glm</span><span class="p">);</span>


<span class="k">function</span><span class="w"> </span>[hdr_ds,nsamples]<span class="p">=</span><span class="nf">convert_bv_glm_header</span><span class="p">(</span>hdr, params<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">nsamples</span><span class="p">=</span><span class="n">hdr</span><span class="p">.</span><span class="n">NrOfPredictors</span><span class="p">;</span>


    <span class="c">% get sample attributes</span>
    <span class="n">name1</span><span class="p">=</span><span class="n">cell</span><span class="p">(</span><span class="n">nsamples</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">name2</span><span class="p">=</span><span class="n">cell</span><span class="p">(</span><span class="n">nsamples</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">rgb</span><span class="p">=</span><span class="nb">zeros</span><span class="p">(</span><span class="n">nsamples</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">=</span><span class="mi">1</span><span class="p">:</span><span class="n">nsamples</span>
        <span class="n">p</span><span class="p">=</span><span class="n">hdr</span><span class="p">.</span><span class="n">Predictor</span><span class="p">(</span><span class="n">k</span><span class="p">);</span>
        <span class="n">name1</span><span class="p">{</span><span class="n">k</span><span class="p">}=</span><span class="n">p</span><span class="p">.</span><span class="n">Name1</span><span class="p">;</span>
        <span class="n">name2</span><span class="p">{</span><span class="n">k</span><span class="p">}=</span><span class="n">p</span><span class="p">.</span><span class="n">Name2</span><span class="p">;</span>
        <span class="n">rgb</span><span class="p">(</span><span class="n">k</span><span class="p">,:)=</span><span class="n">p</span><span class="p">.</span><span class="n">RGB</span><span class="p">(</span><span class="mi">1</span><span class="p">,:);</span>
    <span class="k">end</span>

    <span class="n">sa</span><span class="p">=</span><span class="n">struct</span><span class="p">();</span>
    <span class="n">sa</span><span class="p">.</span><span class="n">Name1</span><span class="p">=</span><span class="n">name1</span><span class="p">;</span>
    <span class="n">sa</span><span class="p">.</span><span class="n">Name2</span><span class="p">=</span><span class="n">name2</span><span class="p">;</span>
    <span class="n">sa</span><span class="p">.</span><span class="n">RGB</span><span class="p">=</span><span class="n">rgb</span><span class="p">;</span>

    <span class="n">vol</span><span class="p">=</span><span class="n">get_vol_bv</span><span class="p">(</span><span class="n">hdr</span><span class="p">);</span>

    <span class="n">hdr_ds</span><span class="p">=</span><span class="n">struct</span><span class="p">();</span>
    <span class="n">hdr_ds</span><span class="p">.</span><span class="n">sa</span><span class="p">=</span><span class="n">sa</span><span class="p">;</span>
    <span class="n">hdr_ds</span><span class="p">.</span><span class="n">a</span><span class="p">.</span><span class="n">vol</span><span class="p">=</span><span class="n">vol</span><span class="p">;</span>


<span class="k">function</span><span class="w"> </span>data<span class="p">=</span><span class="nf">convert_bv_glm_data</span><span class="p">(</span>hdr, volumes<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="c">% ignore filename, because all data is already in hdr</span>
    <span class="n">data</span><span class="p">=</span><span class="n">slice_4d</span><span class="p">(</span><span class="n">hdr</span><span class="p">.</span><span class="n">GLMData</span><span class="p">.</span><span class="n">BetaMaps</span><span class="p">,</span> <span class="n">volumes</span><span class="p">);</span>



<span class="c">% BV volumetric map input</span>
<span class="c">% -----------------------</span>
<span class="k">function</span><span class="w"> </span>b<span class="p">=</span><span class="nf">isa_bv_vmp</span><span class="p">(</span>hdr<span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="n">b</span><span class="p">=(</span><span class="n">isa</span><span class="p">(</span><span class="n">hdr</span><span class="p">,</span><span class="s">&#39;xff&#39;</span><span class="p">)</span> <span class="o">||</span> <span class="n">isstruct</span><span class="p">(</span><span class="n">hdr</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="c">...</span>
            <span class="n">isfield</span><span class="p">(</span><span class="n">hdr</span><span class="p">,</span><span class="s">&#39;Map&#39;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">isstruct</span><span class="p">(</span><span class="n">hdr</span><span class="p">.</span><span class="n">Map</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="c">...</span>
            <span class="n">isfield</span><span class="p">(</span><span class="n">hdr</span><span class="p">,</span><span class="s">&#39;VMRDimX&#39;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">isfield</span><span class="p">(</span><span class="n">hdr</span><span class="p">,</span><span class="s">&#39;NrOfMaps&#39;</span><span class="p">);</span>


<span class="k">function</span><span class="w"> </span>hdr<span class="p">=</span><span class="nf">read_bv_vmp_header</span><span class="p">(</span>fn<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">hdr</span><span class="p">=</span><span class="n">get_and_check_data</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="p">@</span><span class="n">xff_struct</span><span class="p">,</span> <span class="p">@</span><span class="n">isa_bv_vmp</span><span class="p">);</span>


<span class="k">function</span><span class="w"> </span>[hdr_ds,nsamples]<span class="p">=</span><span class="nf">convert_bv_vmp_header</span><span class="p">(</span>hdr, params<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">nsamples</span><span class="p">=</span><span class="n">hdr</span><span class="p">.</span><span class="n">NrOfMaps</span><span class="p">;</span>

    <span class="n">sa</span><span class="p">=</span><span class="n">struct</span><span class="p">();</span>
    <span class="n">labels</span><span class="p">=</span><span class="n">cell</span><span class="p">(</span><span class="n">nsamples</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">=</span><span class="mi">1</span><span class="p">:</span><span class="n">nsamples</span>
        <span class="n">map</span><span class="p">=</span><span class="n">hdr</span><span class="p">.</span><span class="n">Map</span><span class="p">(</span><span class="n">k</span><span class="p">);</span>
        <span class="n">labels</span><span class="p">{</span><span class="n">k</span><span class="p">}=</span><span class="n">map</span><span class="p">.</span><span class="n">Name</span><span class="p">;</span>
    <span class="k">end</span>

    <span class="n">sa</span><span class="p">.</span><span class="n">labels</span><span class="p">=</span><span class="n">labels</span><span class="p">;</span>
    <span class="n">sa</span><span class="p">.</span><span class="n">stats</span><span class="p">=</span><span class="n">cosmo_statcode</span><span class="p">(</span><span class="n">hdr</span><span class="p">);</span>

    <span class="n">hdr_ds</span><span class="p">=</span><span class="n">struct</span><span class="p">();</span>
    <span class="n">hdr_ds</span><span class="p">.</span><span class="n">sa</span><span class="p">=</span><span class="n">sa</span><span class="p">;</span>
    <span class="n">hdr_ds</span><span class="p">.</span><span class="n">a</span><span class="p">.</span><span class="n">vol</span><span class="p">=</span><span class="n">get_vol_bv</span><span class="p">(</span><span class="n">hdr</span><span class="p">);</span>


<span class="k">function</span><span class="w"> </span>data<span class="p">=</span><span class="nf">convert_bv_vmp_data</span><span class="p">(</span>hdr, volumes<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">nsamples</span><span class="p">=</span><span class="nb">numel</span><span class="p">(</span><span class="n">hdr</span><span class="p">.</span><span class="n">Map</span><span class="p">);</span>

    <span class="k">if</span> <span class="nb">isempty</span><span class="p">(</span><span class="n">volumes</span><span class="p">)</span>
        <span class="n">volumes</span><span class="p">=</span><span class="mi">1</span><span class="p">:</span><span class="n">nsamples</span><span class="p">;</span>
    <span class="k">end</span>

    <span class="n">nvolumes</span><span class="p">=</span><span class="nb">numel</span><span class="p">(</span><span class="n">volumes</span><span class="p">);</span>
    <span class="n">data_cell</span><span class="p">=</span><span class="n">cell</span><span class="p">(</span><span class="n">nvolumes</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>

    <span class="k">for</span> <span class="n">k</span><span class="p">=</span><span class="mi">1</span><span class="p">:</span><span class="n">nvolumes</span>
        <span class="n">map</span><span class="p">=</span><span class="n">hdr</span><span class="p">.</span><span class="n">Map</span><span class="p">(</span><span class="n">volumes</span><span class="p">(</span><span class="n">k</span><span class="p">)).</span><span class="n">VMPData</span><span class="p">;</span>
        <span class="n">data_cell</span><span class="p">{</span><span class="n">k</span><span class="p">}=</span><span class="n">map</span><span class="p">;</span>
    <span class="k">end</span>

    <span class="n">data</span><span class="p">=</span><span class="nb">cat</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="n">data_cell</span><span class="p">{:});</span>



<span class="c">% BV mask input</span>
<span class="c">% -------------</span>
<span class="k">function</span><span class="w"> </span>b<span class="p">=</span><span class="nf">isa_bv_msk</span><span class="p">(</span>hdr<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">b</span><span class="p">=(</span><span class="n">isa</span><span class="p">(</span><span class="n">hdr</span><span class="p">,</span><span class="s">&#39;xff&#39;</span><span class="p">)</span> <span class="o">||</span> <span class="n">isstruct</span><span class="p">(</span><span class="n">hdr</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="n">isfield</span><span class="p">(</span><span class="n">hdr</span><span class="p">,</span> <span class="s">&#39;Mask&#39;</span><span class="p">);</span>


<span class="k">function</span><span class="w"> </span>hdr<span class="p">=</span><span class="nf">read_bv_msk_header</span><span class="p">(</span>fn<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">hdr</span><span class="p">=</span><span class="n">get_and_check_data</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="p">@</span><span class="n">xff_struct</span><span class="p">,</span> <span class="p">@</span><span class="n">isa_bv_msk</span><span class="p">);</span>


<span class="k">function</span><span class="w"> </span>[hdr_ds,nsamples]<span class="p">=</span><span class="nf">convert_bv_msk_header</span><span class="p">(</span>hdr, params<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">nsamples</span><span class="p">=</span><span class="mi">1</span><span class="p">;</span>

    <span class="n">hdr_ds</span><span class="p">=</span><span class="n">struct</span><span class="p">();</span>
    <span class="n">hdr_ds</span><span class="p">.</span><span class="n">sa</span><span class="p">=</span><span class="n">struct</span><span class="p">();</span>
    <span class="n">hdr_ds</span><span class="p">.</span><span class="n">a</span><span class="p">.</span><span class="n">vol</span><span class="p">=</span><span class="n">get_vol_bv</span><span class="p">(</span><span class="n">hdr</span><span class="p">);</span>


<span class="k">function</span><span class="w"> </span>data<span class="p">=</span><span class="nf">convert_bv_msk_data</span><span class="p">(</span>hdr, volumes<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">require_singleton_volume</span><span class="p">(</span><span class="n">volumes</span><span class="p">);</span>

    <span class="n">data</span><span class="p">=</span><span class="n">double</span><span class="p">(</span><span class="n">hdr</span><span class="p">.</span><span class="n">Mask</span><span class="p">);</span>



<span class="c">% BV volume time course input</span>
<span class="c">% ---------------------------</span>
<span class="k">function</span><span class="w"> </span>b<span class="p">=</span><span class="nf">isa_bv_vtc</span><span class="p">(</span>hdr<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">b</span><span class="p">=(</span><span class="n">isa</span><span class="p">(</span><span class="n">hdr</span><span class="p">,</span><span class="s">&#39;xff&#39;</span><span class="p">)</span> <span class="o">||</span> <span class="n">isstruct</span><span class="p">(</span><span class="n">hdr</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="n">isfield</span><span class="p">(</span><span class="n">hdr</span><span class="p">,</span> <span class="s">&#39;VTCData&#39;</span><span class="p">);</span>


<span class="k">function</span><span class="w"> </span>hdr<span class="p">=</span><span class="nf">read_bv_vtc_header</span><span class="p">(</span>fn<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">hdr</span><span class="p">=</span><span class="n">get_and_check_data</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="p">@</span><span class="n">xff_struct</span><span class="p">,</span> <span class="p">@</span><span class="n">isa_bv_vtc</span><span class="p">);</span>


<span class="k">function</span><span class="w"> </span>[hdr_ds,nsamples]<span class="p">=</span><span class="nf">convert_bv_vtc_header</span><span class="p">(</span>hdr, params<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">nsamples</span><span class="p">=</span><span class="nb">size</span><span class="p">(</span><span class="n">hdr</span><span class="p">.</span><span class="n">VTCData</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>

    <span class="n">hdr_ds</span><span class="p">=</span><span class="n">struct</span><span class="p">();</span>
    <span class="n">hdr_ds</span><span class="p">.</span><span class="n">sa</span><span class="p">=</span><span class="n">struct</span><span class="p">();</span>
    <span class="n">hdr_ds</span><span class="p">.</span><span class="n">a</span><span class="p">.</span><span class="n">vol</span><span class="p">=</span><span class="n">get_vol_bv</span><span class="p">(</span><span class="n">hdr</span><span class="p">);</span>


<span class="k">function</span><span class="w"> </span>data<span class="p">=</span><span class="nf">convert_bv_vtc_data</span><span class="p">(</span>hdr, volumes<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">data</span><span class="p">=</span><span class="n">slice_4d</span><span class="p">(</span><span class="nb">shiftdim</span><span class="p">(</span><span class="n">hdr</span><span class="p">.</span><span class="n">VTCData</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">volumes</span><span class="p">);</span>



<span class="c">% BV volumetric MR (anatomy) input</span>
<span class="c">% --------------------------------</span>
<span class="k">function</span><span class="w"> </span>b<span class="p">=</span><span class="nf">isa_bv_vmr</span><span class="p">(</span>hdr<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">b</span><span class="p">=(</span><span class="n">isa</span><span class="p">(</span><span class="n">hdr</span><span class="p">,</span><span class="s">&#39;xff&#39;</span><span class="p">)</span> <span class="o">||</span> <span class="n">isstruct</span><span class="p">(</span><span class="n">hdr</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="n">isfield</span><span class="p">(</span><span class="n">hdr</span><span class="p">,</span><span class="s">&#39;VMRData&#39;</span><span class="p">);</span>


<span class="k">function</span><span class="w"> </span>hdr<span class="p">=</span><span class="nf">read_bv_vmr_header</span><span class="p">(</span>fn<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">hdr</span><span class="p">=</span><span class="n">get_and_check_data</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="p">@</span><span class="n">xff_struct</span><span class="p">,</span> <span class="p">@</span><span class="n">isa_bv_vmr</span><span class="p">);</span>


<span class="k">function</span><span class="w"> </span>[hdr_ds,nsamples]<span class="p">=</span><span class="nf">convert_bv_vmr_header</span><span class="p">(</span>hdr, params<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">nsamples</span><span class="p">=</span><span class="mi">1</span><span class="p">;</span>

    <span class="n">hdr_ds</span><span class="p">=</span><span class="n">struct</span><span class="p">();</span>
    <span class="n">hdr_ds</span><span class="p">.</span><span class="n">sa</span><span class="p">=</span><span class="n">struct</span><span class="p">();</span>
    <span class="n">hdr_ds</span><span class="p">.</span><span class="n">a</span><span class="p">.</span><span class="n">vol</span><span class="p">=</span><span class="n">get_vol_bv</span><span class="p">(</span><span class="n">hdr</span><span class="p">);</span>


<span class="k">function</span><span class="w"> </span>data<span class="p">=</span><span class="nf">convert_bv_vmr_data</span><span class="p">(</span>hdr, volumes<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">data</span><span class="p">=</span><span class="n">slice_4d</span><span class="p">(</span><span class="n">hdr</span><span class="p">.</span><span class="n">VMRData</span><span class="p">,</span><span class="n">volumes</span><span class="p">);</span>



<span class="c">%%%%%%%%%%%%%%%%%%%%%%%%</span>
<span class="c">% SPM structure</span>
<span class="c">%%%%%%%%%%%%%%%%%%%%%%%%</span>

<span class="c">% SPM input</span>
<span class="c">% ---------</span>
<span class="k">function</span><span class="w"> </span>b<span class="p">=</span><span class="nf">isa_spm</span><span class="p">(</span>hdr<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">b</span><span class="p">=</span><span class="n">isstruct</span><span class="p">(</span><span class="n">hdr</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">isfield</span><span class="p">(</span><span class="n">hdr</span><span class="p">,</span><span class="s">&#39;xX&#39;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">isfield</span><span class="p">(</span><span class="n">hdr</span><span class="p">.</span><span class="n">xX</span><span class="p">,</span><span class="s">&#39;X&#39;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="c">...</span>
                <span class="n">isnumeric</span><span class="p">(</span><span class="n">hdr</span><span class="p">.</span><span class="n">xX</span><span class="p">.</span><span class="n">X</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">isfield</span><span class="p">(</span><span class="n">hdr</span><span class="p">,</span><span class="s">&#39;SPMid&#39;</span><span class="p">);</span>


<span class="k">function</span><span class="w"> </span>hdr<span class="p">=</span><span class="nf">read_spm_header</span><span class="p">(</span>fn<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">hdr</span><span class="p">=</span><span class="n">read_spm_struct_header</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="p">[]);</span>

<span class="k">function</span><span class="w"> </span>hdr<span class="p">=</span><span class="nf">read_spm_struct_header</span><span class="p">(</span>fn_with_input_type, spm_header<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="c">% input can be &#39;SPM.mat&#39;, &#39;SPM.mat:beta&#39;, &#39;SPM.mat:con&#39;, or</span>
    <span class="c">% &#39;SPM.mat:spm&#39;. Output is the SPM struct with extra fields &#39;path&#39; and</span>
    <span class="c">% &#39;input_type&#39; added, so that convert_spm_header can get the correct</span>
    <span class="c">% fields</span>

    <span class="k">if</span> <span class="n">isa_spm</span><span class="p">(</span><span class="n">fn_with_input_type</span><span class="p">)</span>
        <span class="n">fn_with_input_type</span><span class="p">=</span><span class="s">&#39;SPM.mat&#39;</span><span class="p">;</span>
    <span class="k">end</span>

    <span class="p">[</span><span class="n">fn</span><span class="p">,</span><span class="n">input_type</span><span class="p">]=</span><span class="n">get_spm_input_type</span><span class="p">(</span><span class="n">fn_with_input_type</span><span class="p">);</span>

    <span class="k">if</span> <span class="nb">isempty</span><span class="p">(</span><span class="n">spm_header</span><span class="p">)</span>
        <span class="c">% .mat file must be loaded still</span>
        <span class="n">spm_struct</span><span class="p">=</span><span class="n">load</span><span class="p">(</span><span class="n">fn</span><span class="p">);</span>
        <span class="k">if</span> <span class="o">~</span><span class="n">isstruct</span><span class="p">(</span><span class="n">spm_struct</span><span class="p">)</span> <span class="o">||</span> <span class="c">...</span>
                <span class="o">~</span><span class="nb">isequal</span><span class="p">(</span><span class="n">fieldnames</span><span class="p">(</span><span class="n">spm_struct</span><span class="p">),{</span><span class="s">&#39;SPM&#39;</span><span class="p">})</span>
            <span class="n">error</span><span class="p">(</span><span class="s">&#39;expected data with struct &#39;&#39;SPM&#39;&#39; in file &#39;&#39;%s&#39;&#39;&#39;</span><span class="p">,</span><span class="n">fn</span><span class="p">);</span>
        <span class="k">end</span>
        <span class="n">spm_header</span><span class="p">=</span><span class="n">spm_struct</span><span class="p">.</span><span class="n">SPM</span><span class="p">;</span>
    <span class="k">end</span>

    <span class="n">hdr</span><span class="p">=</span><span class="n">spm_header</span><span class="p">;</span>
    <span class="n">hdr</span><span class="p">.</span><span class="n">path</span><span class="p">=</span><span class="n">fileparts</span><span class="p">(</span><span class="n">fn</span><span class="p">);</span>
    <span class="n">hdr</span><span class="p">.</span><span class="n">input_type</span><span class="p">=</span><span class="n">input_type</span><span class="p">;</span>

    <span class="n">get_and_check_data</span><span class="p">(</span><span class="n">hdr</span><span class="p">,</span> <span class="p">[],</span> <span class="p">@</span><span class="n">isa_spm</span><span class="p">);</span>

<span class="k">function</span><span class="w"> </span>[fn,input_type]<span class="p">=</span><span class="nf">get_spm_input_type</span><span class="p">(</span>fn_with_input_type<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">sep</span><span class="p">=</span><span class="s">&#39;:&#39;</span><span class="p">;</span>
    <span class="n">input_type</span><span class="p">=</span><span class="n">cosmo_strsplit</span><span class="p">(</span><span class="n">fn_with_input_type</span><span class="p">,</span><span class="n">sep</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">fn</span><span class="p">=</span><span class="n">fn_with_input_type</span><span class="p">;</span>

    <span class="k">switch</span> <span class="n">input_type</span>
        <span class="k">case</span> <span class="p">{</span><span class="s">&#39;beta&#39;</span><span class="p">,</span><span class="s">&#39;con&#39;</span><span class="p">,</span><span class="s">&#39;spm&#39;</span><span class="p">}</span>
            <span class="n">fn</span><span class="p">=</span><span class="n">fn</span><span class="p">(</span><span class="mi">1</span><span class="p">:(</span><span class="k">end</span><span class="o">-</span><span class="nb">numel</span><span class="p">(</span><span class="n">input_type</span><span class="p">)</span><span class="o">-</span><span class="nb">numel</span><span class="p">(</span><span class="n">sep</span><span class="p">)));</span>
        <span class="k">otherwise</span>
            <span class="n">input_type</span><span class="p">=</span><span class="s">&#39;beta&#39;</span><span class="p">;</span> <span class="c">% the default; function will crash</span>
                               <span class="c">% if fn is not a proper filename</span>
    <span class="k">end</span>


<span class="k">function</span><span class="w"> </span>[hdr_ds,nsamples]<span class="p">=</span><span class="nf">convert_spm_header</span><span class="p">(</span>spm_struct, params<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span> <span class="n">isfield</span><span class="p">(</span><span class="n">spm_struct</span><span class="p">,</span><span class="s">&#39;input_type&#39;</span><span class="p">)</span>
        <span class="n">input_type</span><span class="p">=</span><span class="n">spm_struct</span><span class="p">.</span><span class="n">input_type</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="n">input_type</span><span class="p">=</span><span class="s">&#39;beta&#39;</span><span class="p">;</span>
    <span class="k">end</span>

    <span class="k">if</span> <span class="n">isfield</span><span class="p">(</span><span class="n">spm_struct</span><span class="p">,</span><span class="s">&#39;path&#39;</span><span class="p">)</span>
        <span class="n">path</span><span class="p">=</span><span class="n">spm_struct</span><span class="p">.</span><span class="n">path</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="n">path</span><span class="p">=</span><span class="s">&#39;&#39;</span><span class="p">;</span>
    <span class="k">end</span>

    <span class="c">% get data of interest</span>
    <span class="k">switch</span> <span class="n">input_type</span>
            <span class="k">case</span> <span class="s">&#39;beta&#39;</span>
                <span class="n">input_vols</span><span class="p">=</span><span class="n">spm_struct</span><span class="p">.</span><span class="n">Vbeta</span><span class="p">;</span>
                <span class="n">input_labels</span><span class="p">=</span><span class="n">spm_struct</span><span class="p">.</span><span class="n">xX</span><span class="p">.</span><span class="n">name</span><span class="o">&#39;</span><span class="p">;</span>
            <span class="k">case</span> <span class="s">&#39;con&#39;</span>
                <span class="n">input_vols</span><span class="p">=[</span><span class="n">spm_struct</span><span class="p">.</span><span class="n">xCon</span><span class="p">.</span><span class="n">Vcon</span><span class="p">];</span>
                <span class="n">input_labels</span><span class="p">={</span><span class="n">spm_struct</span><span class="p">.</span><span class="n">xCon</span><span class="p">.</span><span class="n">name</span><span class="p">}</span><span class="s">&#39;;</span>
<span class="s">            case &#39;</span><span class="n">spm</span><span class="o">&#39;</span>
                <span class="n">input_vols</span><span class="p">=[</span><span class="n">spm_struct</span><span class="p">.</span><span class="n">xCon</span><span class="p">.</span><span class="n">Vspm</span><span class="p">];</span>
                <span class="n">input_labels</span><span class="p">={</span><span class="n">spm_struct</span><span class="p">.</span><span class="n">xCon</span><span class="p">.</span><span class="n">name</span><span class="p">}</span><span class="s">&#39;;</span>
<span class="s">        otherwise</span>
<span class="s">            error(&#39;</span><span class="n">illegal</span> <span class="n">data</span> <span class="n">type</span> <span class="c">%s&#39;, input_type);</span>
    <span class="k">end</span>

    <span class="n">n_input</span><span class="p">=</span><span class="nb">numel</span><span class="p">(</span><span class="n">input_vols</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="nb">numel</span><span class="p">(</span><span class="n">input_labels</span><span class="p">)</span><span class="o">==</span><span class="n">n_input</span><span class="p">);</span>

    <span class="n">sa</span><span class="p">=</span><span class="n">struct</span><span class="p">();</span>

    <span class="k">if</span> <span class="n">isfield</span><span class="p">(</span><span class="n">spm_struct</span><span class="p">,</span><span class="s">&#39;Sess&#39;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">input_type</span><span class="p">,</span><span class="s">&#39;beta&#39;</span><span class="p">)</span>
        <span class="c">% single subject GLM with betas; will use only betas of interest</span>
        <span class="c">% and set chunks based on runs</span>
        <span class="n">nruns</span><span class="p">=</span><span class="nb">numel</span><span class="p">(</span><span class="n">spm_struct</span><span class="p">.</span><span class="n">Sess</span><span class="p">);</span>
        <span class="n">nbeta</span><span class="p">=</span><span class="nb">numel</span><span class="p">(</span><span class="n">spm_struct</span><span class="p">.</span><span class="n">Vbeta</span><span class="p">);</span>
        <span class="n">sessions</span><span class="p">=</span><span class="nb">zeros</span><span class="p">(</span><span class="n">nbeta</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
        <span class="n">beta_index</span><span class="p">=</span><span class="nb">zeros</span><span class="p">(</span><span class="n">nbeta</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">=</span><span class="mi">1</span><span class="p">:</span><span class="n">nruns</span>
            <span class="n">sess</span><span class="p">=</span><span class="n">spm_struct</span><span class="p">.</span><span class="n">Sess</span><span class="p">(</span><span class="n">k</span><span class="p">);</span>
            <span class="n">sess_idxs</span><span class="p">=[</span><span class="n">sess</span><span class="p">.</span><span class="n">Fc</span><span class="p">.</span><span class="nb">i</span><span class="p">];</span>
            <span class="n">row_idxs</span><span class="p">=</span><span class="n">sess</span><span class="p">.</span><span class="n">col</span><span class="p">(</span><span class="n">sess_idxs</span><span class="p">);</span>

            <span class="n">sessions</span><span class="p">(</span><span class="n">row_idxs</span><span class="p">)=</span><span class="n">k</span><span class="p">;</span>
            <span class="n">beta_index</span><span class="p">(</span><span class="n">row_idxs</span><span class="p">)=</span><span class="n">row_idxs</span><span class="p">;</span>
        <span class="k">end</span>

        <span class="n">keep_vol_msk</span><span class="p">=</span><span class="n">sessions</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">;</span>
        <span class="n">sa</span><span class="p">.</span><span class="n">chunks</span><span class="p">=</span><span class="n">sessions</span><span class="p">(</span><span class="n">keep_vol_msk</span><span class="p">);</span>
        <span class="n">sa</span><span class="p">.</span><span class="n">beta_index</span><span class="p">=</span><span class="n">beta_index</span><span class="p">(</span><span class="n">keep_vol_msk</span><span class="p">);</span>
    <span class="k">else</span>
        <span class="c">% anything else: use all volumes</span>
        <span class="n">keep_vol_msk</span><span class="p">=</span><span class="n">true</span><span class="p">(</span><span class="n">n_input</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">end</span>

    <span class="n">sa</span><span class="p">.</span><span class="n">labels</span><span class="p">=</span><span class="n">input_labels</span><span class="p">(</span><span class="n">keep_vol_msk</span><span class="p">);</span>
    <span class="n">sa</span><span class="p">.</span><span class="n">fname</span><span class="p">=</span><span class="n">cellfun</span><span class="p">(@(</span><span class="n">fn</span><span class="p">)</span><span class="n">fullfile</span><span class="p">(</span><span class="n">path</span><span class="p">,</span><span class="n">fn</span><span class="p">),</span><span class="c">...</span>
                    <span class="p">{</span><span class="n">input_vols</span><span class="p">(</span><span class="n">keep_vol_msk</span><span class="p">).</span><span class="n">fname</span><span class="p">}</span><span class="s">&#39;,...</span>
<span class="s">                                    &#39;</span><span class="n">UniformOutput</span><span class="o">&#39;</span><span class="p">,</span><span class="n">false</span><span class="p">);</span>


    <span class="n">nsamples</span><span class="p">=</span><span class="n">sum</span><span class="p">(</span><span class="n">keep_vol_msk</span><span class="p">);</span>
    <span class="k">if</span> <span class="n">nsamples</span><span class="o">==</span><span class="mi">0</span>
        <span class="n">error</span><span class="p">(</span><span class="s">&#39;Illegal: empty input&#39;</span><span class="p">);</span>
    <span class="k">end</span>

    <span class="c">% get volume info</span>
    <span class="n">first_vol</span><span class="p">=</span><span class="n">input_vols</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">vol</span><span class="p">=</span><span class="n">struct</span><span class="p">();</span>
    <span class="n">vol</span><span class="p">.</span><span class="n">dim</span><span class="p">=</span><span class="n">first_vol</span><span class="p">.</span><span class="n">dim</span><span class="p">;</span>
    <span class="n">vol</span><span class="p">.</span><span class="n">mat</span><span class="p">=</span><span class="n">first_vol</span><span class="p">.</span><span class="n">mat</span><span class="p">;</span>


    <span class="n">hdr_ds</span><span class="p">=</span><span class="n">struct</span><span class="p">();</span>
    <span class="n">hdr_ds</span><span class="p">.</span><span class="n">a</span><span class="p">.</span><span class="n">vol</span><span class="p">=</span><span class="n">vol</span><span class="p">;</span>
    <span class="n">hdr_ds</span><span class="p">.</span><span class="n">sa</span><span class="p">=</span><span class="n">sa</span><span class="p">;</span>


<span class="k">function</span><span class="w"> </span>hdr<span class="p">=</span><span class="nf">read_spm_data</span><span class="p">(</span>fn, hdr, volumes<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="c">% store volumes, so that when convert_spm_data is called, this</span>
    <span class="c">% information is used</span>
    <span class="n">hdr</span><span class="p">.</span><span class="n">volumes</span><span class="p">=</span><span class="n">volumes</span><span class="p">;</span>


<span class="k">function</span><span class="w"> </span>data<span class="p">=</span><span class="nf">convert_spm_data</span><span class="p">(</span>hdr, volumes<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="c">% get SPM info</span>
    <span class="n">hdr_ds</span><span class="p">=</span><span class="n">convert_spm_header</span><span class="p">(</span><span class="n">hdr</span><span class="p">);</span>

    <span class="c">% see which files to load</span>
    <span class="n">file_names</span><span class="p">=</span><span class="n">hdr_ds</span><span class="p">.</span><span class="n">sa</span><span class="p">.</span><span class="n">fname</span><span class="p">;</span>
    <span class="n">n_files</span><span class="p">=</span><span class="nb">numel</span><span class="p">(</span><span class="n">file_names</span><span class="p">);</span>

    <span class="k">if</span> <span class="n">isfield</span><span class="p">(</span><span class="n">hdr</span><span class="p">,</span> <span class="s">&#39;volumes&#39;</span><span class="p">)</span>
        <span class="c">% call after read_spm_data; volumes are already selected</span>
        <span class="c">% this must be done by the calling function</span>
        <span class="n">assert</span><span class="p">(</span><span class="nb">isempty</span><span class="p">(</span><span class="n">volumes</span><span class="p">));</span>
        <span class="n">volumes</span><span class="p">=</span><span class="n">hdr</span><span class="p">.</span><span class="n">volumes</span><span class="p">;</span>
    <span class="k">end</span>

    <span class="k">if</span> <span class="nb">isempty</span><span class="p">(</span><span class="n">volumes</span><span class="p">)</span>
        <span class="n">volumes</span><span class="p">=</span><span class="mi">1</span><span class="p">:</span><span class="n">n_files</span><span class="p">;</span>
    <span class="k">end</span>

    <span class="n">n_volumes</span><span class="p">=</span><span class="nb">numel</span><span class="p">(</span><span class="n">volumes</span><span class="p">);</span>

    <span class="c">% allocate space for output</span>
    <span class="n">dim</span><span class="p">=</span><span class="n">hdr_ds</span><span class="p">.</span><span class="n">a</span><span class="p">.</span><span class="n">vol</span><span class="p">.</span><span class="n">dim</span><span class="p">;</span>
    <span class="n">data</span><span class="p">=</span><span class="nb">zeros</span><span class="p">([</span><span class="n">dim</span> <span class="n">n_volumes</span><span class="p">]);</span>

    <span class="c">%</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">=</span><span class="mi">1</span><span class="p">:</span><span class="n">n_volumes</span>
        <span class="n">file_name</span><span class="p">=</span><span class="n">file_names</span><span class="p">{</span><span class="n">volumes</span><span class="p">(</span><span class="n">k</span><span class="p">)};</span>

        <span class="n">nii</span><span class="p">=</span><span class="n">load_untouch_nii</span><span class="p">(</span><span class="n">file_name</span><span class="p">);</span>

        <span class="n">data</span><span class="p">(:,:,:,</span><span class="n">k</span><span class="p">)=</span><span class="n">nii</span><span class="p">.</span><span class="n">img</span><span class="p">;</span>
    <span class="k">end</span>


<span class="c">%%%%%%%%%%%%%%%%%%%%%%%%</span>
<span class="c">% FieldTrip source</span>

<span class="c">% FieldTrip source input</span>
<span class="c">% ----------------------</span>
<span class="k">function</span><span class="w">  </span>b<span class="p">=</span><span class="nf">isa_ft_source</span><span class="p">(</span>hdr<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">b</span><span class="p">=</span><span class="n">isstruct</span><span class="p">(</span><span class="n">hdr</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">isfield</span><span class="p">(</span><span class="n">hdr</span><span class="p">,</span><span class="s">&#39;inside&#39;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="c">...</span>
                                    <span class="n">isfield</span><span class="p">(</span><span class="n">hdr</span><span class="p">,</span><span class="s">&#39;pos&#39;</span><span class="p">))</span>        <span class="o">||</span> <span class="c">...</span>
                        <span class="p">(</span><span class="n">cosmo_check_dataset</span><span class="p">(</span><span class="n">hdr</span><span class="p">,</span><span class="n">false</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="c">...</span>
                                    <span class="n">cosmo_isfield</span><span class="p">(</span><span class="n">hdr</span><span class="p">,</span><span class="s">&#39;fa.pos&#39;</span><span class="p">)));</span>


<span class="k">function</span><span class="w"> </span>hdr<span class="p">=</span><span class="nf">read_ft_source_header</span><span class="p">(</span>fn<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">hdr</span><span class="p">=</span><span class="n">get_and_check_data</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="p">@</span><span class="n">fast_import_data</span><span class="p">,</span> <span class="p">@</span><span class="n">isa_ft_source</span><span class="p">);</span>


<span class="k">function</span><span class="w"> </span>[ds,nsamples]<span class="p">=</span><span class="nf">convert_ft_source_header</span><span class="p">(</span>hdr, params<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span> <span class="n">isfield</span><span class="p">(</span><span class="n">hdr</span><span class="p">,</span><span class="s">&#39;inside&#39;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">isfield</span><span class="p">(</span><span class="n">hdr</span><span class="p">,</span><span class="s">&#39;pos&#39;</span><span class="p">)</span>
        <span class="c">% fieldtrip struct</span>
        <span class="n">ds_meeg</span><span class="p">=</span><span class="n">cosmo_meeg_dataset</span><span class="p">(</span><span class="n">hdr</span><span class="p">);</span>
    <span class="k">else</span>
        <span class="c">% must be dataset struct with field .fa.pos</span>
        <span class="n">cosmo_isfield</span><span class="p">(</span><span class="n">hdr</span><span class="p">,</span><span class="s">&#39;fa.pos&#39;</span><span class="p">,</span><span class="n">true</span><span class="p">);</span>
        <span class="n">ds_meeg</span><span class="p">=</span><span class="n">hdr</span><span class="p">;</span>
    <span class="k">end</span>

    <span class="n">cosmo_check_dataset</span><span class="p">(</span><span class="n">ds_meeg</span><span class="p">,</span><span class="s">&#39;meeg&#39;</span><span class="p">);</span>

    <span class="n">ds</span><span class="p">=</span><span class="n">cosmo_vol_grid_convert</span><span class="p">(</span><span class="n">ds_meeg</span><span class="p">,</span><span class="s">&#39;tovol&#39;</span><span class="p">);</span>
    <span class="n">nsamples</span><span class="p">=</span><span class="nb">size</span><span class="p">(</span><span class="n">ds</span><span class="p">.</span><span class="n">samples</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>


<span class="k">function</span><span class="w"> </span>ds<span class="p">=</span><span class="nf">convert_ft_source_data</span><span class="p">(</span>ds_meeg, volumes<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">ds</span><span class="p">=</span><span class="n">convert_ft_source_header</span><span class="p">(</span><span class="n">ds_meeg</span><span class="p">,</span> <span class="n">struct</span><span class="p">());</span>
    <span class="n">ds</span><span class="p">=</span><span class="n">slice_dataset_volumes</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span> <span class="n">volumes</span><span class="p">);</span>


<span class="c">%%%%%%%%%%%%%%%%%%%%%%%%</span>
<span class="c">% PyMVPA fMRI  datasset</span>

<span class="k">function</span><span class="w"> </span>tf<span class="p">=</span><span class="nf">isa_pymvpa_fmri</span><span class="p">(</span>ds<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">tf</span><span class="p">=</span><span class="n">isstruct</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">isfield</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span><span class="s">&#39;samples&#39;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="c">...</span>
            <span class="n">all</span><span class="p">(</span><span class="n">cosmo_isfield</span><span class="p">(</span><span class="n">ds</span><span class="p">,{</span><span class="s">&#39;a.imgaffine&#39;</span><span class="p">,</span><span class="c">...</span>
                                    <span class="s">&#39;a.voxel_dim&#39;</span><span class="p">,</span><span class="c">...</span>
                                    <span class="s">&#39;a.voxel_eldim&#39;</span><span class="p">,</span><span class="c">...</span>
                                    <span class="s">&#39;fa.voxel_indices&#39;</span><span class="p">}));</span>

<span class="k">function</span><span class="w"> </span>ds<span class="p">=</span><span class="nf">read_pymvpa_ds_header</span><span class="p">(</span>ds<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">ds</span><span class="p">=</span><span class="n">get_and_check_data</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span> <span class="p">[],</span> <span class="p">@</span><span class="n">isa_pymvpa_fmri</span><span class="p">);</span>


<span class="k">function</span><span class="w"> </span>[ds, nsamples]<span class="p">=</span><span class="nf">convert_pymvpa_ds_header</span><span class="p">(</span>pymvpa_ds, params<span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="c">% set volume information</span>
    <span class="n">vol</span><span class="p">=</span><span class="n">struct</span><span class="p">();</span>
    <span class="n">mat_base0</span><span class="p">=</span><span class="n">pymvpa_ds</span><span class="p">.</span><span class="n">a</span><span class="p">.</span><span class="n">imgaffine</span><span class="p">;</span>
    <span class="n">offset</span><span class="p">=</span><span class="n">mat_base0</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="nb">ones</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">mat_base1</span><span class="p">=</span><span class="n">mat_base0</span><span class="p">;</span>
    <span class="n">mat_base1</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)=</span><span class="n">mat_base1</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span><span class="o">-</span><span class="n">offset</span><span class="p">;</span>

    <span class="n">vol</span><span class="p">.</span><span class="n">mat</span><span class="p">=</span><span class="n">mat_base1</span><span class="p">;</span>

    <span class="n">dim</span><span class="p">=</span><span class="n">pymvpa_ds</span><span class="p">.</span><span class="n">a</span><span class="p">.</span><span class="n">voxel_dim</span><span class="p">;</span>
    <span class="n">vol</span><span class="p">.</span><span class="n">dim</span><span class="p">=</span><span class="n">double</span><span class="p">(</span><span class="n">dim</span><span class="p">(:)</span><span class="o">&#39;</span><span class="p">);</span>

    <span class="n">vol</span><span class="p">.</span><span class="n">xform</span><span class="p">=</span><span class="s">&#39;unknown&#39;</span><span class="p">;</span>

    <span class="c">% set feature dimensions</span>
    <span class="n">dim_labels</span><span class="p">={</span><span class="s">&#39;i&#39;</span><span class="p">;</span><span class="s">&#39;j&#39;</span><span class="p">;</span><span class="s">&#39;k&#39;</span><span class="p">};</span>
    <span class="n">n_dim_labels</span><span class="p">=</span><span class="nb">numel</span><span class="p">(</span><span class="n">dim_labels</span><span class="p">);</span>
    <span class="n">fdim</span><span class="p">=</span><span class="n">struct</span><span class="p">();</span>
    <span class="n">fdim</span><span class="p">.</span><span class="n">labels</span><span class="p">=</span><span class="n">dim_labels</span><span class="p">;</span>
    <span class="n">fdim</span><span class="p">.</span><span class="n">values</span><span class="p">=</span><span class="n">arrayfun</span><span class="p">(@(</span><span class="n">x</span><span class="p">)</span><span class="mi">1</span><span class="p">:</span><span class="n">x</span><span class="p">,</span><span class="n">vol</span><span class="p">.</span><span class="n">dim</span><span class="p">(:),</span><span class="s">&#39;UniformOutput&#39;</span><span class="p">,</span><span class="n">false</span><span class="p">);</span>

    <span class="c">% copy over data from PyMPVA struct</span>
    <span class="n">ds</span><span class="p">=</span><span class="n">pymvpa_ds</span><span class="p">;</span>

    <span class="c">% ensure samples are double</span>
    <span class="k">if</span> <span class="o">~</span><span class="n">isa</span><span class="p">(</span><span class="n">ds</span><span class="p">.</span><span class="n">samples</span><span class="p">,</span><span class="s">&#39;double&#39;</span><span class="p">)</span>
        <span class="n">ds</span><span class="p">.</span><span class="n">samples</span><span class="p">=</span><span class="n">double</span><span class="p">(</span><span class="n">ds</span><span class="p">.</span><span class="n">samples</span><span class="p">);</span>
    <span class="k">end</span>

    <span class="c">% remove PyMVPA volume-specific fields</span>
    <span class="n">ds</span><span class="p">.</span><span class="n">a</span><span class="p">=</span><span class="n">rmfield</span><span class="p">(</span><span class="n">ds</span><span class="p">.</span><span class="n">a</span><span class="p">,{</span><span class="s">&#39;imgaffine&#39;</span><span class="p">,</span><span class="s">&#39;voxel_dim&#39;</span><span class="p">,</span><span class="s">&#39;voxel_eldim&#39;</span><span class="p">});</span>
    <span class="k">if</span> <span class="n">isfield</span><span class="p">(</span><span class="n">ds</span><span class="p">.</span><span class="n">a</span><span class="p">,</span><span class="s">&#39;mapper&#39;</span><span class="p">)</span>
        <span class="n">ds</span><span class="p">.</span><span class="n">a</span><span class="p">=</span><span class="n">rmfield</span><span class="p">(</span><span class="n">ds</span><span class="p">.</span><span class="n">a</span><span class="p">,</span><span class="s">&#39;mapper&#39;</span><span class="p">);</span>
    <span class="k">end</span>

    <span class="c">% set vol and fdim</span>
    <span class="n">ds</span><span class="p">.</span><span class="n">a</span><span class="p">.</span><span class="n">vol</span><span class="p">=</span><span class="n">vol</span><span class="p">;</span>
    <span class="n">ds</span><span class="p">.</span><span class="n">a</span><span class="p">.</span><span class="n">fdim</span><span class="p">=</span><span class="n">fdim</span><span class="p">;</span>

    <span class="c">% set voxel indices</span>
    <span class="n">ijk_base0</span><span class="p">=</span><span class="n">double</span><span class="p">(</span><span class="n">ds</span><span class="p">.</span><span class="n">fa</span><span class="p">.</span><span class="n">voxel_indices</span><span class="p">);</span>
    <span class="n">ijk_base1</span><span class="p">=</span><span class="n">ijk_base0</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">=</span><span class="mi">1</span><span class="p">:</span><span class="n">n_dim_labels</span>
        <span class="n">ds</span><span class="p">.</span><span class="n">fa</span><span class="p">.(</span><span class="n">dim_labels</span><span class="p">{</span><span class="n">k</span><span class="p">})=</span><span class="n">ijk_base1</span><span class="p">(</span><span class="n">k</span><span class="p">,:);</span>
    <span class="k">end</span>
    <span class="n">ds</span><span class="p">.</span><span class="n">fa</span><span class="p">=</span><span class="n">rmfield</span><span class="p">(</span><span class="n">ds</span><span class="p">.</span><span class="n">fa</span><span class="p">,</span><span class="s">&#39;voxel_indices&#39;</span><span class="p">);</span>

    <span class="c">% deal with scipy&#39;s 3d character arrays</span>
    <span class="n">ds</span><span class="p">.</span><span class="n">fa</span><span class="p">=</span><span class="n">convert_struct_with_3d_string_array_to_cellstr</span><span class="p">(</span><span class="n">ds</span><span class="p">.</span><span class="n">fa</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
    <span class="k">if</span> <span class="n">isfield</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span><span class="s">&#39;sa&#39;</span><span class="p">)</span>
        <span class="n">ds</span><span class="p">.</span><span class="n">sa</span><span class="p">=</span><span class="n">convert_struct_with_3d_string_array_to_cellstr</span><span class="p">(</span><span class="n">ds</span><span class="p">.</span><span class="n">sa</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">end</span>

    <span class="c">% set number of samples</span>
    <span class="n">nsamples</span><span class="p">=</span><span class="nb">size</span><span class="p">(</span><span class="n">ds</span><span class="p">.</span><span class="n">samples</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>

<span class="k">function</span><span class="w"> </span>ds<span class="p">=</span><span class="nf">convert_pymvpa_ds_data</span><span class="p">(</span>ds, volumes<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">ds</span><span class="p">=</span><span class="n">convert_pymvpa_ds_header</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span> <span class="n">struct</span><span class="p">());</span>
    <span class="n">ds</span><span class="p">=</span><span class="n">slice_dataset_volumes</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span><span class="n">volumes</span><span class="p">);</span>


<span class="k">function</span><span class="w"> </span>c<span class="p">=</span><span class="nf">convert_3d_string_array_to_cellstr</span><span class="p">(</span>arr,dim<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">sz</span><span class="p">=</span><span class="nb">size</span><span class="p">(</span><span class="n">arr</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="nb">numel</span><span class="p">(</span><span class="n">sz</span><span class="p">)</span><span class="o">==</span><span class="mi">3</span><span class="p">);</span>
    <span class="k">if</span> <span class="n">dim</span><span class="o">==</span><span class="mi">1</span>
        <span class="n">new_sz_idxs</span><span class="p">=[</span><span class="mi">1</span> <span class="mi">3</span><span class="p">];</span>
    <span class="k">else</span>
        <span class="n">new_sz_idxs</span><span class="p">=[</span><span class="mi">2</span> <span class="mi">3</span><span class="p">];</span>
    <span class="k">end</span>

    <span class="n">arr_2d</span><span class="p">=</span><span class="nb">reshape</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span><span class="n">sz</span><span class="p">(</span><span class="n">new_sz_idxs</span><span class="p">));</span>
    <span class="n">c</span><span class="p">=</span><span class="n">cellstr</span><span class="p">(</span><span class="n">arr_2d</span><span class="p">);</span>

    <span class="k">if</span> <span class="n">dim</span><span class="o">==</span><span class="mi">2</span>
        <span class="n">c</span><span class="p">=</span><span class="n">c</span><span class="o">&#39;</span><span class="p">;</span>
    <span class="k">end</span>

<span class="k">function</span><span class="w"> </span>s<span class="p">=</span><span class="nf">convert_struct_with_3d_string_array_to_cellstr</span><span class="p">(</span>s,dim<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="c">% deal with scipy&#39;s character arrays that represent 2d cell strings</span>
    <span class="n">fns</span><span class="p">=</span><span class="n">fieldnames</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">=</span><span class="mi">1</span><span class="p">:</span><span class="nb">numel</span><span class="p">(</span><span class="n">fns</span><span class="p">)</span>
        <span class="n">fn</span><span class="p">=</span><span class="n">fns</span><span class="p">{</span><span class="n">k</span><span class="p">};</span>
        <span class="n">value</span><span class="p">=</span><span class="n">s</span><span class="p">.(</span><span class="n">fn</span><span class="p">);</span>
        <span class="k">if</span> <span class="n">ischar</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nb">numel</span><span class="p">(</span><span class="nb">size</span><span class="p">(</span><span class="n">value</span><span class="p">))</span><span class="o">==</span><span class="mi">3</span>
            <span class="n">s</span><span class="p">.(</span><span class="n">fn</span><span class="p">)=</span><span class="n">convert_3d_string_array_to_cellstr</span><span class="p">(</span><span class="n">value</span><span class="p">,</span><span class="n">dim</span><span class="p">);</span>
        <span class="k">end</span>
    <span class="k">end</span>

<span class="c">%%%%%%%%%%%%%%%%%%%%%%%%</span>
<span class="c">% CoSMoMVPA datasset</span>

<span class="c">% CoSMoMVPA dataset input</span>
<span class="c">% -----------------------</span>

<span class="k">function</span><span class="w"> </span>tf<span class="p">=</span><span class="nf">isa_cosmo_fmri</span><span class="p">(</span>ds<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">tf</span><span class="p">=</span><span class="n">cosmo_check_dataset</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span><span class="s">&#39;fmri&#39;</span><span class="p">,</span><span class="n">false</span><span class="p">);</span>

<span class="k">function</span><span class="w"> </span>ds<span class="p">=</span><span class="nf">read_cosmo_ds_header</span><span class="p">(</span>ds<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">ds</span><span class="p">=</span><span class="n">get_and_check_data</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span> <span class="p">[],</span> <span class="p">@</span><span class="n">isa_cosmo_fmri</span><span class="p">);</span>

<span class="k">function</span><span class="w"> </span>[ds, nsamples]<span class="p">=</span><span class="nf">convert_cosmo_ds_header</span><span class="p">(</span>ds, params<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">ds</span><span class="p">=</span><span class="n">get_and_check_data</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span> <span class="p">[],</span> <span class="p">@</span><span class="n">isa_cosmo_fmri</span><span class="p">);</span>
    <span class="n">nsamples</span><span class="p">=</span><span class="nb">size</span><span class="p">(</span><span class="n">ds</span><span class="p">.</span><span class="n">samples</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>

<span class="k">function</span><span class="w"> </span>ds<span class="p">=</span><span class="nf">convert_cosmo_ds_data</span><span class="p">(</span>ds, volumes<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">ds</span><span class="p">=</span><span class="n">slice_dataset_volumes</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span><span class="n">volumes</span><span class="p">);</span>
</pre></div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/cosmomvpa_logo.png" alt="Logo"/>
            </a></p>
  <h4>Previous topic</h4>
  <p class="topless"><a href="cosmo_fmri_convert_xform_skl.html"
                        title="previous chapter">cosmo fmri convert xform skl</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="cosmo_fmri_deoblique_skl.html"
                        title="next chapter">cosmo fmri deoblique skl</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/matlab/cosmo_fmri_dataset_skl.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="cosmo_fmri_deoblique_skl.html" title="cosmo fmri deoblique skl"
             >next</a> |</li>
        <li class="right" >
          <a href="cosmo_fmri_convert_xform_skl.html" title="cosmo fmri convert xform skl"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">CoSMoMVPA</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../documentation.html" >Documentation</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../cimec2016.html" >CIMeC hands-on methods course, part 1 (6 April-2 May 2016)</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="../matindex_skl.html" >CoSMoMVPA functions - skeleton files</a> &#187;</li> 
      </ul>
    </div>
      <div class="footer">
       <span class="creativecommons">
          <a href="http://opensource.org/licenses/MIT" >
          <img src="../_static/mit-license_logo.png"
               border="0" alt="Creative Commons License"/>
         </a> 
         
        <a href="copyright.html">Copyright 2013-2016 Nikolaas N. Oosterhof, Andrew C. Connolly, CoSMoMVPA contributors</a>.
        CoSMoMVPA is licensed under a <a href="http://opensource.org/licenses/MIT">Expat (MIT) License</a>.
       </span>
      </div>
  </body>
</html>

<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Demo: fMRI surface-based searchlights with LDA classifier</title><meta name="generator" content="MATLAB 8.5"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2016-12-01"><meta name="DC.source" content="demo_surface_searchlight_lda.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>Demo: fMRI surface-based searchlights with LDA classifier</h1><!--introduction--><p>The data used here is available from <a href="http://cosmomvpa.org/datadb.zip">http://cosmomvpa.org/datadb.zip</a></p><p>This example uses the following dataset: + 'digit'    A participant made finger pressed with the index and middle finger of    the right hand during 4 runs in an fMRI study. Each run was divided in    4 blocks with presses of each finger and analyzed with the GLM,    resulting in 2*4*4=32 t-values</p><p>The example shows four possible searchlight analyses, covering typical use cases:   1) single or twin surfaces      + Caret and BrainVoyager use a single surface; a parameter 'offsets'        is used to define which voxels are considered to be in the "grey        matter" (but this may be not so precise)      + FreeSurfer uses twin surfaces (pial and white), and voxels in        between or on them are considered to be in the grey matter   2) lower resolution output map      + in the canonical surface-based searchlight, each node on the input        surface(s) is assigned a measure value (accuracy, in this example)      + it is also possible to have output in a lower resolution version        than the input surfaces; this reduces both the execution time        (a Good Thing) and spatial precision (a Bad Thing). Two approaches        are illustrated to use a lower resolution surface for output:        1) from MapIcosahedron, with a lower value for the number of          divisions of the triangles        2) using a surface subsampling approach, implemented by           surfing_subsample_surface</p><p>In all cases a searchlight is run with a 100 voxel searchlight, using a disc for which the metric radius varies from node to node. For a fixed metric radius of the disc, use a positive value for 'radius' below. Distances are measured across the cortical surface using a geodesic distance metric.</p><p>This example requires the surfing toolbox, github.com/nno/surfing</p><p>This example may take quite some time to run. For faster execution, set ld=16 (instead of ld=64) below</p><p>If you use this code for a publication, please cite: Oosterhof, N.N., Wiestler, T, Downing, P.E., &amp; Diedrichsen, J. (2011) A comparison of volume-based and surface-based information mapping. Neuroimage. DOI:10.1016/j.neuroimage.2010.04.270</p><div><ol><li>For CoSMoMVPA's copyright information and license terms,   #</li><li>see the COPYING file distributed with CoSMoMVPA.           #</li></ol></div><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Check externals</a></li><li><a href="#2">Set data paths</a></li><li><a href="#4">Load functional data</a></li><li><a href="#5">Set partition scheme. odd_even is fast; for publication-quality analysis</a></li><li><a href="#6">Read inflated surface</a></li><li><a href="#7">Run four types of searchlights</a></li></ul></div><h2>Check externals<a name="1"></a></h2><pre class="codeinput">cosmo_check_external(<span class="string">'surfing'</span>);
</pre><h2>Set data paths<a name="2"></a></h2><p>The function cosmo_config() returns a struct containing paths to tutorial data. (Alternatively the paths can be set manually without using cosmo_config.)</p><pre class="codeinput">config=cosmo_config();

digit_study_path=fullfile(config.tutorial_data_path,<span class="string">'digit'</span>);
readme_fn=fullfile(digit_study_path,<span class="string">'README'</span>);
cosmo_type(readme_fn);

output_path=config.output_data_path;

<span class="comment">% reset citation list</span>
cosmo_check_external(<span class="string">'-tic'</span>);

<span class="comment">% resolution parameter for input surfaces</span>
<span class="comment">% 64 is for high-quality results; use 16 for fast execution</span>
ld=64;

<span class="comment">% Twin surface case (FS)</span>
pial_fn=fullfile(digit_study_path,<span class="keyword">...</span>
                            sprintf(<span class="string">'ico%d_mh.pial_al.asc'</span>, ld));
white_fn=fullfile(digit_study_path,<span class="keyword">...</span>
                            sprintf(<span class="string">'ico%d_mh.smoothwm_al.asc'</span>, ld));

<span class="comment">% Single surface case (Caret/BV)</span>
intermediate_fn=fullfile(digit_study_path,<span class="keyword">...</span>
                            sprintf(<span class="string">'ico%d_mh.intermediate_al.asc'</span>, ld));

<span class="comment">% Used for visualization</span>
inflated_fn=fullfile(digit_study_path,<span class="keyword">...</span>
                         sprintf(<span class="string">'ico%d_mh.inflated_alCoMmedial.asc'</span>, ld));
</pre><pre class="codeoutput">Overview
--------
fMRI responses to a human participant pressing buttons with the index and middle finger.

Contents
--------
- glm_T_stats_allruns+orig.{BRIK,HEAD}: 
    t-statistics associated with finger presses. 
    There are 4 runs, each with 4 blocks. 
    Each block has two t-statistics, one for each of button presses for the 
index and middle finger (in that order). 
- epi+orig.{HEAD,BRIK}:
    A single EPI image.
- icoXX_mh.YY.asc:
    Surface anatomy meshes of two hemispheres with standard topology, generated 
    using AFNI SUMA's MapIcosahedron. Left and right hemisphere surfaces were
    merged in the order left, right; the first half of the nodes and faces refer 
    to the left hemisphere, the second half to the right hemisphere.
    XX={16,64} is the number of linear divisions of MapIcosahedron; surfaces
    have (XX^2)*10+2 nodes and XX^2*20 faces in each hemisphere.
    YY={pial_al,white_al} are the outer and inner surfaces around the grey matter
    generated by FreeSurfer. YY=intermediate_al is the node-wise average of the
    pial and white surfaces; this surface can be used for single-surface
    analyses when surfaces are generated using Caret or BrainVoyager
    YY=inflated_alCoMmedial are inflated surfaces with the center of mass
    along the medial side of the two hemispheres. These surfaces are suitable
    for visualization purposes.

Methods
-------
This dataset contains data from a fingerpress experiment where a participant 
(28y right-handed male) pressed buttons on a box with the index and middle 
finger of the right  hand while fMRI volumes were acquired. Over four runs, in 
total sixteen blocks of 72s finger presses were acquired; in each block the 
participant pressed the index and middle finger during different `mini-blocks' 
of 8 s each. Each block was preceded and followed by a 16s rest period. 
Functional data was preprocessed in AFNI with despiking, time slice correction, 
motion correction, and scaling to percent signal change by dividing the signal 
for each volume by the mean of the run. No spatial smoothing or interpolation 
was applied to the functional data, except for interpolation during motion 
correction. The preprocessed data was analyzed with a general linear model 
(GLM) with separate regressors for each finger and each block (and some 
regressors of no interest) to obtain t-values for each finger in each block. 

License
-------
The contents are made available by Nikolaas N. Oosterhof &lt;nikolaas.oosterhof 
|at| unitn.it&gt; under the Creative Commons CC0 1.0 Universal Public Domain 
Dedication ("CC0"). See the LICENSE file for details, or visit 
http://creativecommons.org/publicdomain/zero/1.0/deed.en.

Contact
-------
Nikolaas N. Oosterhof &lt;nikolaas.oosterhof |at| unitn.it&gt;


</pre><p>Set parameters</p><pre class="codeinput"><span class="comment">% Searchlight radius: select 100 features in each searchlight</span>
<span class="comment">% (to use a fixed radius of 8mm, use:</span>
<span class="comment">%    cosmo_surficial_neighborhood(...,'radius',8)</span>
<span class="comment">% in the code below)</span>

feature_count=100;

<span class="comment">% Single surface case: select voxels that are 3 mm or closer to the surface</span>
<span class="comment">% on the white-matter side, up to voxels that are 2 mm from the surface on</span>
<span class="comment">% the pial matter side</span>
single_surf_offsets=[-2 3];

<span class="comment">% Single surface case: number of iterations to downsample surface</span>
lowres_output_onesurf_niter=10;

<span class="comment">% Twin surface case: number of linear divisions from MapIcosahedron</span>
lowres_output_twosurf_icold=16;
lowres_intermediate_fn=fullfile(digit_study_path,<span class="keyword">...</span>
                                sprintf(<span class="string">'ico%d_mh.intermediate_al.asc'</span>,<span class="keyword">...</span>
                                        lowres_output_twosurf_icold));


<span class="comment">% Use the cosmo_cross_validation_measure and set its parameters</span>
<span class="comment">% (classifier and partitions) in a measure_args struct.</span>
measure = @cosmo_crossvalidation_measure;
measure_args = struct();

<span class="comment">% Define which classifier to use, using a function handle.</span>
<span class="comment">% Alternatives are @cosmo_classify_{svm,nn,naive_bayes}</span>
measure_args.classifier = @cosmo_classify_lda;
</pre><h2>Load functional data<a name="4"></a></h2><pre class="codeinput">data_path=digit_study_path;
data_fn=fullfile(data_path,<span class="string">'glm_T_stats_perblock+orig'</span>);

targets=repmat(1:2,1,16)';    <span class="comment">% class labels: 1 2 1 2 1 2 1 2 1 2 ... 1 2</span>
chunks=floor(((1:32)-1)/8)+1; <span class="comment">% run labels:   1 1 1 1 1 1 1 1 2 2 ... 4 4</span>

ds = cosmo_fmri_dataset(data_fn,<span class="string">'targets'</span>,targets,<span class="string">'chunks'</span>,chunks);

<span class="comment">% remove zero elements</span>
zero_msk=all(ds.samples==0,1);
ds = cosmo_slice(ds, ~zero_msk, 2);

fprintf(<span class="string">'Dataset has %d samples and %d features\n'</span>, size(ds.samples));

<span class="comment">% print dataset</span>
fprintf(<span class="string">'Dataset input:\n'</span>);
cosmo_disp(ds);
</pre><pre class="codeoutput">Dataset has 32 samples and 168097 features
Dataset input:
.sa                                                                       
  .labels                                                                 
    { 'fi_i_R1_B01#0_Tstat'                                               
      'fi_m_R1_B01#0_Tstat'                                               
      'fi_i_R1_B02#0_Tstat'                                               
               :                                                          
      'fi_m_R4_B03#0_Tstat'                                               
      'fi_i_R4_B04#0_Tstat'                                               
      'fi_m_R4_B04#0_Tstat' }@32x1                                        
  .stats                                                                  
    { 'Ttest(168)'                                                        
      'Ttest(168)'                                                        
      'Ttest(168)'                                                        
           :                                                              
      'Ttest(168)'                                                        
      'Ttest(168)'                                                        
      'Ttest(168)' }@32x1                                                 
  .targets                                                                
    [ 1                                                                   
      2                                                                   
      1                                                                   
      :                                                                   
      2                                                                   
      1                                                                   
      2 ]@32x1                                                            
  .chunks                                                                 
    [ 1                                                                   
      1                                                                   
      1                                                                   
      :                                                                   
      4                                                                   
      4                                                                   
      4 ]@32x1                                                            
.a                                                                        
  .vol                                                                    
    .mat                                                                  
      [ -2.5         0         0      71.2                                
           0      -2.5         0       112                                
           0         0       2.5        43                                
           0         0         0         1 ]                              
    .dim                                                                  
      [ 61        84        41 ]                                          
    .xform                                                                
      'scanner_anat'                                                      
  .fdim                                                                   
    .labels                                                               
      { 'i'                                                               
        'j'                                                               
        'k' }                                                             
    .values                                                               
      { [ 1         2         3  ...  59        60        61 ]@1x61       
        [ 1         2         3  ...  82        83        84 ]@1x84       
        [ 1         2         3  ...  39        40        41 ]@1x41 }     
.samples                                                                  
  [     0         0         0  ...  -0.878     0.178      4.66            
        0         0         0  ...    2.48      -0.3      1.12            
        0         0         0  ...   -1.05    -0.707      1.04            
      :         :         :            :         :         :              
    -2.21    -0.243    -0.377  ...   -1.59         1     0.987            
    -1.97      1.06     0.673  ...   -1.23      1.41     0.999            
     -4.5      1.16      1.53  ...    1.86     -1.31     0.405 ]@32x168097
.fa                                                                       
  .i                                                                      
    [ 1         2         3  ...  59        60        61 ]@1x168097       
  .j                                                                      
    [ 1         1         1  ...  84        84        84 ]@1x168097       
  .k                                                                      
    [ 3         3         3  ...  36        36        36 ]@1x168097       
</pre><h2>Set partition scheme. odd_even is fast; for publication-quality analysis<a name="5"></a></h2><p>nfold_partitioner is recommended. Alternatives are: - cosmo_nfold_partitioner    (take-one-chunk-out crossvalidation) - cosmo_nchoosek_partitioner (take-K-chunks-out  "             ").</p><pre class="codeinput">measure_args.partitions = cosmo_oddeven_partitioner(ds);

<span class="comment">% print measure and arguments</span>
fprintf(<span class="string">'Searchlight measure:\n'</span>);
cosmo_disp(measure);
fprintf(<span class="string">'Searchlight measure arguments:\n'</span>);
cosmo_disp(measure_args);
</pre><pre class="codeoutput">Searchlight measure:
@cosmo_c ... measure
Searchlight measure arguments:
.classifier                     
  @cosmo_classify_lda           
.partitions                     
  .train_indices                
    { [  1         [  9         
         2           10         
         3           11         
         :            :         
        22           30         
        23           31         
        24 ]@16x1    32 ]@16x1 }
  .test_indices                 
    { [  9         [  1         
        10            2         
        11            3         
         :            :         
        30           22         
        31           23         
        32 ]@16x1    24 ]@16x1 }
</pre><h2>Read inflated surface<a name="6"></a></h2><pre class="codeinput">[v_inf,f_inf]=surfing_read(inflated_fn);
fprintf(<span class="string">'The inflated surface has %d vertices, %d faces\n'</span>,<span class="keyword">...</span>
            size(v_inf,1), size(f_inf,1))
</pre><pre class="codeoutput">The inflated surface has 81924 vertices, 163840 faces
</pre><h2>Run four types of searchlights<a name="7"></a></h2><pre class="codeinput"><span class="keyword">for</span> one_surf=[true,false]
    <span class="keyword">if</span> one_surf
        desc=<span class="string">'1surf'</span>;
    <span class="keyword">else</span>
        desc=<span class="string">'2surfs'</span>;
    <span class="keyword">end</span>

    <span class="keyword">for</span> lowres_output=[false,true]
        <span class="keyword">if</span> lowres_output
            desc=sprintf(<span class="string">'%s_lowres'</span>, desc);
        <span class="keyword">end</span>
        fprintf(<span class="string">'\n\n *** Starting analysis with %s *** \n\n\n'</span>, desc)

        <span class="comment">% define searchlight surface paramters for each type of analysis</span>
        <span class="keyword">if</span> one_surf &amp;&amp; lowres_output

            <span class="comment">% single surface (Caret/BV) with lower-res output</span>
            surf_def={intermediate_fn,single_surf_offsets,<span class="keyword">...</span>
                            lowres_output_onesurf_niter};

        <span class="keyword">elseif</span> one_surf &amp;&amp; ~lowres_output

            <span class="comment">% single surface (Caret/BV) with original-res output</span>
            surf_def={intermediate_fn,single_surf_offsets};

        <span class="keyword">elseif</span> ~one_surf &amp;&amp; lowres_output

            <span class="comment">% single surface (FS) with lower-res output</span>
            surf_def={white_fn,pial_fn,lowres_intermediate_fn};

        <span class="keyword">elseif</span> ~one_surf &amp;&amp; ~lowres_output

            <span class="comment">% single surface (FS) with original-res output</span>
            surf_def={white_fn,pial_fn};

        <span class="keyword">else</span>
            assert(false); <span class="comment">% should never get here</span>
        <span class="keyword">end</span>

        <span class="comment">% Define the feature neighborhood for each node on the surface</span>
        <span class="comment">% - nbrhood has the neighborhood information</span>
        <span class="comment">% - vo and fo are vertices and faces of the output surface</span>
        <span class="comment">% - out2in is the mapping from output to input surface</span>
        fprintf(<span class="string">'Defining neighborhood with %s\n'</span>, desc);
        [nbrhood,vo,fo,out2in]=cosmo_surficial_neighborhood(ds,surf_def,<span class="keyword">...</span>
                                                    <span class="string">'count'</span>,feature_count);

        <span class="comment">% print neighborhood</span>
        fprintf(<span class="string">'Searchlight neighborhood definition:\n'</span>);
        cosmo_disp(nbrhood);


        fprintf(<span class="string">'The output surface has %d vertices, %d nodes\n'</span>,<span class="keyword">...</span>
                        size(vo,1), size(fo,1));



        <span class="comment">% Run the searchlight</span>
        lda_results = cosmo_searchlight(ds,nbrhood,measure,measure_args);


        <span class="comment">% print searchlight output</span>
        fprintf(<span class="string">'Dataset output:\n'</span>);
        cosmo_disp(lda_results);

        <span class="comment">% Apply the node mapping from the surifical neighborhood</span>
        <span class="comment">% to the high-res inflated surface.</span>
        <span class="comment">% (This example shows how such a mapping can be applied to new</span>
        <span class="comment">% surfaces)</span>
        <span class="keyword">if</span> lowres_output
            v_inf_out=v_inf(out2in,:);
            f_inf_out=fo;
        <span class="keyword">else</span>
            v_inf_out=v_inf;
            f_inf_out=f_inf;
        <span class="keyword">end</span>

        <span class="comment">% visualize the surfaces, if the afni matlab toolbox is present</span>
        <span class="keyword">if</span> cosmo_check_external(<span class="string">'afni'</span>,false)
            nvertices=size(v_inf_out,1);

            opt=struct();

            <span class="keyword">for</span> show_edge=[false, true]
                opt.ShowEdge=show_edge;

                <span class="keyword">if</span> show_edge
                    t=<span class="string">'with edges'</span>;
                <span class="keyword">else</span>
                    t=<span class="string">'without edges'</span>;
                <span class="keyword">end</span>

                header=strrep([desc <span class="string">' '</span> t],<span class="string">'_'</span>,<span class="string">' '</span>);


                DispIVSurf(vo,fo,1:nvertices,lda_results.samples',0,opt);
                title(sprintf(<span class="string">'Original %s'</span>, header));

                DispIVSurf(v_inf_out,f_inf_out,1:nvertices,<span class="keyword">...</span>
                                        lda_results.samples',0,opt);
                title(sprintf(<span class="string">'Inflated %s'</span>, header));
            <span class="keyword">end</span>
        <span class="keyword">else</span>
            fprintf(<span class="string">'skip surface display; no afni matlab toolbox\n'</span>);
        <span class="keyword">end</span>

        <span class="keyword">if</span> lowres_output &amp;&amp; one_surf
            <span class="comment">% in this example only this case a new surface was generated.</span>
            <span class="comment">% To aid visualization using external tools, store it to disc.</span>

            <span class="comment">% The surface is stored in ASCII, GIFTI and BV SRF</span>
            <span class="comment">% formats, if the required externals are present</span>
            surf_output_fn=fullfile(output_path,[<span class="string">'inflated_'</span> desc]);

            <span class="comment">% AFNI/SUMA ASC</span>
            surfing_write([surf_output_fn <span class="string">'.asc'</span>],v_inf_out,f_inf_out);

            <span class="comment">% BV SRF</span>
            <span class="keyword">if</span> cosmo_check_external(<span class="string">'neuroelf'</span>,false)
                surfing_write([surf_output_fn <span class="string">'.srf'</span>],v_inf_out,f_inf_out);
            <span class="keyword">end</span>

            <span class="comment">% GIFTI</span>
            <span class="keyword">if</span> cosmo_check_external(<span class="string">'gifti'</span>,false)
                surfing_write([surf_output_fn <span class="string">'.gii'</span>],v_inf_out,f_inf_out);
            <span class="keyword">end</span>
        <span class="keyword">end</span>

        <span class="comment">% store searchlight results</span>
        data_output_fn=fullfile(output_path,[<span class="string">'lda_'</span> desc]);

        <span class="keyword">if</span> cosmo_check_external(<span class="string">'afni'</span>,false)
            cosmo_map2surface(lda_results, [data_output_fn <span class="string">'.niml.dset'</span>]);
        <span class="keyword">end</span>

        <span class="keyword">if</span> cosmo_check_external(<span class="string">'neuroelf'</span>,false)
            cosmo_map2surface(lda_results, [data_output_fn <span class="string">'.smp'</span>]);
        <span class="keyword">end</span>

        <span class="comment">% store voxel counts (how often each voxel is in a neighborhood)</span>
        <span class="comment">% take a random sample (the first one) from the input dataset</span>
        <span class="comment">% and count how often each voxel was selected.</span>
        <span class="comment">% If everything works, then voxels in the grey matter have high</span>
        <span class="comment">% voxel counts but voxels outside it low or zero counts.</span>
        <span class="comment">% Thus, this can be used as a sanity check that can be visualized</span>
        <span class="comment">% easily.</span>

        vox_count_ds=cosmo_slice(ds,1);
        vox_count_ds.samples(:)=0;

        ncenters=numel(nbrhood.neighbors);
        <span class="keyword">for</span> k=1:ncenters
            idxs=nbrhood.neighbors{k}; <span class="comment">% feature indices in neigborhood</span>
            vox_count_ds.samples(idxs)=vox_count_ds.samples(idxs)+1;
        <span class="keyword">end</span>

        vox_count_output_fn=fullfile(output_path,[<span class="string">'vox_count_'</span> desc]);

        <span class="comment">% store voxel count results</span>
        cosmo_map2fmri(vox_count_ds, [vox_count_output_fn <span class="string">'.nii'</span>]);

        <span class="keyword">if</span> cosmo_check_external(<span class="string">'afni'</span>,false)
            cosmo_map2fmri(vox_count_ds, [vox_count_output_fn <span class="string">'+orig'</span>]);
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">% Show citation information</span>
cosmo_check_external(<span class="string">'-cite'</span>);
</pre><pre class="codeoutput">

 *** Starting analysis with 1surf *** 


Defining neighborhood with 1surf
Warning: found 14674 / 81924 center nodes outside the volume, these will be
ignored. 
Using 168097 / 210084 voxels in functional volume mask
+00:14:00 [####################] -00:00:00  r=8.07, 100.0 vox
Searchlight neighborhood definition:
.a                                                                                     
  .fdim                                                                                
    .labels                                                                            
      { 'node_indices' }                                                               
    .values                                                                            
      { [ 1         2         3  ...  8.19e+04  8.19e+04  8.19e+04 ]@1x81924 }         
.fa                                                                                    
  .node_indices                                                                        
    [ 1         2         3  ...  8.19e+04  8.19e+04  8.19e+04 ]@1x81924               
.neighbors                                                                             
  { [  ]                                                                               
    [ 1.13e+05  1.13e+05  1.13e+05  ...  1.34e+05  1.34e+05  1.34e+05 ]@1x99           
    [ 1.05e+05   1.1e+05   1.1e+05  ...  1.35e+05  1.35e+05   1.4e+05 ]@1x99           
                                       :                                               
    [ 1.67e+04  1.68e+04  1.68e+04  ...  4.25e+04  4.25e+04  4.26e+04 ]@1x100          
    [ 1.68e+04  1.68e+04  1.68e+04  ...  4.25e+04  4.26e+04  4.26e+04 ]@1x100          
    [ 1.67e+04  1.67e+04  1.68e+04  ...  4.25e+04  4.25e+04  4.25e+04 ]@1x100 }@81924x1
.origin                                                                                
  .a                                                                                   
    .vol                                                                               
      .mat                                                                             
        [ -2.5         0         0      71.2                                           
             0      -2.5         0       112                                           
             0         0       2.5        43                                           
             0         0         0         1 ]                                         
      .dim                                                                             
        [ 61        84        41 ]                                                     
      .xform                                                                           
        'scanner_anat'                                                                 
    .fdim                                                                              
      .labels                                                                          
        { 'i'                                                                          
          'j'                                                                          
          'k' }                                                                        
      .values                                                                          
        { [ 1         2         3  ...  59        60        61 ]@1x61                  
          [ 1         2         3  ...  82        83        84 ]@1x84                  
          [ 1         2         3  ...  39        40        41 ]@1x41 }                
  .fa                                                                                  
    .i                                                                                 
      [ 1         2         3  ...  59        60        61 ]@1x168097                  
    .j                                                                                 
      [ 1         1         1  ...  84        84        84 ]@1x168097                  
    .k                                                                                 
      [ 3         3         3  ...  36        36        36 ]@1x168097                  
The output surface has 81924 vertices, 163840 nodes
+00:05:33 [####################] -00:00:00  
Dataset output:
.a                                                                            
  .fdim                                                                       
    .labels                                                                   
      { 'node_indices' }                                                      
    .values                                                                   
      { [ 1         2         3  ...  8.19e+04  8.19e+04  8.19e+04 ]@1x81924 }
.fa                                                                           
  .node_indices                                                               
    [ 1         2         3  ...  8.19e+04  8.19e+04  8.19e+04 ]@1x81924      
  .center_ids                                                                 
    [ 1         2         3  ...  8.19e+04  8.19e+04  8.19e+04 ]@1x81924      
.samples                                                                      
  [ 0.5     0.562     0.719  ...  0.594     0.625     0.656 ]@1x81924         
.sa                                                                           
  .labels                                                                     
    { 'accuracy' }                                                            
DispIVSurf verbose: z-buffer mode.
DispIVSurf verbose: Scaling ITvect to fit colormap
DispIVSurf verbose: Set hold to off
DispIVSurf verbose: Drawing Patches
DispIVSurf verbose: Applied interp for Shade.
DispIVSurf verbose: Set Edgecolor to none
DispIVSurf verbose: Set view to 2D
DispIVSurf verbose: Displaying colormap
DispIVSurf verbose: Seting Axes properties
DispIVSurf verbose: Done
DispIVSurf verbose: z-buffer mode.
DispIVSurf verbose: Scaling ITvect to fit colormap
DispIVSurf verbose: Set hold to off
DispIVSurf verbose: Drawing Patches
DispIVSurf verbose: Applied interp for Shade.
DispIVSurf verbose: Set Edgecolor to none
DispIVSurf verbose: Set view to 2D
DispIVSurf verbose: Displaying colormap
DispIVSurf verbose: Seting Axes properties
DispIVSurf verbose: Done
DispIVSurf verbose: z-buffer mode.
DispIVSurf verbose: Scaling ITvect to fit colormap
DispIVSurf verbose: Set hold to off
DispIVSurf verbose: Drawing Patches
DispIVSurf verbose: Applied interp for Shade.
DispIVSurf verbose: Set Edgecolor to black
DispIVSurf verbose: Set view to 2D
DispIVSurf verbose: Displaying colormap
DispIVSurf verbose: Seting Axes properties
DispIVSurf verbose: Done
DispIVSurf verbose: z-buffer mode.
DispIVSurf verbose: Scaling ITvect to fit colormap
DispIVSurf verbose: Set hold to off
DispIVSurf verbose: Drawing Patches
DispIVSurf verbose: Applied interp for Shade.
DispIVSurf verbose: Set Edgecolor to black
DispIVSurf verbose: Set view to 2D
DispIVSurf verbose: Displaying colormap
DispIVSurf verbose: Seting Axes properties
DispIVSurf verbose: Done


 *** Starting analysis with 1surf_lowres *** 


Defining neighborhood with 1surf_lowres
+00:00:11 [####################] -00:00:00  100.0% simple nodes
+00:00:09 [####################] -00:00:00  81924 nodes: 16.6% removed
+00:00:08 [####################] -00:00:00  100.0% simple nodes
+00:00:04 [####################] -00:00:00  68312 nodes: 17.1% removed
+00:00:07 [####################] -00:00:00  100.0% simple nodes
+00:00:03 [####################] -00:00:00  56620 nodes: 15.3% removed
+00:00:06 [####################] -00:00:00  100.0% simple nodes
+00:00:03 [####################] -00:00:00  47949 nodes: 16.7% removed
+00:00:06 [####################] -00:00:00  100.0% simple nodes
+00:00:02 [####################] -00:00:00  39921 nodes: 16.1% removed
+00:00:09 [####################] -00:00:00  100.0% simple nodes
+00:00:03 [####################] -00:00:00  33486 nodes: 16.0% removed
+00:00:04 [####################] -00:00:00  100.0% simple nodes
+00:00:02 [####################] -00:00:00  28127 nodes: 15.6% removed
+00:00:03 [####################] -00:00:00  100.0% simple nodes
+00:00:01 [####################] -00:00:00  23746 nodes: 15.8% removed
+00:00:02 [####################] -00:00:00  100.0% simple nodes
+00:00:01 [####################] -00:00:00  19995 nodes: 15.6% removed
+00:00:02 [####################] -00:00:00  100.0% simple nodes
+00:00:01 [####################] -00:00:00  16872 nodes: 15.5% removed
+00:00:16 [####################] -00:00:00  81924 -&gt; 14257 nodes
Warning: found 2572 / 14257 center nodes outside the volume, these will be
ignored. 
Using 168097 / 210084 voxels in functional volume mask
+00:02:01 [####################] -00:00:00  r=8.08, 100.0 vox
Searchlight neighborhood definition:
.a                                                                                     
  .fdim                                                                                
    .labels                                                                            
      { 'node_indices' }                                                               
    .values                                                                            
      { [ 1         2         3  ...  1.43e+04  1.43e+04  1.43e+04 ]@1x14257 }         
.fa                                                                                    
  .node_indices                                                                        
    [ 1         2         3  ...  1.43e+04  1.43e+04  1.43e+04 ]@1x14257               
.neighbors                                                                             
  { [ 904       905       965  ...  2.02e+04  2.03e+04  2.03e+04 ]@1x100               
    [ 1.03e+03  1.03e+03  1.03e+03  ...  2.53e+04  2.53e+04  2.53e+04 ]@1x100          
    [  ]                                                                               
                                       :                                               
    [ 2.19e+04  2.19e+04   2.2e+04  ...  4.26e+04  4.27e+04  4.78e+04 ]@1x101          
    [ 1.68e+04  1.69e+04  1.69e+04  ...  4.25e+04  4.26e+04  4.26e+04 ]@1x100          
    [ 1.68e+04  1.68e+04  1.68e+04  ...  4.25e+04  4.26e+04  4.26e+04 ]@1x100 }@14257x1
.origin                                                                                
  .a                                                                                   
    .vol                                                                               
      .mat                                                                             
        [ -2.5         0         0      71.2                                           
             0      -2.5         0       112                                           
             0         0       2.5        43                                           
             0         0         0         1 ]                                         
      .dim                                                                             
        [ 61        84        41 ]                                                     
      .xform                                                                           
        'scanner_anat'                                                                 
    .fdim                                                                              
      .labels                                                                          
        { 'i'                                                                          
          'j'                                                                          
          'k' }                                                                        
      .values                                                                          
        { [ 1         2         3  ...  59        60        61 ]@1x61                  
          [ 1         2         3  ...  82        83        84 ]@1x84                  
          [ 1         2         3  ...  39        40        41 ]@1x41 }                
  .fa                                                                                  
    .i                                                                                 
      [ 1         2         3  ...  59        60        61 ]@1x168097                  
    .j                                                                                 
      [ 1         1         1  ...  84        84        84 ]@1x168097                  
    .k                                                                                 
      [ 3         3         3  ...  36        36        36 ]@1x168097                  
The output surface has 14257 vertices, 28506 nodes
+00:00:50 [####################] -00:00:00  
Dataset output:
.a                                                                            
  .fdim                                                                       
    .labels                                                                   
      { 'node_indices' }                                                      
    .values                                                                   
      { [ 1         2         3  ...  1.43e+04  1.43e+04  1.43e+04 ]@1x14257 }
.fa                                                                           
  .node_indices                                                               
    [ 1         2         3  ...  1.43e+04  1.43e+04  1.43e+04 ]@1x14257      
  .center_ids                                                                 
    [ 1         2         3  ...  1.43e+04  1.43e+04  1.43e+04 ]@1x14257      
.samples                                                                      
  [ 0.5       0.5       0.5  ...  0.594     0.625     0.625 ]@1x14257         
.sa                                                                           
  .labels                                                                     
    { 'accuracy' }                                                            
DispIVSurf verbose: z-buffer mode.
DispIVSurf verbose: Scaling ITvect to fit colormap
DispIVSurf verbose: Set hold to off
DispIVSurf verbose: Drawing Patches
DispIVSurf verbose: Applied interp for Shade.
DispIVSurf verbose: Set Edgecolor to none
DispIVSurf verbose: Set view to 2D
DispIVSurf verbose: Displaying colormap
DispIVSurf verbose: Seting Axes properties
DispIVSurf verbose: Done
DispIVSurf verbose: z-buffer mode.
DispIVSurf verbose: Scaling ITvect to fit colormap
DispIVSurf verbose: Set hold to off
DispIVSurf verbose: Drawing Patches
DispIVSurf verbose: Applied interp for Shade.
DispIVSurf verbose: Set Edgecolor to none
DispIVSurf verbose: Set view to 2D
DispIVSurf verbose: Displaying colormap
DispIVSurf verbose: Seting Axes properties
DispIVSurf verbose: Done
DispIVSurf verbose: z-buffer mode.
DispIVSurf verbose: Scaling ITvect to fit colormap
DispIVSurf verbose: Set hold to off
DispIVSurf verbose: Drawing Patches
DispIVSurf verbose: Applied interp for Shade.
DispIVSurf verbose: Set Edgecolor to black
DispIVSurf verbose: Set view to 2D
DispIVSurf verbose: Displaying colormap
DispIVSurf verbose: Seting Axes properties
DispIVSurf verbose: Done
DispIVSurf verbose: z-buffer mode.
DispIVSurf verbose: Scaling ITvect to fit colormap
DispIVSurf verbose: Set hold to off
DispIVSurf verbose: Drawing Patches
DispIVSurf verbose: Applied interp for Shade.
DispIVSurf verbose: Set Edgecolor to black
DispIVSurf verbose: Set view to 2D
DispIVSurf verbose: Displaying colormap
DispIVSurf verbose: Seting Axes properties
DispIVSurf verbose: Done


 *** Starting analysis with 2surfs *** 


Defining neighborhood with 2surfs
Warning: found 14674 / 81924 center nodes outside the volume, these will be
ignored. 
Using 168097 / 210084 voxels in functional volume mask
+00:20:10 [####################] -00:00:00  r=10.11, 100.0 vox
Searchlight neighborhood definition:
.a                                                                                     
  .fdim                                                                                
    .labels                                                                            
      { 'node_indices' }                                                               
    .values                                                                            
      { [ 1         2         3  ...  8.19e+04  8.19e+04  8.19e+04 ]@1x81924 }         
.fa                                                                                    
  .node_indices                                                                        
    [ 1         2         3  ...  8.19e+04  8.19e+04  8.19e+04 ]@1x81924               
.neighbors                                                                             
  { [  ]                                                                               
    [ 1.08e+05  1.08e+05  1.08e+05  ...  1.34e+05  1.34e+05  1.34e+05 ]@1x100          
    [ 1.05e+05  1.05e+05  1.05e+05  ...  1.4e+05   1.4e+05  1.41e+05 ]@1x100           
                                       :                                               
    [ 1.17e+04  1.17e+04  1.18e+04  ...  3.75e+04  4.26e+04  4.26e+04 ]@1x99           
    [ 1.67e+04  1.67e+04  1.67e+04  ...  4.26e+04  4.26e+04  4.26e+04 ]@1x100          
    [ 1.17e+04  1.17e+04  1.67e+04  ...  3.75e+04  4.26e+04  4.26e+04 ]@1x100 }@81924x1
.origin                                                                                
  .a                                                                                   
    .vol                                                                               
      .mat                                                                             
        [ -2.5         0         0      71.2                                           
             0      -2.5         0       112                                           
             0         0       2.5        43                                           
             0         0         0         1 ]                                         
      .dim                                                                             
        [ 61        84        41 ]                                                     
      .xform                                                                           
        'scanner_anat'                                                                 
    .fdim                                                                              
      .labels                                                                          
        { 'i'                                                                          
          'j'                                                                          
          'k' }                                                                        
      .values                                                                          
        { [ 1         2         3  ...  59        60        61 ]@1x61                  
          [ 1         2         3  ...  82        83        84 ]@1x84                  
          [ 1         2         3  ...  39        40        41 ]@1x41 }                
  .fa                                                                                  
    .i                                                                                 
      [ 1         2         3  ...  59        60        61 ]@1x168097                  
    .j                                                                                 
      [ 1         1         1  ...  84        84        84 ]@1x168097                  
    .k                                                                                 
      [ 3         3         3  ...  36        36        36 ]@1x168097                  
The output surface has 81924 vertices, 163840 nodes
+00:06:50 [####################] -00:00:00  
Dataset output:
.a                                                                            
  .fdim                                                                       
    .labels                                                                   
      { 'node_indices' }                                                      
    .values                                                                   
      { [ 1         2         3  ...  8.19e+04  8.19e+04  8.19e+04 ]@1x81924 }
.fa                                                                           
  .node_indices                                                               
    [ 1         2         3  ...  8.19e+04  8.19e+04  8.19e+04 ]@1x81924      
  .center_ids                                                                 
    [ 1         2         3  ...  8.19e+04  8.19e+04  8.19e+04 ]@1x81924      
.samples                                                                      
  [ 0.5       0.5     0.656  ...  0.656     0.594     0.625 ]@1x81924         
.sa                                                                           
  .labels                                                                     
    { 'accuracy' }                                                            
DispIVSurf verbose: z-buffer mode.
DispIVSurf verbose: Scaling ITvect to fit colormap
DispIVSurf verbose: Set hold to off
DispIVSurf verbose: Drawing Patches
DispIVSurf verbose: Applied interp for Shade.
DispIVSurf verbose: Set Edgecolor to none
DispIVSurf verbose: Set view to 2D
DispIVSurf verbose: Displaying colormap
DispIVSurf verbose: Seting Axes properties
DispIVSurf verbose: Done
DispIVSurf verbose: z-buffer mode.
DispIVSurf verbose: Scaling ITvect to fit colormap
DispIVSurf verbose: Set hold to off
DispIVSurf verbose: Drawing Patches
DispIVSurf verbose: Applied interp for Shade.
DispIVSurf verbose: Set Edgecolor to none
DispIVSurf verbose: Set view to 2D
DispIVSurf verbose: Displaying colormap
DispIVSurf verbose: Seting Axes properties
DispIVSurf verbose: Done
DispIVSurf verbose: z-buffer mode.
DispIVSurf verbose: Scaling ITvect to fit colormap
DispIVSurf verbose: Set hold to off
DispIVSurf verbose: Drawing Patches
DispIVSurf verbose: Applied interp for Shade.
DispIVSurf verbose: Set Edgecolor to black
DispIVSurf verbose: Set view to 2D
DispIVSurf verbose: Displaying colormap
DispIVSurf verbose: Seting Axes properties
DispIVSurf verbose: Done
DispIVSurf verbose: z-buffer mode.
DispIVSurf verbose: Scaling ITvect to fit colormap
DispIVSurf verbose: Set hold to off
DispIVSurf verbose: Drawing Patches
DispIVSurf verbose: Applied interp for Shade.
DispIVSurf verbose: Set Edgecolor to black
DispIVSurf verbose: Set view to 2D
DispIVSurf verbose: Displaying colormap
DispIVSurf verbose: Seting Axes properties
DispIVSurf verbose: Done


 *** Starting analysis with 2surfs_lowres *** 


Defining neighborhood with 2surfs_lowres
+00:00:10 [####################] -00:00:00  81924 -&gt; 5124 nodes
Warning: found 911 / 5124 center nodes outside the volume, these will be
ignored. 
Using 168097 / 210084 voxels in functional volume mask
+00:01:31 [####################] -00:00:00  r=10.12, 100.0 vox
Searchlight neighborhood definition:
.a                                                                                    
  .fdim                                                                               
    .labels                                                                           
      { 'node_indices' }                                                              
    .values                                                                           
      { [ 1         2         3  ...  5.12e+03  5.12e+03  5.12e+03 ]@1x5124 }         
.fa                                                                                   
  .node_indices                                                                       
    [ 1         2         3  ...  5.12e+03  5.12e+03  5.12e+03 ]@1x5124               
.neighbors                                                                            
  { [  ]                                                                              
    [ 1.08e+05  1.08e+05  1.08e+05  ...  1.34e+05  1.34e+05  1.34e+05 ]@1x100         
    [ 1.05e+05  1.05e+05  1.05e+05  ...  1.4e+05   1.4e+05  1.41e+05 ]@1x100          
                                       :                                              
    [ 1.18e+04  1.18e+04  1.18e+04  ...  3.75e+04  3.75e+04  3.76e+04 ]@1x100         
    [ 2.71e+04  2.71e+04  2.72e+04  ...  4.28e+04  4.28e+04  4.28e+04 ]@1x100         
    [ 1.68e+04  1.69e+04  1.69e+04  ...  4.26e+04  4.26e+04  4.27e+04 ]@1x100 }@5124x1
.origin                                                                               
  .a                                                                                  
    .vol                                                                              
      .mat                                                                            
        [ -2.5         0         0      71.2                                          
             0      -2.5         0       112                                          
             0         0       2.5        43                                          
             0         0         0         1 ]                                        
      .dim                                                                            
        [ 61        84        41 ]                                                    
      .xform                                                                          
        'scanner_anat'                                                                
    .fdim                                                                             
      .labels                                                                         
        { 'i'                                                                         
          'j'                                                                         
          'k' }                                                                       
      .values                                                                         
        { [ 1         2         3  ...  59        60        61 ]@1x61                 
          [ 1         2         3  ...  82        83        84 ]@1x84                 
          [ 1         2         3  ...  39        40        41 ]@1x41 }               
  .fa                                                                                 
    .i                                                                                
      [ 1         2         3  ...  59        60        61 ]@1x168097                 
    .j                                                                                
      [ 1         1         1  ...  84        84        84 ]@1x168097                 
    .k                                                                                
      [ 3         3         3  ...  36        36        36 ]@1x168097                 
The output surface has 5124 vertices, 10240 nodes
+00:00:23 [####################] -00:00:00  
Dataset output:
.a                                                                           
  .fdim                                                                      
    .labels                                                                  
      { 'node_indices' }                                                     
    .values                                                                  
      { [ 1         2         3  ...  5.12e+03  5.12e+03  5.12e+03 ]@1x5124 }
.fa                                                                          
  .node_indices                                                              
    [ 1         2         3  ...  5.12e+03  5.12e+03  5.12e+03 ]@1x5124      
  .center_ids                                                                
    [ 1         2         3  ...  5.12e+03  5.12e+03  5.12e+03 ]@1x5124      
.samples                                                                     
  [ 0.5       0.5     0.656  ...  0.625     0.656     0.625 ]@1x5124         
.sa                                                                          
  .labels                                                                    
    { 'accuracy' }                                                           
DispIVSurf verbose: z-buffer mode.
DispIVSurf verbose: Scaling ITvect to fit colormap
DispIVSurf verbose: Set hold to off
DispIVSurf verbose: Drawing Patches
DispIVSurf verbose: Applied interp for Shade.
DispIVSurf verbose: Set Edgecolor to none
DispIVSurf verbose: Set view to 2D
DispIVSurf verbose: Displaying colormap
DispIVSurf verbose: Seting Axes properties
DispIVSurf verbose: Done
DispIVSurf verbose: z-buffer mode.
DispIVSurf verbose: Scaling ITvect to fit colormap
DispIVSurf verbose: Set hold to off
DispIVSurf verbose: Drawing Patches
DispIVSurf verbose: Applied interp for Shade.
DispIVSurf verbose: Set Edgecolor to none
DispIVSurf verbose: Set view to 2D
DispIVSurf verbose: Displaying colormap
DispIVSurf verbose: Seting Axes properties
DispIVSurf verbose: Done
DispIVSurf verbose: z-buffer mode.
DispIVSurf verbose: Scaling ITvect to fit colormap
DispIVSurf verbose: Set hold to off
DispIVSurf verbose: Drawing Patches
DispIVSurf verbose: Applied interp for Shade.
DispIVSurf verbose: Set Edgecolor to black
DispIVSurf verbose: Set view to 2D
DispIVSurf verbose: Displaying colormap
DispIVSurf verbose: Seting Axes properties
DispIVSurf verbose: Done
DispIVSurf verbose: z-buffer mode.
DispIVSurf verbose: Scaling ITvect to fit colormap
DispIVSurf verbose: Set hold to off
DispIVSurf verbose: Drawing Patches
DispIVSurf verbose: Applied interp for Shade.
DispIVSurf verbose: Set Edgecolor to black
DispIVSurf verbose: Set view to 2D
DispIVSurf verbose: Displaying colormap
DispIVSurf verbose: Seting Axes properties
DispIVSurf verbose: Done
If you use CoSMoMVPA and/or some other toolboxes for a publication, please cite:

Z. Saad, G. Chen. AFNI Matlab library. available online from https://github.com/afni/AFNI

N. N. Oosterhof, T. Wiestler, J. Diedrichsen (2011). A comparison of volume-based and surface-based multi-voxel pattern analysis. Neuroimage 56 (2), 593-600. Surfing toolbox available online from http://github.com/nno/surfing

Gabriel Peyre. Toolbox Fast Marching - A toolbox Fast Marching and level sets computations [https://www.ceremade.dauphine.fr/~peyre/matlab/fast-marching/content.html]. toolbox fast marching [included in surfing] available online from http://github.com/nno/surfing

J. Weber. NeuroElf toolbox. available online from http://neuroelf.net

J. Shen. NIFTI toolbox. available online from http://www.mathworks.com/matlabcentral/fileexchange/8797-tools-for-nifti-and-analyze-image

G. Flandin. GIfTI library for matlab. available online from www.artefact.tk/software/matlab/gifti

N. N. Oosterhof, A. C. Connolly, J. V. Haxby (2016). CoSMoMVPA: multi-modal multivariate pattern analysis of neuroimaging data in Matlab / GNU Octave. Frontiers in Neuroinformatics, doi:10.3389/fninf.2016.00027.. CoSMoMVPA toolbox available online from http://cosmomvpa.org

The Mathworks, Natick, MA, United States. Matlab 8.5.0.197613 (R2015a) (February 12, 2015). available online from http://www.mathworks.com

</pre><img vspace="5" hspace="5" src="demo_surface_searchlight_lda_01.png" alt=""> <img vspace="5" hspace="5" src="demo_surface_searchlight_lda_02.png" alt=""> <img vspace="5" hspace="5" src="demo_surface_searchlight_lda_03.png" alt=""> <img vspace="5" hspace="5" src="demo_surface_searchlight_lda_04.png" alt=""> <img vspace="5" hspace="5" src="demo_surface_searchlight_lda_05.png" alt=""> <img vspace="5" hspace="5" src="demo_surface_searchlight_lda_06.png" alt=""> <img vspace="5" hspace="5" src="demo_surface_searchlight_lda_07.png" alt=""> <img vspace="5" hspace="5" src="demo_surface_searchlight_lda_08.png" alt=""> <img vspace="5" hspace="5" src="demo_surface_searchlight_lda_09.png" alt=""> <img vspace="5" hspace="5" src="demo_surface_searchlight_lda_10.png" alt=""> <img vspace="5" hspace="5" src="demo_surface_searchlight_lda_11.png" alt=""> <img vspace="5" hspace="5" src="demo_surface_searchlight_lda_12.png" alt=""> <img vspace="5" hspace="5" src="demo_surface_searchlight_lda_13.png" alt=""> <img vspace="5" hspace="5" src="demo_surface_searchlight_lda_14.png" alt=""> <img vspace="5" hspace="5" src="demo_surface_searchlight_lda_15.png" alt=""> <img vspace="5" hspace="5" src="demo_surface_searchlight_lda_16.png" alt=""> <p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2015a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Demo: fMRI surface-based searchlights with LDA classifier
%
% The data used here is available from http://cosmomvpa.org/datadb.zip
%
% This example uses the following dataset:
% + 'digit'
%    A participant made finger pressed with the index and middle finger of
%    the right hand during 4 runs in an fMRI study. Each run was divided in
%    4 blocks with presses of each finger and analyzed with the GLM,
%    resulting in 2*4*4=32 t-values
%
% The example shows four possible searchlight analyses, covering typical
% use cases:
%   1) single or twin surfaces
%      + Caret and BrainVoyager use a single surface; a parameter 'offsets'
%        is used to define which voxels are considered to be in the "grey
%        matter" (but this may be not so precise)
%      + FreeSurfer uses twin surfaces (pial and white), and voxels in
%        between or on them are considered to be in the grey matter
%   2) lower resolution output map
%      + in the canonical surface-based searchlight, each node on the input
%        surface(s) is assigned a measure value (accuracy, in this example)
%      + it is also possible to have output in a lower resolution version
%        than the input surfaces; this reduces both the execution time
%        (a Good Thing) and spatial precision (a Bad Thing). Two approaches
%        are illustrated to use a lower resolution surface for output:
%        1) from MapIcosahedron, with a lower value for the number of
%          divisions of the triangles
%        2) using a surface subsampling approach, implemented by
%           surfing_subsample_surface
%
% In all cases a searchlight is run with a 100 voxel searchlight, using a
% disc for which the metric radius varies from node to node. For a fixed
% metric radius of the disc, use a positive value for 'radius' below.
% Distances are measured across the cortical surface using a geodesic
% distance metric.
%
% This example requires the surfing toolbox, github.com/nno/surfing
%
% This example may take quite some time to run. For faster execution, set
% ld=16 (instead of ld=64) below
%
% If you use this code for a publication, please cite:
% Oosterhof, N.N., Wiestler, T, Downing, P.E., & Diedrichsen, J. (2011)
% A comparison of volume-based and surface-based information mapping.
% Neuroimage. DOI:10.1016/j.neuroimage.2010.04.270
%
% #   For CoSMoMVPA's copyright information and license terms,   #
% #   see the COPYING file distributed with CoSMoMVPA.           #

%% Check externals
cosmo_check_external('surfing');

%% Set data paths
% The function cosmo_config() returns a struct containing paths to tutorial
% data. (Alternatively the paths can be set manually without using
% cosmo_config.)
config=cosmo_config();

digit_study_path=fullfile(config.tutorial_data_path,'digit');
readme_fn=fullfile(digit_study_path,'README');
cosmo_type(readme_fn);

output_path=config.output_data_path;

% reset citation list
cosmo_check_external('-tic');

% resolution parameter for input surfaces
% 64 is for high-quality results; use 16 for fast execution
ld=64;

% Twin surface case (FS)
pial_fn=fullfile(digit_study_path,...
                            sprintf('ico%d_mh.pial_al.asc', ld));
white_fn=fullfile(digit_study_path,...
                            sprintf('ico%d_mh.smoothwm_al.asc', ld));

% Single surface case (Caret/BV)
intermediate_fn=fullfile(digit_study_path,...
                            sprintf('ico%d_mh.intermediate_al.asc', ld));

% Used for visualization
inflated_fn=fullfile(digit_study_path,...
                         sprintf('ico%d_mh.inflated_alCoMmedial.asc', ld));

%%
% Set parameters

% Searchlight radius: select 100 features in each searchlight
% (to use a fixed radius of 8mm, use:
%    cosmo_surficial_neighborhood(...,'radius',8)
% in the code below)

feature_count=100;

% Single surface case: select voxels that are 3 mm or closer to the surface
% on the white-matter side, up to voxels that are 2 mm from the surface on
% the pial matter side
single_surf_offsets=[-2 3];

% Single surface case: number of iterations to downsample surface
lowres_output_onesurf_niter=10;

% Twin surface case: number of linear divisions from MapIcosahedron
lowres_output_twosurf_icold=16;
lowres_intermediate_fn=fullfile(digit_study_path,...
                                sprintf('ico%d_mh.intermediate_al.asc',...
                                        lowres_output_twosurf_icold));


% Use the cosmo_cross_validation_measure and set its parameters
% (classifier and partitions) in a measure_args struct.
measure = @cosmo_crossvalidation_measure;
measure_args = struct();

% Define which classifier to use, using a function handle.
% Alternatives are @cosmo_classify_{svm,nn,naive_bayes}
measure_args.classifier = @cosmo_classify_lda;



%% Load functional data
data_path=digit_study_path;
data_fn=fullfile(data_path,'glm_T_stats_perblock+orig');

targets=repmat(1:2,1,16)';    % class labels: 1 2 1 2 1 2 1 2 1 2 ... 1 2
chunks=floor(((1:32)-1)/8)+1; % run labels:   1 1 1 1 1 1 1 1 2 2 ... 4 4

ds = cosmo_fmri_dataset(data_fn,'targets',targets,'chunks',chunks);

% remove zero elements
zero_msk=all(ds.samples==0,1);
ds = cosmo_slice(ds, ~zero_msk, 2);

fprintf('Dataset has %d samples and %d features\n', size(ds.samples));

% print dataset
fprintf('Dataset input:\n');
cosmo_disp(ds);

%% Set partition scheme. odd_even is fast; for publication-quality analysis
% nfold_partitioner is recommended.
% Alternatives are:
% - cosmo_nfold_partitioner    (take-one-chunk-out crossvalidation)
% - cosmo_nchoosek_partitioner (take-K-chunks-out  "             ").
measure_args.partitions = cosmo_oddeven_partitioner(ds);

% print measure and arguments
fprintf('Searchlight measure:\n');
cosmo_disp(measure);
fprintf('Searchlight measure arguments:\n');
cosmo_disp(measure_args);

%% Read inflated surface
[v_inf,f_inf]=surfing_read(inflated_fn);
fprintf('The inflated surface has %d vertices, %d faces\n',...
            size(v_inf,1), size(f_inf,1))

%% Run four types of searchlights
for one_surf=[true,false]
    if one_surf
        desc='1surf';
    else
        desc='2surfs';
    end

    for lowres_output=[false,true]
        if lowres_output
            desc=sprintf('%s_lowres', desc);
        end
        fprintf('\n\n *** Starting analysis with %s *** \n\n\n', desc)

        % define searchlight surface paramters for each type of analysis
        if one_surf && lowres_output

            % single surface (Caret/BV) with lower-res output
            surf_def={intermediate_fn,single_surf_offsets,...
                            lowres_output_onesurf_niter};

        elseif one_surf && ~lowres_output

            % single surface (Caret/BV) with original-res output
            surf_def={intermediate_fn,single_surf_offsets};

        elseif ~one_surf && lowres_output

            % single surface (FS) with lower-res output
            surf_def={white_fn,pial_fn,lowres_intermediate_fn};

        elseif ~one_surf && ~lowres_output

            % single surface (FS) with original-res output
            surf_def={white_fn,pial_fn};

        else
            assert(false); % should never get here
        end

        % Define the feature neighborhood for each node on the surface
        % - nbrhood has the neighborhood information
        % - vo and fo are vertices and faces of the output surface
        % - out2in is the mapping from output to input surface
        fprintf('Defining neighborhood with %s\n', desc);
        [nbrhood,vo,fo,out2in]=cosmo_surficial_neighborhood(ds,surf_def,...
                                                    'count',feature_count);

        % print neighborhood
        fprintf('Searchlight neighborhood definition:\n');
        cosmo_disp(nbrhood);


        fprintf('The output surface has %d vertices, %d nodes\n',...
                        size(vo,1), size(fo,1));



        % Run the searchlight
        lda_results = cosmo_searchlight(ds,nbrhood,measure,measure_args);


        % print searchlight output
        fprintf('Dataset output:\n');
        cosmo_disp(lda_results);

        % Apply the node mapping from the surifical neighborhood
        % to the high-res inflated surface.
        % (This example shows how such a mapping can be applied to new
        % surfaces)
        if lowres_output
            v_inf_out=v_inf(out2in,:);
            f_inf_out=fo;
        else
            v_inf_out=v_inf;
            f_inf_out=f_inf;
        end

        % visualize the surfaces, if the afni matlab toolbox is present
        if cosmo_check_external('afni',false)
            nvertices=size(v_inf_out,1);

            opt=struct();

            for show_edge=[false, true]
                opt.ShowEdge=show_edge;

                if show_edge
                    t='with edges';
                else
                    t='without edges';
                end

                header=strrep([desc ' ' t],'_',' ');


                DispIVSurf(vo,fo,1:nvertices,lda_results.samples',0,opt);
                title(sprintf('Original %s', header));

                DispIVSurf(v_inf_out,f_inf_out,1:nvertices,...
                                        lda_results.samples',0,opt);
                title(sprintf('Inflated %s', header));
            end
        else
            fprintf('skip surface display; no afni matlab toolbox\n');
        end

        if lowres_output && one_surf
            % in this example only this case a new surface was generated.
            % To aid visualization using external tools, store it to disc.

            % The surface is stored in ASCII, GIFTI and BV SRF
            % formats, if the required externals are present
            surf_output_fn=fullfile(output_path,['inflated_' desc]);

            % AFNI/SUMA ASC
            surfing_write([surf_output_fn '.asc'],v_inf_out,f_inf_out);

            % BV SRF
            if cosmo_check_external('neuroelf',false)
                surfing_write([surf_output_fn '.srf'],v_inf_out,f_inf_out);
            end

            % GIFTI
            if cosmo_check_external('gifti',false)
                surfing_write([surf_output_fn '.gii'],v_inf_out,f_inf_out);
            end
        end

        % store searchlight results
        data_output_fn=fullfile(output_path,['lda_' desc]);

        if cosmo_check_external('afni',false)
            cosmo_map2surface(lda_results, [data_output_fn '.niml.dset']);
        end

        if cosmo_check_external('neuroelf',false)
            cosmo_map2surface(lda_results, [data_output_fn '.smp']);
        end

        % store voxel counts (how often each voxel is in a neighborhood)
        % take a random sample (the first one) from the input dataset
        % and count how often each voxel was selected.
        % If everything works, then voxels in the grey matter have high
        % voxel counts but voxels outside it low or zero counts.
        % Thus, this can be used as a sanity check that can be visualized
        % easily.

        vox_count_ds=cosmo_slice(ds,1);
        vox_count_ds.samples(:)=0;

        ncenters=numel(nbrhood.neighbors);
        for k=1:ncenters
            idxs=nbrhood.neighbors{k}; % feature indices in neigborhood
            vox_count_ds.samples(idxs)=vox_count_ds.samples(idxs)+1;
        end

        vox_count_output_fn=fullfile(output_path,['vox_count_' desc]);

        % store voxel count results
        cosmo_map2fmri(vox_count_ds, [vox_count_output_fn '.nii']);

        if cosmo_check_external('afni',false)
            cosmo_map2fmri(vox_count_ds, [vox_count_output_fn '+orig']);
        end
    end
end

% Show citation information
cosmo_check_external('-cite');

##### SOURCE END #####
--></body></html>
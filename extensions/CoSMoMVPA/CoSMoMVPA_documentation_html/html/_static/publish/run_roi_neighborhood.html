
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>ROI neighborhood example</title><meta name="generator" content="MATLAB 8.5"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2016-12-01"><meta name="DC.source" content="run_roi_neighborhood.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>ROI neighborhood example</h1><!--introduction--><p>This example shows how to define and use neighborhoods, and shows how they can be used with the cosmo_searchlight function</p><div><ol><li>For CoSMoMVPA's copyright information and license terms,   #</li><li>see the COPYING file distributed with CoSMoMVPA.           #</li></ol></div><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Load data (without mask)</a></li><li><a href="#2">Define a neighborhood struct for two ROIs</a></li><li><a href="#3">Part 1: 'manual' saerchlight using a neighborhood and a measure</a></li><li><a href="#4">Part 2: use cosmo_searchlight to replicate Part 1</a></li><li><a href="#5">Part 3: use cosmo_searchlight for split-half correlation differences</a></li><li><a href="#6">Part 4: (advanced) use cosmo_searchlight to get confusion matrices</a></li></ul></div><h2>Load data (without mask)<a name="1"></a></h2><pre class="codeinput">config=cosmo_config();
data_path=fullfile(config.tutorial_data_path,<span class="string">'ak6'</span>,<span class="string">'s01'</span>);

data_fn=fullfile(data_path,<span class="string">'glm_T_stats_perrun.nii'</span>);
ds=cosmo_fmri_dataset(data_fn,<span class="keyword">...</span>
                        <span class="string">'targets'</span>,repmat(1:6,1,10),<span class="keyword">...</span>
                        <span class="string">'chunks'</span>,floor(((1:60)-1)/6)+1);
</pre><h2>Define a neighborhood struct for two ROIs<a name="2"></a></h2><pre class="codeinput"><span class="comment">% Use EV and VT masks</span>
roi_names={<span class="string">'ev'</span>,<span class="string">'vt'</span>};
nrois=numel(roi_names);

<span class="comment">% Start with empty struct</span>
nbrhood=struct();

<span class="comment">% Add a feature attribute with the labels to neighborhood</span>
nbrhood.fa.roi_names=roi_names;

<span class="comment">% For illustrative purposes as a single dataset attribute</span>
nbrhood.a.some_attribute=<span class="string">'useless'</span>;

<span class="comment">% Set the origin field - this is not required, but is useful to avoid</span>
<span class="comment">% mistakes where neighborhoods are used with a different dataset than</span>
<span class="comment">% intended</span>
nbrhood.origin.fa=ds.fa;
nbrhood.origin.a=ds.a;

<span class="comment">% Add a field '.neighbors' to the nbrhood, which is initialized to a cell</span>
<span class="comment">% with two elements (one for each ROI).</span>
<span class="comment">% In the for-loop below, the cell is filled with feature indices</span>
nbrhood.neighbors=cell(nrois,1);

<span class="comment">% Add the feature indices of each ROI to the neighborhood</span>
<span class="keyword">for</span> k=1:nrois
    <span class="comment">% name of ROI</span>
    roi_name=roi_names{k};

    <span class="comment">% filename of mask volume</span>
    roi_fn=fullfile(data_path,sprintf(<span class="string">'%s_mask.nii'</span>,roi_name));

    <span class="comment">% load roi mask volume and assign to variable named 'ds_roi'</span>
    <span class="comment">% &gt;@@&gt;</span>
    ds_roi=cosmo_fmri_dataset(roi_fn);
    <span class="comment">% &lt;@@&lt;</span>

    <span class="comment">% safety check to ensure that the feature attributes match</span>
    assert(isequal(ds_roi.fa,ds.fa));

    <span class="comment">% find the indices where the voxels in the ROI have non-zero values,</span>
    <span class="comment">% and assign to a variable named 'nonzero_idxs'</span>
    <span class="comment">% &gt;@@&gt;</span>
    nonzero_idxs=find(ds_roi.samples);
    <span class="comment">% &lt;@@&lt;</span>

    <span class="comment">% store the non-zero indices in the k-th element of</span>
    <span class="comment">% 'nbrhood.neighbors'</span>
    <span class="comment">% &gt;@@&gt;</span>
    nbrhood.neighbors{k}=nonzero_idxs;
    <span class="comment">% &lt;@@&lt;</span>
<span class="keyword">end</span>

<span class="comment">% show 'nbrhood' using cosmo_disp</span>
<span class="comment">% &gt;@@&gt;</span>
fprintf(<span class="string">'\nNeighborhood definition:\n'</span>);
cosmo_disp(nbrhood);
<span class="comment">% &lt;@@&lt;</span>
</pre><pre class="codeoutput">
Neighborhood definition:
.fa                                                                            
  .roi_names                                                                   
    { 'ev'  'vt' }                                                             
.a                                                                             
  .some_attribute                                                              
    'useless'                                                                  
.origin                                                                        
  .fa                                                                          
    .i                                                                         
      [ 1         2         3  ...  78        79        80 ]@1x275200          
    .j                                                                         
      [ 1         1         1  ...  80        80        80 ]@1x275200          
    .k                                                                         
      [ 1         1         1  ...  43        43        43 ]@1x275200          
  .a                                                                           
    .vol                                                                       
      .mat                                                                     
        [ -3         0         0       121                                     
           0         3         0      -114                                     
           0         0         3     -11.1                                     
           0         0         0         1 ]                                   
      .xform                                                                   
        'scanner_anat'                                                         
      .dim                                                                     
        [ 80        80        43 ]                                             
    .fdim                                                                      
      .labels                                                                  
        { 'i'                                                                  
          'j'                                                                  
          'k' }                                                                
      .values                                                                  
        { [ 1         2         3  ...  78        79        80 ]@1x80          
          [ 1         2         3  ...  78        79        80 ]@1x80          
          [ 1         2         3  ...  41        42        43 ]@1x43 }        
.neighbors                                                                     
  { [ 1.4e+04  2.04e+04  2.04e+04  ...  7.8e+04  7.83e+04  7.83e+04 ]@1x300    
    [ 8.29e+03  8.29e+03  8.29e+03  ...  5.31e+04  5.31e+04  5.32e+04 ]@1x400 }
</pre><h2>Part 1: 'manual' saerchlight using a neighborhood and a measure<a name="3"></a></h2><pre class="codeinput"><span class="comment">% This part shows how a 'searchlight' can be imitated using a neighborhood</span>
<span class="comment">% and a measure. The main idea here is:</span>
<span class="comment">% - nbrhood.neighbors contains a cell, each element with indices of</span>
<span class="comment">%   features</span>
<span class="comment">% - apply the measure to subsets of the dataset gives a 'partial' dataset,</span>
<span class="comment">%   in the sense that the measure only returns .sa and .samples.</span>
<span class="comment">%   Then the outputs from each application of the measure are stacked</span>
<span class="comment">%   to get the output in each subset of the dataset for each</span>
<span class="comment">%   feature in nbrhood. The stacked output dataset is still 'partial'</span>
<span class="comment">%   (only with .sa and .samples, but without .fa and .a)</span>
<span class="comment">% - the neighborhood struct gives .fa and .a, so combining these with</span>
<span class="comment">%   the stacked dataset to get a full dataset with</span>
<span class="comment">%   .samples, .fa, .sa., and .a</span>
<span class="comment">%</span>

<span class="comment">% Define a measure and arguments for n-fold</span>
<span class="comment">% cross-validation with LDA classifier</span>
measure=@cosmo_crossvalidation_measure;
measure_args=struct();
measure_args.partitions=cosmo_nfold_partitioner(ds);
measure_args.classifier=@cosmo_classify_lda;

<span class="comment">% it is assumed that nbrhood was defined in the previous section. Here</span>
<span class="comment">% see how many rois there are.</span>
nrois=numel(nbrhood.neighbors); <span class="comment">% should be 2 in this example</span>

<span class="comment">% When applying the measure to data in a single ROI, the output is a</span>
<span class="comment">% dataset structure. Allocate a cell of size 1 x 'nrois' to store</span>
<span class="comment">% these dataset; assign it to a variable 'each_measure_output'</span>
<span class="comment">% &gt;@@&gt;</span>
each_measure_output=cell(1,nrois);
<span class="comment">% &lt;@@&lt;</span>

<span class="comment">% Now loop over the elements in nbrhood.neighbors to apply the measure to</span>
<span class="comment">% each ROI</span>
<span class="keyword">for</span> k=1:nrois
    <span class="comment">% get the feature indices for the k-th ROI, and store in variable named</span>
    <span class="comment">% 'feature_idxs'</span>
    <span class="comment">% &gt;@@&gt;</span>
    feature_idxs=nbrhood.neighbors{k};
    <span class="comment">% &lt;@@&lt;</span>

    <span class="comment">% slice the 'ds' dataset using these feature_idxs along the second</span>
    <span class="comment">% (feature) dimension to select the data in the k-th ROI. Assign the</span>
    <span class="comment">% result to a variable named 'ds_roi'</span>
    <span class="comment">% &gt;@@&gt;</span>
    ds_roi=cosmo_slice(ds,feature_idxs,2);
    <span class="comment">% &lt;@@&lt;</span>

    <span class="comment">% safety check (for this exercise)</span>
    <span class="comment">% if this throws an error then you did something wrong</span>
    assert(size(ds_roi.samples,2)==numel(feature_idxs));

    <span class="comment">% apply the measure and store the result in the k-th element of</span>
    <span class="comment">% 'each_measure_output'</span>
    <span class="comment">% &gt;@@&gt;</span>
    each_measure_output{k}=measure(ds_roi,measure_args);
    <span class="comment">% &lt;@@&lt;</span>

<span class="keyword">end</span>

<span class="comment">% Stack the datasets in 'each_measure_output' using cosmo_stack along</span>
<span class="comment">% the second dimension, to get a dataset where .samples is 1 x nrois.</span>
<span class="comment">% Assign the result to a variable 'full_output'</span>
<span class="comment">% Hint: the second argument of cosmo_stack must be 2</span>
<span class="comment">% &gt;@@&gt;</span>
full_output=cosmo_stack(each_measure_output,2);
<span class="comment">% &lt;@@&lt;</span>

<span class="comment">% From the 'nbrhood' now copy the contents of the .fa. and .a fields</span>
<span class="comment">% to 'full_output' to get a full dataset with .samples, .a, .fa and .sa</span>
<span class="comment">% &gt;@@&gt;</span>
full_output.fa=nbrhood.fa;
full_output.a=nbrhood.a;
<span class="comment">% &lt;@@&lt;</span>

<span class="comment">% Show the result</span>
cosmo_check_dataset(full_output);
fprintf(<span class="string">'\nOutput of cross-validation:\n'</span>)
cosmo_disp(full_output)
</pre><pre class="codeoutput">
Output of cross-validation:
.samples            
  [ 0.85     0.833 ]
.sa                 
  .labels           
    { 'accuracy' }  
.fa                 
  .roi_names        
    { 'ev'  'vt' }  
.a                  
  .some_attribute   
    'useless'       
</pre><h2>Part 2: use cosmo_searchlight to replicate Part 1<a name="4"></a></h2><pre class="codeinput"><span class="comment">% the cosmo_searchlight routine uses a neighborhood and a measure</span>
<span class="comment">% and applies them in a similar way as in Part 1</span>

<span class="comment">% Use cosmo_searchlight with arguments:</span>
<span class="comment">%  - the input dataset ('ds')</span>
<span class="comment">%  - the neighborhood struct ('nbrhood')</span>
<span class="comment">%  - the function handle of the measure ('measure')</span>
<span class="comment">%  - the arguments to the measure ('measure_args')</span>
<span class="comment">% Assign the result to the variable 'full_output_alt' and display it</span>
<span class="comment">% contents using cosmo_disp</span>

<span class="comment">% &gt;@@&gt;</span>
<span class="comment">% apply searchlight</span>
full_output_alt=cosmo_searchlight(ds,nbrhood,measure,measure_args);

fprintf(<span class="string">'Output of cross-validation using cosmo_searchlight:\n'</span>);
cosmo_disp(full_output_alt);

<span class="comment">% alternative syntax: cosmo_searchlight can also be called with</span>
<span class="comment">% measure-arguments as key-value pairs (just like cosmomvpa_fmri_dataset)</span>
full_output_alt2=cosmo_searchlight(ds,nbrhood,measure,<span class="keyword">...</span>
                                   <span class="string">'partitions'</span>,measure_args.partitions,<span class="keyword">...</span>
                                   <span class="string">'classifier'</span>,measure_args.classifier);

fprintf([<span class="string">'Output of cross-validation using cosmo_searchlight '</span><span class="keyword">...</span>
            <span class="string">'(alternative syntax):\n'</span>]);
cosmo_disp(full_output_alt2);
<span class="comment">% &lt;@@&lt;</span>
</pre><pre class="codeoutput">+00:00:00 [####################] -00:00:00  
Output of cross-validation using cosmo_searchlight:
.a                  
  .some_attribute   
    'useless'       
.fa                 
  .roi_names        
    { 'ev'  'vt' }  
  .center_ids       
    [ 1         2 ] 
.samples            
  [ 0.85     0.833 ]
.sa                 
  .labels           
    { 'accuracy' }  
+00:00:00 [####################] -00:00:00  
Output of cross-validation using cosmo_searchlight (alternative syntax):
.a                  
  .some_attribute   
    'useless'       
.fa                 
  .roi_names        
    { 'ev'  'vt' }  
  .center_ids       
    [ 1         2 ] 
.samples            
  [ 0.85     0.833 ]
.sa                 
  .labels           
    { 'accuracy' }  
</pre><h2>Part 3: use cosmo_searchlight for split-half correlation differences<a name="5"></a></h2><pre class="codeinput"><span class="comment">% This is a variation of part 2, showing how split-half correlation</span>
<span class="comment">% differences can be computed using a searchlight</span>
<span class="comment">%</span>
<span class="comment">% Note: this dataset has 10 chunks. The correlation measure will,</span>
<span class="comment">% by default, *not* do a 'simple' odd-even partitioning, but instead will</span>
<span class="comment">% use all possible splits of the 10 chunks in two groups of 5, yielding</span>
<span class="comment">% nchoosek(10,5) = 10! / (5!*5!) = 252 splits. Correlation diffences are</span>
<span class="comment">% computed for each split and then averaged.</span>
<span class="comment">% (to override this, you can specify a 'partitions' argument with, for</span>
<span class="comment">% example, the output of cosmo_oddeven_partitioner(ds,'half') ).</span>

<span class="comment">% Set the variable 'measure' to a function handle referring to</span>
<span class="comment">% cosmo_correlation_measure</span>
<span class="comment">% &gt;@@&gt;</span>
measure=@cosmo_correlation_measure;
<span class="comment">% &lt;@@&lt;</span>

<span class="comment">% Run the searchlight using cosmo_searchlight, which takes the dataset,</span>
<span class="comment">% neighborhood and measure arguments. (No additional measure arguments are</span>
<span class="comment">% required for the correlation measure)</span>
corr_output=cosmo_searchlight(ds,nbrhood,measure);

<span class="comment">% Show the result</span>
cosmo_disp(corr_output);
</pre><pre class="codeoutput">+00:00:00 [####################] -00:00:00  
.a                  
  .some_attribute   
    'useless'       
.fa                 
  .roi_names        
    { 'ev'  'vt' }  
  .center_ids       
    [ 1         2 ] 
.samples            
  [ 0.47     0.497 ]
.sa                 
  .labels           
    { 'corr' }      
</pre><h2>Part 4: (advanced) use cosmo_searchlight to get confusion matrices<a name="6"></a></h2><pre class="codeinput"><span class="comment">% This exercise is like part 2 (classifation), but now</span>
<span class="comment">% classification confusions are computed and visualized</span>
<span class="comment">%</span>
<span class="comment">% set arguments for the measure, ensuring that the predictions (instead</span>
<span class="comment">% of classification accuracies) are returned</span>
measure=@cosmo_crossvalidation_measure;
measure_args=struct();
measure_args.partitions=cosmo_nfold_partitioner(ds);
measure_args.classifier=@cosmo_classify_lda;
measure_args.output=<span class="string">'predictions'</span>;

<span class="comment">% apply searchlight using the dataset, neighborhood, measure, and measure</span>
<span class="comment">% arguments; store the result in 'ds_confusion'</span>
<span class="comment">% &gt;@@&gt;</span>
ds_confusion=cosmo_searchlight(ds,nbrhood,measure,measure_args);
<span class="comment">% &lt;@@&lt;</span>

<span class="comment">% show contents of ds_confusion</span>
cosmo_disp(ds_confusion);

<span class="comment">% convert to array form (nclasses x nclasses x nrois, with nclasses=6 and</span>
<span class="comment">% nrois=2) and assign the result to a variable 'mx_confusion'</span>
<span class="comment">% Hint: use cosmo_confusion_matrix and apply it to 'ds_confusion' directly</span>
<span class="comment">% &gt;@@&gt;</span>
mx_confusion=cosmo_confusion_matrix(ds_confusion);
<span class="comment">% &lt;@@&lt;</span>

<span class="comment">% visualize the confusion matrices</span>

classes= {<span class="string">'monkey'</span>,<span class="string">'lemur'</span>,<span class="string">'mallard'</span>,<span class="string">'warbler'</span>,<span class="string">'ladybug'</span>,<span class="string">'lunamoth'</span>};
nmatrices=size(mx_confusion,3);
<span class="keyword">for</span> k=1:nmatrices
    <span class="comment">% &gt;@@&gt;</span>
    figure()
    imagesc(mx_confusion(:,:,k),[0 10]);
    title(ds_confusion.fa.roi_names{k});
    set(gca, <span class="string">'xtick'</span>, 1:numel(classes), <span class="string">'xticklabel'</span>, classes)
    set(gca, <span class="string">'ytick'</span>, 1:numel(classes), <span class="string">'yticklabel'</span>, classes)
    colorbar();
    <span class="comment">% &lt;@@&lt;</span>
<span class="keyword">end</span>
</pre><pre class="codeoutput">+00:00:00 [####################] -00:00:00  
.a                    
  .some_attribute     
    'useless'         
.fa                   
  .roi_names          
    { 'ev'  'vt' }    
  .center_ids         
    [ 1         2 ]   
.samples              
  [ 1         1       
    1         2       
    3         4       
    :         :       
    4         2       
    6         5       
    4         6 ]@60x2
.sa                   
  .targets            
    [ 1               
      2               
      3               
      :               
      4               
      5               
      6 ]@60x1        
</pre><img vspace="5" hspace="5" src="run_roi_neighborhood_01.png" alt=""> <img vspace="5" hspace="5" src="run_roi_neighborhood_02.png" alt=""> <p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2015a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% ROI neighborhood example
%
% This example shows how to define and use neighborhoods, and shows
% how they can be used with the cosmo_searchlight function
%
% #   For CoSMoMVPA's copyright information and license terms,   #
% #   see the COPYING file distributed with CoSMoMVPA.           #

%% Load data (without mask)
config=cosmo_config();
data_path=fullfile(config.tutorial_data_path,'ak6','s01');

data_fn=fullfile(data_path,'glm_T_stats_perrun.nii');
ds=cosmo_fmri_dataset(data_fn,...
                        'targets',repmat(1:6,1,10),...
                        'chunks',floor(((1:60)-1)/6)+1);


%% Define a neighborhood struct for two ROIs

% Use EV and VT masks
roi_names={'ev','vt'};
nrois=numel(roi_names);

% Start with empty struct
nbrhood=struct();

% Add a feature attribute with the labels to neighborhood
nbrhood.fa.roi_names=roi_names;

% For illustrative purposes as a single dataset attribute
nbrhood.a.some_attribute='useless';

% Set the origin field - this is not required, but is useful to avoid
% mistakes where neighborhoods are used with a different dataset than
% intended
nbrhood.origin.fa=ds.fa;
nbrhood.origin.a=ds.a;

% Add a field '.neighbors' to the nbrhood, which is initialized to a cell
% with two elements (one for each ROI).
% In the for-loop below, the cell is filled with feature indices
nbrhood.neighbors=cell(nrois,1);

% Add the feature indices of each ROI to the neighborhood
for k=1:nrois
    % name of ROI
    roi_name=roi_names{k};

    % filename of mask volume
    roi_fn=fullfile(data_path,sprintf('%s_mask.nii',roi_name));

    % load roi mask volume and assign to variable named 'ds_roi'
    % >@@>
    ds_roi=cosmo_fmri_dataset(roi_fn);
    % <@@<

    % safety check to ensure that the feature attributes match
    assert(isequal(ds_roi.fa,ds.fa));

    % find the indices where the voxels in the ROI have non-zero values,
    % and assign to a variable named 'nonzero_idxs'
    % >@@>
    nonzero_idxs=find(ds_roi.samples);
    % <@@<

    % store the non-zero indices in the k-th element of
    % 'nbrhood.neighbors'
    % >@@>
    nbrhood.neighbors{k}=nonzero_idxs;
    % <@@<
end

% show 'nbrhood' using cosmo_disp
% >@@>
fprintf('\nNeighborhood definition:\n');
cosmo_disp(nbrhood);
% <@@<

%% Part 1: 'manual' saerchlight using a neighborhood and a measure

% This part shows how a 'searchlight' can be imitated using a neighborhood
% and a measure. The main idea here is:
% - nbrhood.neighbors contains a cell, each element with indices of
%   features
% - apply the measure to subsets of the dataset gives a 'partial' dataset,
%   in the sense that the measure only returns .sa and .samples.
%   Then the outputs from each application of the measure are stacked
%   to get the output in each subset of the dataset for each
%   feature in nbrhood. The stacked output dataset is still 'partial'
%   (only with .sa and .samples, but without .fa and .a)
% - the neighborhood struct gives .fa and .a, so combining these with
%   the stacked dataset to get a full dataset with
%   .samples, .fa, .sa., and .a
%

% Define a measure and arguments for n-fold
% cross-validation with LDA classifier
measure=@cosmo_crossvalidation_measure;
measure_args=struct();
measure_args.partitions=cosmo_nfold_partitioner(ds);
measure_args.classifier=@cosmo_classify_lda;

% it is assumed that nbrhood was defined in the previous section. Here
% see how many rois there are.
nrois=numel(nbrhood.neighbors); % should be 2 in this example

% When applying the measure to data in a single ROI, the output is a
% dataset structure. Allocate a cell of size 1 x 'nrois' to store
% these dataset; assign it to a variable 'each_measure_output'
% >@@>
each_measure_output=cell(1,nrois);
% <@@<

% Now loop over the elements in nbrhood.neighbors to apply the measure to
% each ROI
for k=1:nrois
    % get the feature indices for the k-th ROI, and store in variable named
    % 'feature_idxs'
    % >@@>
    feature_idxs=nbrhood.neighbors{k};
    % <@@<

    % slice the 'ds' dataset using these feature_idxs along the second
    % (feature) dimension to select the data in the k-th ROI. Assign the
    % result to a variable named 'ds_roi'
    % >@@>
    ds_roi=cosmo_slice(ds,feature_idxs,2);
    % <@@<

    % safety check (for this exercise)
    % if this throws an error then you did something wrong
    assert(size(ds_roi.samples,2)==numel(feature_idxs));

    % apply the measure and store the result in the k-th element of
    % 'each_measure_output'
    % >@@>
    each_measure_output{k}=measure(ds_roi,measure_args);
    % <@@<

end

% Stack the datasets in 'each_measure_output' using cosmo_stack along
% the second dimension, to get a dataset where .samples is 1 x nrois.
% Assign the result to a variable 'full_output'
% Hint: the second argument of cosmo_stack must be 2
% >@@>
full_output=cosmo_stack(each_measure_output,2);
% <@@<

% From the 'nbrhood' now copy the contents of the .fa. and .a fields
% to 'full_output' to get a full dataset with .samples, .a, .fa and .sa
% >@@>
full_output.fa=nbrhood.fa;
full_output.a=nbrhood.a;
% <@@<

% Show the result
cosmo_check_dataset(full_output);
fprintf('\nOutput of cross-validation:\n')
cosmo_disp(full_output)


%% Part 2: use cosmo_searchlight to replicate Part 1

% the cosmo_searchlight routine uses a neighborhood and a measure
% and applies them in a similar way as in Part 1

% Use cosmo_searchlight with arguments:
%  - the input dataset ('ds')
%  - the neighborhood struct ('nbrhood')
%  - the function handle of the measure ('measure')
%  - the arguments to the measure ('measure_args')
% Assign the result to the variable 'full_output_alt' and display it
% contents using cosmo_disp

% >@@>
% apply searchlight
full_output_alt=cosmo_searchlight(ds,nbrhood,measure,measure_args);

fprintf('Output of cross-validation using cosmo_searchlight:\n');
cosmo_disp(full_output_alt);

% alternative syntax: cosmo_searchlight can also be called with
% measure-arguments as key-value pairs (just like cosmomvpa_fmri_dataset)
full_output_alt2=cosmo_searchlight(ds,nbrhood,measure,...
                                   'partitions',measure_args.partitions,...
                                   'classifier',measure_args.classifier);

fprintf(['Output of cross-validation using cosmo_searchlight '...
            '(alternative syntax):\n']);
cosmo_disp(full_output_alt2);
% <@@<


%% Part 3: use cosmo_searchlight for split-half correlation differences

% This is a variation of part 2, showing how split-half correlation
% differences can be computed using a searchlight
%
% Note: this dataset has 10 chunks. The correlation measure will,
% by default, *not* do a 'simple' odd-even partitioning, but instead will
% use all possible splits of the 10 chunks in two groups of 5, yielding
% nchoosek(10,5) = 10! / (5!*5!) = 252 splits. Correlation diffences are
% computed for each split and then averaged.
% (to override this, you can specify a 'partitions' argument with, for
% example, the output of cosmo_oddeven_partitioner(ds,'half') ).

% Set the variable 'measure' to a function handle referring to
% cosmo_correlation_measure
% >@@>
measure=@cosmo_correlation_measure;
% <@@<

% Run the searchlight using cosmo_searchlight, which takes the dataset,
% neighborhood and measure arguments. (No additional measure arguments are
% required for the correlation measure)
corr_output=cosmo_searchlight(ds,nbrhood,measure);

% Show the result
cosmo_disp(corr_output);

%% Part 4: (advanced) use cosmo_searchlight to get confusion matrices

% This exercise is like part 2 (classifation), but now
% classification confusions are computed and visualized
%
% set arguments for the measure, ensuring that the predictions (instead
% of classification accuracies) are returned
measure=@cosmo_crossvalidation_measure;
measure_args=struct();
measure_args.partitions=cosmo_nfold_partitioner(ds);
measure_args.classifier=@cosmo_classify_lda;
measure_args.output='predictions';

% apply searchlight using the dataset, neighborhood, measure, and measure
% arguments; store the result in 'ds_confusion'
% >@@>
ds_confusion=cosmo_searchlight(ds,nbrhood,measure,measure_args);
% <@@<

% show contents of ds_confusion
cosmo_disp(ds_confusion);

% convert to array form (nclasses x nclasses x nrois, with nclasses=6 and
% nrois=2) and assign the result to a variable 'mx_confusion'
% Hint: use cosmo_confusion_matrix and apply it to 'ds_confusion' directly
% >@@>
mx_confusion=cosmo_confusion_matrix(ds_confusion);
% <@@<

% visualize the confusion matrices

classes= {'monkey','lemur','mallard','warbler','ladybug','lunamoth'};
nmatrices=size(mx_confusion,3);
for k=1:nmatrices
    % >@@>
    figure()
    imagesc(mx_confusion(:,:,k),[0 10]);
    title(ds_confusion.fa.roi_names{k});
    set(gca, 'xtick', 1:numel(classes), 'xticklabel', classes)
    set(gca, 'ytick', 1:numel(classes), 'yticklabel', classes)
    colorbar();
    % <@@<
end

















##### SOURCE END #####
--></body></html>

<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>MEEG time-frequency searchlight</title><meta name="generator" content="MATLAB 8.5"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2016-12-01"><meta name="DC.source" content="demo_meeg_timefreq_searchlight.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>MEEG time-frequency searchlight</h1><!--introduction--><p>This example shows MVPA analyses performed on MEEG data, using a searchlight across the time, frequency and channel dimensions</p><p>The input dataset involved a paradigm with electrical median nerve stimulation for durations of 2s at 20Hz.</p><p>The code presented here can be adapted for other MEEG analyses, but there are a few potential caveats: * assignment of targets (labels of conditions) is based here on   stimulation periods versus pre-stimulation periods. In typical   analyses the targets should be based on different trial conditions, for   example as set a FieldTrip .trialinfo field. * assignment of chunks (parts of the data that are assumed to be   independent) is based on a trial-by-trial basis. For cross-validation,   the number of chunks is reduced to two to speed up the analysis. * the time window used for analyses is rather small. This means that in   particular for time-freq analysis a lot of data is missing, especially   for early and late timepoints in the lower frequency bands. For typical   analyses it may be preferred to use a wider time window. * the current examples do not perform baseline corrections or signal   normalizations, which may reduce discriminatory power.</p><p>Note: running this code requires FieldTrip.</p><div><ol><li>For CoSMoMVPA's copyright information and license terms,   #</li><li>see the COPYING file distributed with CoSMoMVPA.           #</li></ol></div><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">get timelock data in CoSMoMVPA format</a></li><li><a href="#2">set MVPA parameters</a></li><li><a href="#3">run searchlight</a></li><li><a href="#4">visualize results</a></li></ul></div><h2>get timelock data in CoSMoMVPA format<a name="1"></a></h2><pre class="codeinput"><span class="comment">% set configuration</span>
config=cosmo_config();
data_path=fullfile(config.tutorial_data_path,<span class="string">'meg_20hz'</span>);

<span class="comment">% show dataset information</span>
readme_fn=fullfile(data_path,<span class="string">'README'</span>);
cosmo_type(readme_fn);

<span class="comment">% reset citation list</span>
cosmo_check_external(<span class="string">'-tic'</span>);

<span class="comment">% load data</span>
data_fn=fullfile(data_path,<span class="string">'subj102_B01_20Hz_timefreq.mat'</span>);
data_tf=load(data_fn);

<span class="comment">% convert to cosmomvpa struct</span>
ds_tf=cosmo_meeg_dataset(data_tf);

<span class="comment">% set the target (trial condition)</span>
ds_tf.sa.targets=ds_tf.sa.trialinfo(:,1); <span class="comment">% 1=pre, 2=post</span>

<span class="comment">% set the chunks (independent measurements)</span>
<span class="comment">% in this dataset, the first half of the samples (in order)</span>
<span class="comment">% are the post-trials;</span>
<span class="comment">% the second half the pre-trials</span>
ds_tf.sa.chunks=[(1:145) (1:145)]';


<span class="comment">% in addition give a label to each trial</span>
index2label={<span class="string">'pre'</span>,<span class="string">'post'</span>}; <span class="comment">% 1=pre, 2=peri/post</span>
ds_tf.sa.labels=cellfun(@(x)index2label(x),num2cell(ds_tf.sa.targets));

<span class="comment">% just to check everything is ok</span>
cosmo_check_dataset(ds_tf);

<span class="comment">% get rid of features with at least one NaN value across samples</span>
fa_nan_mask=sum(isnan(ds_tf.samples),1)&gt;0;
fprintf(<span class="string">'%d / %d features have NaN\n'</span>, <span class="keyword">...</span>
            sum(fa_nan_mask), numel(fa_nan_mask));
ds_tf=cosmo_slice(ds_tf, ~fa_nan_mask, 2);
</pre><pre class="codeoutput">Summary
-------
MEG data in raw, time-locked and time-frequency formats.

Contents
--------
- subj102_B01_20Hz.fif            raw MEG recording
- preproc.m                       Matlab preprocessing script (based on 
                                  FieldTrip)
- subj102_B01_20Hz_timefreq.mat   Time-locked data (generated by preproc.m)
- subj102_B01_20Hz_timelock.mat   Time-frequency data  (generated by preproc.m)
- LICENSE                         License file 
- README                          This file

Methods
-------
The dataset involved a paradigm with electrical median nerve stimulation with a 
human participant for durations of 2s at 20Hz. Data was acquired at 1khz using 
a neuromag306 system. 
Trial info in the .mat files: 1=pre-stimulus, 2=peri/post-stimulus

License
-------
The contents are made available by Nathan Weisz &lt;nathanweisz |at| me.com&gt; and 
Gianpaolo Demarchi &lt;gianpaolo.demarchi |at| unitn.it&gt; under the Creative 
Commons CC0 1.0 Universal Public Domain Dedication ("CC0"). See the LICENSE 
file for details, or visit 
http://creativecommons.org/publicdomain/zero/1.0/deed.en.

Acknowledgements
----------------
Thanks to Nathan Weisz and Gianpaolo Demarchi for providing this dataset, and 
an anonymous participant for volunteering during the recordings.

Contact
-------
Nikolaas N. Oosterhof &lt;nikolaas.oosterhof |at| unitn.it&gt;
16968 / 92718 features have NaN
</pre><h2>set MVPA parameters<a name="2"></a></h2><pre class="codeinput">fprintf(<span class="string">'The input has feature dimensions %s\n'</span>, <span class="keyword">...</span>
                cosmo_strjoin(ds_tf.a.fdim.labels,<span class="string">', '</span>));


<span class="comment">% set chunks</span>
<span class="comment">% again for speed just two chunks</span>
<span class="comment">% (targets were already set above)</span>
nchunks=2;
ds_tf.sa.chunks=cosmo_chunkize(ds_tf, nchunks);

<span class="comment">% define neighborhood parameters for each dimension</span>

<span class="comment">% channel neighborhood uses meg_combined_from_planar, which means that the</span>
<span class="comment">% input are planar channels but the output has combined-planar channels.</span>
<span class="comment">% to use the magnetometers, use 'meg_axial'</span>
chan_type=<span class="string">'meg_combined_from_planar'</span>;
chan_count=10;        <span class="comment">% use 10 channel locations (relative to the combined</span>
                      <span class="comment">% planar channels)</span>
                      <span class="comment">% as we use meg_combined_from_planar there are</span>
                      <span class="comment">% 20 channels in each searchlight because</span>
                      <span class="comment">% gradiometers are paired</span>
time_radius=2; <span class="comment">% 2*2+1=5 time bines</span>
freq_radius=4; <span class="comment">% 4*2+1=9 freq bins</span>


<span class="comment">% define the neighborhood for each dimensions</span>
chan_nbrhood=cosmo_meeg_chan_neighborhood(ds_tf, <span class="string">'count'</span>, chan_count, <span class="keyword">...</span>
                                                <span class="string">'chantype'</span>, chan_type);
freq_nbrhood=cosmo_interval_neighborhood(ds_tf,<span class="string">'freq'</span>,<span class="keyword">...</span>
                                            <span class="string">'radius'</span>,freq_radius);
time_nbrhood=cosmo_interval_neighborhood(ds_tf,<span class="string">'time'</span>,<span class="keyword">...</span>
                                            <span class="string">'radius'</span>,time_radius);

<span class="comment">% cross neighborhoods for chan-time-freq searchlight</span>
nbrhood=cosmo_cross_neighborhood(ds_tf,{chan_nbrhood,<span class="keyword">...</span>
                                        freq_nbrhood,<span class="keyword">...</span>
                                        time_nbrhood});

<span class="comment">% print some info</span>
nbrhood_nfeatures=cellfun(@numel,nbrhood.neighbors);
fprintf(<span class="string">'Features have on average %.1f +/- %.1f neighbors\n'</span>, <span class="keyword">...</span>
            mean(nbrhood_nfeatures), std(nbrhood_nfeatures));

<span class="comment">% only keep features with at least 10 neighbors</span>
<span class="comment">% (some have zero neighbors - in particular, those with low frequencies</span>
<span class="comment">% early or late in time)</span>
center_ids=find(nbrhood_nfeatures&gt;10);

<span class="comment">% for illustration purposes use the split-half measure because it is</span>
<span class="comment">% relatively fast - but clasifiers can also be used</span>
measure=@cosmo_correlation_measure;

<span class="comment">% split-half, as there are just two chunks</span>
<span class="comment">% (when using a classifier, do not use 'half' but the number of chunks to</span>
<span class="comment">% leave out for testing, e.g. 1).</span>
measure_args=struct();
measure_args.partitions=cosmo_nchoosek_partitioner(ds_tf,<span class="string">'half'</span>);
</pre><pre class="codeoutput">The input has feature dimensions chan, freq, time
+00:00:13 [####################] -00:00:00  crossing neighborhoods
Features have on average 625.9 +/- 244.2 neighbors
</pre><h2>run searchlight<a name="3"></a></h2><pre class="codeinput">sl_tf_ds=cosmo_searchlight(ds_tf,nbrhood,measure,measure_args,<span class="keyword">...</span>
                                      <span class="string">'center_ids'</span>,center_ids);
</pre><pre class="codeoutput">+00:02:07 [####################] -00:00:00  
</pre><h2>visualize results<a name="4"></a></h2><pre class="codeinput"><span class="comment">% deduce layout from output</span>
layout=cosmo_meeg_find_layout(sl_tf_ds);
fprintf(<span class="string">'The output uses layout %s\n'</span>, layout.name);

<span class="comment">% map to FT struct for visualization</span>
sl_tf_ft=cosmo_map2meeg(sl_tf_ds);

<span class="comment">% show figure</span>
figure()
cfg = [];
<span class="keyword">if</span> cosmo_wtf(<span class="string">'is_octave'</span>)
    <span class="comment">% GNU Octave does not show data when labels are shown</span>
    cfg.interactive=<span class="string">'no'</span>;
    cfg.showlabels=<span class="string">'no'</span>;
<span class="keyword">else</span>
    <span class="comment">% Matlab supports interactive viewing and labels</span>
    cfg.interactive = <span class="string">'yes'</span>;
    cfg.showlabels = <span class="string">'yes'</span>;
<span class="keyword">end</span>
cfg.zlim=<span class="string">'maxabs'</span>;
cfg.layout       = layout;
ft_multiplotTFR(cfg, sl_tf_ft);

<span class="comment">% Show citation information</span>
cosmo_check_external(<span class="string">'-cite'</span>);
</pre><pre class="codeoutput">The output uses layout neuromag306cmb.lay
the call to "ft_prepare_layout" took 0 seconds and required the additional allocation of an estimated 0 MB
the call to "ft_multiplotTFR" took 10 seconds and required the additional allocation of an estimated 17 MB
If you use CoSMoMVPA and/or some other toolboxes for a publication, please cite:

R. Oostenveld, P. Fries, E. Maris, J.-M. Schoffelen (2011). FieldTrip: Open Source Software for Advanced Analysis of MEG, EEG, and Invasive Electrophysiological Data, Computational Intelligence and Neuroscience, vol. 2011, Article ID 156869, 9 pages.doi:10.1155/2011/156869. FieldTrip toolbox available online from http://fieldtrip.fcdonders.nl

N. N. Oosterhof, A. C. Connolly, J. V. Haxby (2016). CoSMoMVPA: multi-modal multivariate pattern analysis of neuroimaging data in Matlab / GNU Octave. Frontiers in Neuroinformatics, doi:10.3389/fninf.2016.00027.. CoSMoMVPA toolbox available online from http://cosmomvpa.org

The Mathworks, Natick, MA, United States. Matlab 8.5.0.197613 (R2015a) (February 12, 2015). available online from http://www.mathworks.com

</pre><img vspace="5" hspace="5" src="demo_meeg_timefreq_searchlight_01.png" alt=""> <p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2015a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% MEEG time-frequency searchlight
%
% This example shows MVPA analyses performed on MEEG data, using a
% searchlight across the time, frequency and channel dimensions
%
% The input dataset involved a paradigm with electrical median nerve
% stimulation for durations of 2s at 20Hz.
%
% The code presented here can be adapted for other MEEG analyses, but
% there are a few potential caveats:
% * assignment of targets (labels of conditions) is based here on
%   stimulation periods versus pre-stimulation periods. In typical
%   analyses the targets should be based on different trial conditions, for
%   example as set a FieldTrip .trialinfo field.
% * assignment of chunks (parts of the data that are assumed to be
%   independent) is based on a trial-by-trial basis. For cross-validation,
%   the number of chunks is reduced to two to speed up the analysis.
% * the time window used for analyses is rather small. This means that in
%   particular for time-freq analysis a lot of data is missing, especially
%   for early and late timepoints in the lower frequency bands. For typical
%   analyses it may be preferred to use a wider time window.
% * the current examples do not perform baseline corrections or signal
%   normalizations, which may reduce discriminatory power.
%
% Note: running this code requires FieldTrip.
%
% #   For CoSMoMVPA's copyright information and license terms,   #
% #   see the COPYING file distributed with CoSMoMVPA.           #


%% get timelock data in CoSMoMVPA format

% set configuration
config=cosmo_config();
data_path=fullfile(config.tutorial_data_path,'meg_20hz');

% show dataset information
readme_fn=fullfile(data_path,'README');
cosmo_type(readme_fn);

% reset citation list
cosmo_check_external('-tic');

% load data
data_fn=fullfile(data_path,'subj102_B01_20Hz_timefreq.mat');
data_tf=load(data_fn);

% convert to cosmomvpa struct
ds_tf=cosmo_meeg_dataset(data_tf);

% set the target (trial condition)
ds_tf.sa.targets=ds_tf.sa.trialinfo(:,1); % 1=pre, 2=post

% set the chunks (independent measurements)
% in this dataset, the first half of the samples (in order)
% are the post-trials;
% the second half the pre-trials
ds_tf.sa.chunks=[(1:145) (1:145)]';


% in addition give a label to each trial
index2label={'pre','post'}; % 1=pre, 2=peri/post
ds_tf.sa.labels=cellfun(@(x)index2label(x),num2cell(ds_tf.sa.targets));

% just to check everything is ok
cosmo_check_dataset(ds_tf);

% get rid of features with at least one NaN value across samples
fa_nan_mask=sum(isnan(ds_tf.samples),1)>0;
fprintf('%d / %d features have NaN\n', ...
            sum(fa_nan_mask), numel(fa_nan_mask));
ds_tf=cosmo_slice(ds_tf, ~fa_nan_mask, 2);


%% set MVPA parameters
fprintf('The input has feature dimensions %s\n', ...
                cosmo_strjoin(ds_tf.a.fdim.labels,', '));


% set chunks
% again for speed just two chunks
% (targets were already set above)
nchunks=2;
ds_tf.sa.chunks=cosmo_chunkize(ds_tf, nchunks);

% define neighborhood parameters for each dimension

% channel neighborhood uses meg_combined_from_planar, which means that the
% input are planar channels but the output has combined-planar channels.
% to use the magnetometers, use 'meg_axial'
chan_type='meg_combined_from_planar';
chan_count=10;        % use 10 channel locations (relative to the combined
                      % planar channels)
                      % as we use meg_combined_from_planar there are
                      % 20 channels in each searchlight because
                      % gradiometers are paired
time_radius=2; % 2*2+1=5 time bines
freq_radius=4; % 4*2+1=9 freq bins


% define the neighborhood for each dimensions
chan_nbrhood=cosmo_meeg_chan_neighborhood(ds_tf, 'count', chan_count, ...
                                                'chantype', chan_type);
freq_nbrhood=cosmo_interval_neighborhood(ds_tf,'freq',...
                                            'radius',freq_radius);
time_nbrhood=cosmo_interval_neighborhood(ds_tf,'time',...
                                            'radius',time_radius);

% cross neighborhoods for chan-time-freq searchlight
nbrhood=cosmo_cross_neighborhood(ds_tf,{chan_nbrhood,...
                                        freq_nbrhood,...
                                        time_nbrhood});

% print some info
nbrhood_nfeatures=cellfun(@numel,nbrhood.neighbors);
fprintf('Features have on average %.1f +/- %.1f neighbors\n', ...
            mean(nbrhood_nfeatures), std(nbrhood_nfeatures));

% only keep features with at least 10 neighbors
% (some have zero neighbors - in particular, those with low frequencies
% early or late in time)
center_ids=find(nbrhood_nfeatures>10);

% for illustration purposes use the split-half measure because it is
% relatively fast - but clasifiers can also be used
measure=@cosmo_correlation_measure;

% split-half, as there are just two chunks
% (when using a classifier, do not use 'half' but the number of chunks to
% leave out for testing, e.g. 1).
measure_args=struct();
measure_args.partitions=cosmo_nchoosek_partitioner(ds_tf,'half');


%% run searchlight
sl_tf_ds=cosmo_searchlight(ds_tf,nbrhood,measure,measure_args,...
                                      'center_ids',center_ids);
%% visualize results

% deduce layout from output
layout=cosmo_meeg_find_layout(sl_tf_ds);
fprintf('The output uses layout %s\n', layout.name);

% map to FT struct for visualization
sl_tf_ft=cosmo_map2meeg(sl_tf_ds);

% show figure
figure()
cfg = [];
if cosmo_wtf('is_octave')
    % GNU Octave does not show data when labels are shown
    cfg.interactive='no';
    cfg.showlabels='no';
else
    % Matlab supports interactive viewing and labels
    cfg.interactive = 'yes';
    cfg.showlabels = 'yes';
end
cfg.zlim='maxabs';
cfg.layout       = layout;
ft_multiplotTFR(cfg, sl_tf_ft);

% Show citation information
cosmo_check_external('-cite');


##### SOURCE END #####
--></body></html>